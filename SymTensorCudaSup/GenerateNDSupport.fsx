open System.Text
open System.IO

let maxDims = 6
let maxArity = 6

let combineWith sep items =    
    let rec combine items = 
        match items with
        | [item] -> item
        | item::rest -> item + sep + combine rest
        | [] -> ""
    items |> Seq.toList |> combine

let combineWithButIfEmpty empty sep items =
    if Seq.isEmpty items then empty
    else combineWith sep items

let sw = new StringWriter()
let prn = sprintf
let cw = combineWith
let cwe = combineWithButIfEmpty
let (|>>) seq mapFun = Seq.map mapFun seq

let wrt frmt = fprintfn sw frmt
 
wrt "// this file is automatically generated by GenerateNDSupport.fsx"
wrt "#pragma once"
wrt """#include "Utils.cuh" """
wrt ""  

for dims = 0 to maxDims do
    let ad = {0 .. dims-1}
    
    wrt "// ======================== dimensionality: %d ==================================" dims
    wrt ""

    wrt "struct Pos%dD {" dims
    wrt "   size_t pos[%d];" (max dims 1)
    wrt"    template<typename TArrayND>"
    wrt "   _dev static Pos%dD fromLinearIdx(const TArrayND &ary, size_t idx) {" dims
    wrt "     Pos%dD p;" dims
    if dims >= 1 then
        wrt "     const size_t incr%d = 1;" (dims-1)
    for d = dims - 2 downto 0 do
        wrt "     const size_t incr%d = incr%d * ary.shape(%d);" d (d+1) (d+1)
    for d = 0 to dims - 1 do
        wrt "     p.pos[%d] = idx / incr%d;" d d
        wrt "     idx -= p.pos[%d] * incr%d;" d d
    if dims = 0 then
        // to silence compiler warning
        wrt "     p.pos[0] = 0;"
    wrt "     return p;"
    wrt "   }"
    wrt"    template<typename TArrayND>"
    wrt "   _dev static Pos%dD fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, size_t idx) {" dims
    wrt "     Pos%dD p = fromLinearIdx(ary, idx);" dims 
    if dims >= 1 then
        wrt "     p[%d] = 0;" (dims - 1)
    wrt "     return p;"
    wrt "    }"
    wrt "    template<typename TArrayND>"
    wrt "   _dev size_t toLinearIdx(const TArrayND &ary) const {"
    if dims >= 1 then
        wrt "     const size_t incr%d = 1;" (dims-1)
    for d = dims - 2 downto 0 do
        wrt "     const size_t incr%d = incr%d * ary.shape(%d);" d (d+1) (d+1)
    wrt "     return %s;" (ad |>> (fun i -> prn "incr%d * pos[%d]" i i) |> cwe "0" " + ")
    wrt "   }"
    wrt "  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }"
    wrt "  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }"
    wrt "};"
    wrt ""
    
    if dims > 0 then
        wrt "template <%s>" (ad |>> prn "size_t shape%d" |> cw ", ")
    wrt "struct ShapeStatic%dD {" dims
    wrt "   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes"
    wrt "  	_dev size_t shape(const size_t dim) const {"
    if dims > 0 then
        wrt "      switch (dim) {"
        for d in ad do
            wrt "        case %d: return shape%d;" d d
        wrt "        default: return 0;"
        wrt "      }"
    else
        wrt "      return 0;"
    wrt "   }"
    wrt "};"
    wrt ""

    wrt "struct ShapeDynamic%dD {" dims
    if dims > 0 then
        wrt "   size_t mShape[%d];" dims
        wrt "  	_dev size_t shape(const size_t dim) const { return mShape[dim]; }"
    else
        wrt "  	_dev size_t shape(const size_t dim) const { return 0; }"
    wrt "};"
    wrt ""

    if dims = 0 then
        wrt "template <size_t offset_>"
    else
        wrt "template <size_t offset_, %s>" (ad |>> prn "size_t stride%d" |> cw ", ")
    wrt "struct StrideStatic%dD {" dims
    wrt "   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes"
    wrt "  	_dev size_t stride(const size_t dim) const {"
    wrt "      switch (dim) {"
    for d in ad do
        wrt "        case %d: return stride%d;" d d
    wrt "        default: return 0;"
    wrt "      }"
    wrt "    }"
    wrt "   _dev size_t offset() const { return offset_; }"
    wrt "};"
    wrt ""

    wrt "struct StrideDynamic%dD {" dims
    wrt "   size_t mOffset;"
    wrt "   _dev size_t offset() const { return mOffset; }"
    if dims > 0 then
        wrt "   size_t mStride[%d];" dims
        wrt "  	_dev size_t stride(const size_t dim) const { return mStride[dim]; }"
    else
        wrt "  	_dev size_t stride(const size_t dim) const { return 0; }"
    wrt "};"
    wrt ""

    wrt "template <typename TData, typename TShape, typename TStride>"
    wrt "struct ArrayND%dD : TShape, TStride {" dims
    wrt "  typedef Pos%dD Pos;" dims
    wrt "  typedef TData DataType;"
    wrt "  TData *mData;"
    wrt ""
    wrt "  _dev size_t nDim() const { return %d; }" dims
    wrt "  _dev size_t index(%s) const {"
        (ad |>> prn "const size_t pos%d" |> cw ", ")
    wrt "      return this->offset() + %s;"
        (ad |>> (fun i -> prn "this->stride(%d) * pos%d" i i) |> cwe "0" " + ")
    wrt "  }"
    wrt "  _dev size_t index(const size_t *pos) const {"
    wrt "      return this->offset() + %s;"
        (ad |>> (fun i -> prn "this->stride(%d) * pos[%d]" i i) |> cwe "0" " + ")
    wrt "  }"
    wrt "  _dev size_t index(const Pos%dD &pos) const {" dims
    wrt "      return this->offset() + %s;"
        (ad |>> (fun i -> prn "this->stride(%d) * pos[%d]" i i) |> cwe "0" " + ")
    wrt "  }"
    wrt "  _dev size_t size() const {"
    wrt "    return %s;"
        (ad |>> prn "this->shape(%d)" |> cwe "1" " * ")
    wrt "  }"
    wrt "  _dev Pos%dD linearIdxToPos(size_t idx) const { return Pos%dD::fromLinearIdx(*this, idx); }" dims dims
    wrt "  _dev Pos%dD linearIdxToPosWithLastDimSetToZero(size_t idx) const { return Pos%dD::fromLinearIdxWithLastDimSetToZero(*this, idx); }" dims dims
    wrt "  _dev TData *data() { return mData; }"
    wrt "  _dev const TData *data() const { return mData; }"
    wrt "  _dev TData &element(%s) {"
        (ad |>> prn "size_t pos%d" |> cw ", ")
    wrt "    return data()[index(%s)];"
        (ad |>> prn "pos%d" |> cw ", ")
    wrt "  }"
    wrt "  _dev const TData &element(%s) const {"
        (ad |>> prn "size_t pos%d" |> cw ", ")
    wrt "    return data()[index(%s)];"
        (ad |>> prn "pos%d" |> cw ", ")
    wrt "  }"
    wrt "  _dev TData &element(const size_t *pos) { return data()[index(pos)]; }"
    wrt "  _dev const TData &element(const size_t *pos) const { return data()[index(pos)]; }"
    wrt "  _dev TData &element(const Pos%dD &pos) { return data()[index(pos)]; }" dims
    wrt "  _dev const TData &element(const Pos%dD &pos) const { return data()[index(pos)]; }" dims
    wrt ""
    wrt "  template <typename TElemwiseOp, typename TTarget, typename TSrc0>"
    wrt "  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {"
    wrt "    elemwise1Ary%dD(op, trgt, src0);" dims
    wrt "  }"
    wrt "};"
    wrt ""

    let elementwiseLoop withPosArray fBody =
        wrt "" 
        if dims > 3 then
            let restElements = 
                {2 .. dims - 1} |> Seq.map (sprintf "trgt.shape(%d)") |> combineWith " * "
            wrt "    const size_t itersRest = divCeil(%s, gridDim.z * blockDim.z);" restElements
        if dims = 3 then
            wrt "    const size_t iters2 = divCeil(trgt.shape(2), gridDim.z * blockDim.z);"
        if dims >= 2 then
            wrt "    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);"
        if dims >= 1 then
            wrt "    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);"

        if dims > 3 then
            wrt "    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {"
        if dims = 3 then
            wrt "    for (size_t iter2 = 0; iter2 < iters2; iter2++) {"
        if dims >= 2 then
            wrt "    for (size_t iter1 = 0; iter1 < iters1; iter1++) {"
        if dims >= 1 then
            wrt "    for (size_t iter0 = 0; iter0 < iters0; iter0++) {"

        if dims > 3 then
            wrt "    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);"
            wrt "    const size_t incr2 = 1;"
            for d = 3 to dims - 1 do
                wrt "    const size_t incr%d = incr%d * trgt.shape(%d);" d (d-1) (d-1)
            for d = dims - 1 downto 2 do
                wrt "    const size_t pos%d = posRest / incr%d;" d d
                wrt "    posRest -= pos%d * incr%d;" d d
        if dims = 3 then
            wrt "    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);"
        if dims >= 2 then
            wrt "    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);"
        if dims >= 1 then
            wrt "    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);"
    
            wrt "    if (%s) {"
                (ad |>> (fun i -> prn "(pos%d < trgt.shape(%d))" i i) |> cw " && ")

        if withPosArray then
            let poses = ad |> Seq.map (sprintf "pos%d")
            if dims >= 1 then
                wrt "    const size_t pos[] {%s};" (poses |> cw ", ")
            else
                wrt "    const size_t *pos = nullptr;"

        wrt ""
        fBody dims
        wrt ""

        if dims >= 1 then
            wrt "    }"

        if dims >= 1 then
            wrt "    }"
        if dims >= 2 then
            wrt "    }"
        if dims >= 3 then
            wrt "    }"   


    let elementwiseWrapper ary withIndexes =
        let srcTmpl = 
            {0 .. ary - 1} |> Seq.map (sprintf "typename TSrc%d") |> Seq.toList
        let allTmpl = "typename TTarget" :: srcTmpl
        wrt "template <typename TElemwiseOp, %s>" (allTmpl |> cw ", ")

        let srcArgDecls =
            {0 .. ary - 1} |> Seq.map (fun i -> sprintf "const TSrc%d &src%d" i i) |> Seq.toList
        let allArgDecls = "const TElemwiseOp &op" :: "TTarget &trgt" :: srcArgDecls
        let indexedName = if withIndexes then "Indexed" else ""
        wrt "_dev void elemwise%dAry%dD%s(%s) {" ary dims indexedName (allArgDecls |> cw ", ")

        elementwiseLoop withIndexes (fun dims ->      
            let poses = ad |>> prn "pos%d" |> cw ", "
            let srcArgs = {0 .. ary - 1} |> Seq.map (fun a -> sprintf "src%d.element(%s)" a poses) |> Seq.toList
            let allArgs = if withIndexes then "pos" :: sprintf "%d" dims :: srcArgs else srcArgs
            wrt "  trgt.element(%s) = op(%s);" poses (allArgs |> cw ", "))        
        wrt "}"
        wrt ""

    for ary = 0 to maxArity do
        for withIndexes in [true; false] do
            elementwiseWrapper ary withIndexes

    let reduceWrapper () =
        wrt "template <typename TElemwiseOp, typename TTarget, typename TSrc>" 
        wrt "_dev void reduceTo%dD(const TElemwiseOp &op, const typename TTarget::DataType &initial, TTarget &trgt, const TSrc &src) {" dims
        elementwiseLoop false (fun dims ->      
            let trgtPoses = ad |>> prn "pos%d" |> cw ", "           
            let srcPoses = Seq.append (ad |>> prn "pos%d") (Seq.singleton "reducePos") |> cw ", "
            wrt "  typename TTarget::DataType v = initial;"
            wrt "  for (size_t reducePos = 0; reducePos < src.shape(%d); reducePos++) {" dims
            wrt "    v = op(v, src.element(%s));" srcPoses
            wrt "  }"
            wrt "  trgt.element(%s) = v;" trgtPoses)
        wrt "}"
        wrt ""
    reduceWrapper()

    let elementsWrapper ary =
        let srcTmpl = 
            {0 .. ary - 1} |> Seq.map (sprintf "typename TSrc%d") |> Seq.toList
        let allTmpl = "typename TTarget" :: srcTmpl
        wrt "template <typename TElementsOp, %s>" (allTmpl |> cw ", ")

        let srcArgDecls =
            {0 .. ary - 1} |> Seq.map (fun i -> sprintf "const TSrc%d &src%d" i i) |> Seq.toList
        let allArgDecls = "const TElementsOp &op" :: "TTarget &trgt" :: srcArgDecls
        wrt "_dev void elements%dAry%dD(%s) {" ary dims (allArgDecls |> cw ", ")

        elementwiseLoop false (fun dims ->      
            let poses = ad |>> prn "pos%d" |> Seq.toList
            let srcArgs = {0 .. ary - 1} |> Seq.map (fun a -> sprintf "src%d" a) |> Seq.toList
            let opArgs = poses @ srcArgs 
            wrt "  trgt.element(%s) = op(%s);" (poses |> cw ", ") (opArgs |> cw ", "))        
        wrt "}"
        wrt ""

    for ary = 0 to maxArity do
        elementsWrapper ary 

let elementwiseHeterogenousLoop fBody =
    wrt "" 
    wrt "    const size_t iters = divCeil(trgt.size(), gridDim.x * blockDim.x);" 
    wrt "    for (size_t iter = 0; iter < iters; iter++) {"
    wrt "    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);"   
    wrt "    if (idx < trgt.size()) {"

    wrt ""
    fBody ()
    wrt ""

    wrt "    }"
    wrt "    }"

let elementwiseHeterogenousWrapper ary =
    let srcTmpl = 
        {0 .. ary - 1} |> Seq.map (sprintf "typename TSrc%d") |> Seq.toList
    let allTmpl = "typename TTarget" :: srcTmpl
    wrt "template <typename TElemwiseOp, %s>" (allTmpl |> cw ", ")

    let srcArgDecls =
        {0 .. ary - 1} |> Seq.map (fun i -> sprintf "const TSrc%d &src%d" i i) |> Seq.toList
    let allArgDecls = "const TElemwiseOp &op" :: "TTarget &trgt" :: srcArgDecls
    wrt "_dev void elemwise%dAryHeterogenous(%s) {" ary (allArgDecls |> cw ", ")        
    elementwiseHeterogenousLoop (fun () ->      
        let srcArgs = 
            {0 .. ary - 1} 
            |> Seq.map (fun a -> sprintf "src%d.element(src%d.linearIdxToPos(idx))" a a) 
            |> Seq.toList
        let allArgs = srcArgs
        wrt "  trgt.element(trgt.linearIdxToPos(idx)) = op(%s);" (allArgs |> cw ", "))        
    wrt "}"
    wrt ""

for ary = 0 to maxArity do
    elementwiseHeterogenousWrapper ary


// save only if content changed to preserve modification time
let contents = sw.ToString ()
let outFilename = "NDSupport.cuh"
if not (File.Exists outFilename && File.ReadAllText outFilename = contents) then
    File.WriteAllText (outFilename, contents)


