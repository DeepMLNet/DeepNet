open System.Text
open System.IO

//exit 0

let maxDims = 7
let maxArity = 30

let combineWith sep items =    
    let rec combine items = 
        match items with
        | [item] -> item
        | item::rest -> item + sep + combine rest
        | [] -> ""
    items |> Seq.toList |> combine

let combineWithButIfEmpty empty sep items =
    if Seq.isEmpty items then empty
    else combineWith sep items

let sw = new StringWriter()
let prn = sprintf
let cw = combineWith
let cwe = combineWithButIfEmpty
let (|>>) seq mapFun = Seq.map mapFun seq

let wrt frmt = fprintfn sw frmt
 
wrt "// this file is automatically generated by GenerateNDSupport.fsx"
wrt "#pragma once"
wrt """#include "Utils.cuh" """
wrt ""  

for dims = 0 to maxDims do
    let ad = {0 .. dims-1}
    
    wrt "// ======================== dimensionality: %d ==================================" dims
    wrt ""

    wrt "struct Pos%dD {" dims
    wrt "   idx_t pos[%d];" (max dims 1)
    wrt"    template<typename TArrayND>"
    wrt "   _dev static Pos%dD fromLinearIdx(const TArrayND &ary, idx_t idx) {" dims
    wrt "     Pos%dD p;" dims
    if dims >= 1 then
        wrt "     const idx_t incr%d = 1;" (dims-1)
    for d = dims - 2 downto 0 do
        wrt "     const idx_t incr%d = incr%d * ary.shape(%d);" d (d+1) (d+1)
    for d = 0 to dims - 1 do
        wrt "     p.pos[%d] = idx / incr%d;" d d
        wrt "     idx -= p.pos[%d] * incr%d;" d d
    if dims = 0 then
        // to silence compiler warning
        wrt "     p.pos[0] = 0;"
    wrt "     return p;"
    wrt "   }"
    wrt"    template<typename TArrayND>"
    wrt "   _dev static Pos%dD fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, idx_t idx) {" dims
    wrt "     Pos%dD p = fromLinearIdx(ary, idx);" dims 
    if dims >= 1 then
        wrt "     p[%d] = 0;" (dims - 1)
    wrt "     return p;"
    wrt "    }"
    wrt "    template<typename TArrayND>"
    wrt "   _dev idx_t toLinearIdx(const TArrayND &ary) const {"
    if dims >= 1 then
        wrt "     const idx_t incr%d = 1;" (dims-1)
    for d = dims - 2 downto 0 do
        wrt "     const idx_t incr%d = incr%d * ary.shape(%d);" d (d+1) (d+1)
    wrt "     return %s;" (ad |>> (fun i -> prn "incr%d * pos[%d]" i i) |> cwe "0" " + ")
    wrt "   }"
    wrt "  	_dev idx_t &operator[] (const idx_t dim) { return pos[dim]; }"
    wrt "  	_dev const idx_t &operator[] (const idx_t dim) const { return pos[dim]; }"
    wrt "};"
    wrt ""
    
    if dims > 0 then
        wrt "template <%s>" (ad |>> prn "idx_t shape%d" |> cw ", ")
    wrt "struct ShapeStatic%dD {" dims
    wrt "   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes"
    wrt "  	_dev idx_t shape(const idx_t dim) const {"
    if dims > 0 then
        wrt "      switch (dim) {"
        for d in ad do
            wrt "        case %d: return shape%d;" d d
        wrt "        default: return 0;"
        wrt "      }"
    else
        wrt "      return 0;"
    wrt "   }"
    wrt "};"
    wrt ""

    wrt "struct ShapeDynamic%dD {" dims
    if dims > 0 then
        wrt "   idx_t mShape[%d];" dims
        wrt "  	_dev idx_t shape(const idx_t dim) const { return mShape[dim]; }"
    else
        wrt "  	_dev idx_t shape(const idx_t dim) const { return 0; }"
    wrt "};"
    wrt ""

    if dims = 0 then
        wrt "template <idx_t offset_>"
    else
        wrt "template <idx_t offset_, %s>" (ad |>> prn "idx_t stride%d" |> cw ", ")
    wrt "struct StrideStatic%dD {" dims
    wrt "   char mDummy; // WORKAROUND: if struct is empty, MSVC and NVCC see different struct sizes"
    wrt "  	_dev idx_t stride(const idx_t dim) const {"
    wrt "      switch (dim) {"
    for d in ad do
        wrt "        case %d: return stride%d;" d d
    wrt "        default: return 0;"
    wrt "      }"
    wrt "    }"
    wrt "   _dev idx_t offset() const { return offset_; }"
    wrt "};"
    wrt ""

    wrt "struct StrideDynamic%dD {" dims
    wrt "   idx_t mOffset;"
    wrt "   _dev idx_t offset() const { return mOffset; }"
    if dims > 0 then
        wrt "   idx_t mStride[%d];" dims
        wrt "  	_dev idx_t stride(const idx_t dim) const { return mStride[dim]; }"
    else
        wrt "  	_dev idx_t stride(const idx_t dim) const { return 0; }"
    wrt "};"
    wrt ""

    wrt "template <typename TData, typename TShape, typename TStride>"
    wrt "struct ArrayND%dD : TShape, TStride {" dims
    wrt "  typedef Pos%dD Pos;" dims
    wrt "  typedef TData DataType;"
    wrt "  TData *mData;"
    wrt ""
    wrt "  _dev idx_t nDim() const { return %d; }" dims
    wrt "  _dev idx_t index(%s) const {"
        (ad |>> prn "const idx_t pos%d" |> cw ", ")
    wrt "      return this->offset() + %s;"
        (ad |>> (fun i -> prn "this->stride(%d) * pos%d" i i) |> cwe "0" " + ")
    wrt "  }"
    wrt "  _dev idx_t index(const idx_t *pos) const {"
    wrt "      return this->offset() + %s;"
        (ad |>> (fun i -> prn "this->stride(%d) * pos[%d]" i i) |> cwe "0" " + ")
    wrt "  }"
    wrt "  _dev idx_t index(const Pos%dD &pos) const {" dims
    wrt "      return this->offset() + %s;"
        (ad |>> (fun i -> prn "this->stride(%d) * pos[%d]" i i) |> cwe "0" " + ")
    wrt "  }"
    wrt "  _dev idx_t size() const {"
    wrt "    return %s;"
        (ad |>> prn "this->shape(%d)" |> cwe "1" " * ")
    wrt "  }"
    wrt "  _dev Pos%dD linearIdxToPos(idx_t idx) const { return Pos%dD::fromLinearIdx(*this, idx); }" dims dims
    wrt "  _dev Pos%dD linearIdxToPosWithLastDimSetToZero(idx_t idx) const { return Pos%dD::fromLinearIdxWithLastDimSetToZero(*this, idx); }" dims dims
    wrt "  _dev TData *data() { return mData; }"
    wrt "  _dev const TData *data() const { return mData; }"
    wrt "  _dev TData &element(%s) {"
        (ad |>> prn "idx_t pos%d" |> cw ", ")
    wrt "    return data()[index(%s)];"
        (ad |>> prn "pos%d" |> cw ", ")
    wrt "  }"
    wrt "  _dev const TData &element(%s) const {"
        (ad |>> prn "idx_t pos%d" |> cw ", ")
    wrt "    return data()[index(%s)];"
        (ad |>> prn "pos%d" |> cw ", ")
    wrt "  }"
    wrt "  _dev TData &element(const idx_t *pos) { return data()[index(pos)]; }"
    wrt "  _dev const TData &element(const idx_t *pos) const { return data()[index(pos)]; }"
    wrt "  _dev TData &element(const Pos%dD &pos) { return data()[index(pos)]; }" dims
    wrt "  _dev const TData &element(const Pos%dD &pos) const { return data()[index(pos)]; }" dims
    wrt ""
    wrt "  template <typename TElemwiseOp, typename TTarget, typename TSrc0>"
    wrt "  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {"
    wrt "    elemwise1Ary%dD(op, trgt, src0);" dims
    wrt "  }"
    wrt "};"
    wrt ""

    let elementwiseLoop workAry workDims withPosArray fBody =
        if workDims > 3 then
            let restElements = 
                {0 .. workDims-3} |> Seq.map (sprintf "%s.shape(%d)" workAry) |> combineWith " * "
            wrt " const idx_t restElems = %s;" restElements
            wrt " for (idx_t posR = threadIdx.z + blockIdx.z * blockDim.z; posR < restElems;     posR += gridDim.z * blockDim.z) {"
            wrt " idx_t pos%d = posR;" (workDims-3)
            for d = 0 to workDims-4 do
                let incr = 
                    {d+1 .. workDims-3} |> Seq.map (sprintf "%s.shape(%d)" workAry) |> combineWith " * "
                wrt " const idx_t pos%d = pos%d / (%s);" d (workDims-3) incr
                wrt " pos%d -= pos%d * (%s);" (workDims-3) d incr
        if workDims = 3 then
            wrt " for (idx_t pos%d = threadIdx.z + blockIdx.z * blockDim.z; pos%d < %s.shape(%d); pos%d += gridDim.z * blockDim.z) {" (workDims-3) (workDims-3) workAry (workDims-3) (workDims-3)
        if workDims >= 2 then
            wrt " for (idx_t pos%d = threadIdx.y + blockIdx.y * blockDim.y; pos%d < %s.shape(%d); pos%d += gridDim.y * blockDim.y) {" (workDims-2) (workDims-2) workAry (workDims-2) (workDims-2)
        if workDims >= 1 then
            wrt " for (idx_t pos%d = threadIdx.x + blockIdx.x * blockDim.x; pos%d < %s.shape(%d); pos%d += gridDim.x * blockDim.x) {" (workDims-1) (workDims-1) workAry (workDims-1) (workDims-1)

        if withPosArray then
            let poses = ad |> Seq.map (sprintf "pos%d")
            if workDims >= 1 then
                wrt " const idx_t pos[] {%s};" (poses |> cw ", ")
            else
                wrt " const idx_t *pos = nullptr;"

        wrt ""
        fBody workDims
        wrt ""

        if workDims >= 1 then
            wrt " }"
        if workDims >= 2 then
            wrt " }"
        if workDims >= 3 then
            wrt " }"   


    let elementwiseWrapper ary withIndexes =
        let srcTmpl = 
            {0 .. ary - 1} |> Seq.map (sprintf "typename TSrc%d") |> Seq.toList
        let allTmpl = "typename TTarget" :: srcTmpl
        wrt "template <typename TElemwiseOp, %s>" (allTmpl |> cw ", ")

        let srcArgDecls =
            {0 .. ary - 1} |> Seq.map (fun i -> sprintf "const TSrc%d &src%d" i i) |> Seq.toList
        let allArgDecls = "const TElemwiseOp &op" :: "TTarget &trgt" :: srcArgDecls
        let indexedName = if withIndexes then "Indexed" else ""
        wrt "_dev void elemwise%dAry%dD%s (%s) {" ary dims indexedName (allArgDecls |> cw ", ")

        elementwiseLoop "trgt" dims withIndexes (fun dims ->      
            let poses = ad |>> prn "pos%d" |> cw ", "
            let srcArgs = {0 .. ary - 1} |> Seq.map (fun a -> sprintf "src%d.element(%s)" a poses) |> Seq.toList
            let allArgs = if withIndexes then "pos" :: sprintf "%d" dims :: srcArgs else srcArgs
            wrt "  trgt.element(%s) = op(%s);" poses (allArgs |> cw ", "))        
        wrt "}"
        wrt ""

    for ary = 0 to maxArity do
        for withIndexes in [true; false] do
            elementwiseWrapper ary withIndexes

    let reduceWrapper () =
        wrt "template <typename TElemwiseOp, typename TInitialOp, typename TTarget, typename TSrc>" 
        wrt "_dev void reduceTo%dD (const TElemwiseOp &op, const TInitialOp &initialOp, TTarget &trgt, const TSrc &src) {" dims
        elementwiseLoop "trgt" dims false (fun dims ->      
            let trgtPoses = ad |>> prn "pos%d" |> cw ", "           
            let srcPoses = Seq.append (ad |>> prn "pos%d") (Seq.singleton "reducePos") |> cw ", "
            wrt "  typename TTarget::DataType v = initialOp();"
            wrt "  for (idx_t reducePos = 0; reducePos < src.shape(%d); reducePos++) {" dims
            wrt "    v = op(v, src.element(%s));" srcPoses
            wrt "  }"
            wrt "  trgt.element(%s) = v;" trgtPoses)
        wrt "}"
        wrt ""
    reduceWrapper()

    let elementsWrapper ary =
        let srcTmpl = 
            {0 .. ary - 1} |> Seq.map (sprintf "typename TSrc%d") |> Seq.toList
        let allTmpl = "typename TTarget" :: srcTmpl
        wrt "template <typename TElementsOp, %s>" (allTmpl |> cw ", ")

        let srcArgDecls =
            {0 .. ary - 1} |> Seq.map (fun i -> sprintf "const TSrc%d &src%d" i i) |> Seq.toList
        let allArgDecls = "const TElementsOp &op" :: "TTarget &trgt" :: srcArgDecls
        wrt "_dev void elements%dAry%dD (%s) {" ary dims (allArgDecls |> cw ", ")

        elementwiseLoop "trgt" dims false (fun dims ->      
            let poses = ad |>> prn "pos%d" |> Seq.toList
            let srcArgs = {0 .. ary - 1} |> Seq.map (fun a -> sprintf "src%d" a) |> Seq.toList
            let opArgs = poses @ srcArgs 
            wrt "  trgt.element(%s) = op(%s);" (poses |> cw ", ") (opArgs |> cw ", "))        
        wrt "}"
        wrt ""

    for ary = 0 to maxArity do
        elementsWrapper ary
        
    let checkPosFunc () = 
        let posArgDecls = ad |>> prn "idx_t pos%d" |> Seq.toList
        wrt "template <typename TAry>"
        wrt "_dev void checkPos%dD (const char *msg, const TAry &ary, %s) {" dims (posArgDecls |> cw ", ")
        let allChecks = ad |> Seq.map (fun d -> prn "(0 <= pos%d && pos%d < ary.shape(%d))" d d d)
        wrt "  if (!(%s)) {" (allChecks |> cw " && ")
        let allIdxFmt, allIdxVal = ad |> Seq.toList |> List.map (fun d -> "%d", sprintf "pos%d" d) |> List.unzip
        let allShpFmt, allShpVal = ad |> Seq.toList |> List.map (fun d -> "%d", sprintf "ary.shape(%d)" d) |> List.unzip
        wrt "    printf(\"Invalid index for %%s: [%s] is out of range for shape [%s].\\n\", msg, %s, %s);" 
            (allIdxFmt |> cw "; ") (allShpFmt |> cw "; ") (allIdxVal |> cw ", ") (allShpVal |> cw ", ")
        wrt "    __threadfence();"
        wrt "    __syncthreads();"
        wrt "    asm(\"trap;\");"
        wrt "  }"
        wrt "}"
        wrt ""

    if dims > 0 then checkPosFunc ()

    let gatherFunc trgtDims srcDims =    
        let idxTmpl = 
            {0 .. srcDims - 1} |> Seq.map (sprintf "typename TIdx%d") |> Seq.toList
        let allTmpl = "typename TTarget" :: "typename TSrc" :: idxTmpl
        wrt "template <%s>" (allTmpl |> cw ", ")
         
        let idxArgDecls =
            {0 .. srcDims - 1} |> Seq.map (fun i -> sprintf "const TIdx%d &idx%d" i i) |> Seq.toList
        let allArgDecls = "TTarget &trgt" :: "const TSrc &src" :: idxArgDecls
        wrt "_dev void gather%dDTo%dD (%s) {" srcDims trgtDims (allArgDecls |> cw ", ")

        elementwiseLoop "trgt" trgtDims false (fun _ ->      
            let trgtPoses = {0 .. trgtDims-1} |>> prn "pos%d" |> Seq.toList
            let srcPoses = [0 .. srcDims-1] |> List.map (fun d -> 
                if d < trgtDims then
                    wrt "  const idx_t srcPos%d = idx%d.data() ? idx%d.element(%s) : %s;" d d d (trgtPoses |> cw ", ") trgtPoses.[d]                    
                else
                    wrt "  const idx_t srcPos%d = idx%d.element(%s);" d d (trgtPoses |> cw ", ")
                sprintf "srcPos%d" d)
            if srcDims > 0 then
                wrt "  checkPos%dD (\"gather source\", src, %s);" srcDims (srcPoses |> cw ", ")
            wrt "  trgt.element(%s) = src.element(%s);" (trgtPoses |> cw ", ") (srcPoses |> cw ", ")
        )        
        wrt "}"
        wrt ""       

    let scatterFunc trgtDims srcDims =    
        let idxTmpl = 
            {0 .. trgtDims - 1} |> Seq.map (sprintf "typename TIdx%d") |> Seq.toList
        let allTmpl = "typename TTarget" :: "typename TSrc" :: idxTmpl
        wrt "template <%s>" (allTmpl |> cw ", ")
         
        let idxArgDecls =
            {0 .. trgtDims - 1} |> Seq.map (fun i -> sprintf "const TIdx%d &idx%d" i i) |> Seq.toList
        let allArgDecls = "TTarget &trgt" :: "const TSrc &src" :: idxArgDecls
        wrt "_dev void scatter%dDTo%dD (%s) {" srcDims trgtDims (allArgDecls |> cw ", ")

        elementwiseLoop "src" srcDims false (fun dims ->      
            let srcPoses = {0 .. srcDims-1} |>> prn "pos%d" |> Seq.toList
            let trgtPoses = [0 .. trgtDims-1] |> List.map (fun d -> 
                if d < srcDims then
                    wrt "  const idx_t trgtPos%d = idx%d.data() ? idx%d.element(%s) : %s;" d d d (srcPoses |> cw ", ") srcPoses.[d]
                else
                    wrt "  const idx_t trgtPos%d = idx%d.element(%s);" d d (srcPoses |> cw ", ")
                sprintf "trgtPos%d" d)
            if trgtDims > 0 then
                wrt "  checkPos%dD (\"scatter target\", trgt, %s);" trgtDims (trgtPoses |> cw ", ")
            wrt "  atomicAdd(&trgt.element(%s), src.element(%s));" (trgtPoses |> cw ", ") (srcPoses |> cw ", ") 
        )                    
        wrt "}"
        wrt ""       

    for srcDims=0 to maxDims do
        gatherFunc dims srcDims
        scatterFunc dims srcDims

let elementwiseHeterogenousLoop fBody =
    wrt " for (idx_t idx = threadIdx.x + blockIdx.x * blockDim.x; idx < trgt.size(); idx += gridDim.x * blockDim.x) {"
    wrt ""
    fBody ()
    wrt ""
    wrt " }"

let elementwiseHeterogenousWrapper ary =
    let srcTmpl = 
        {0 .. ary - 1} |> Seq.map (sprintf "typename TSrc%d") |> Seq.toList
    let allTmpl = "typename TTarget" :: srcTmpl
    wrt "template <typename TElemwiseOp, %s>" (allTmpl |> cw ", ")

    let srcArgDecls =
        {0 .. ary - 1} |> Seq.map (fun i -> sprintf "const TSrc%d &src%d" i i) |> Seq.toList
    let allArgDecls = "const TElemwiseOp &op" :: "TTarget &trgt" :: srcArgDecls
    wrt "_dev void elemwise%dAryHeterogenous(%s) {" ary (allArgDecls |> cw ", ")        
    elementwiseHeterogenousLoop (fun () ->      
        let srcArgs = 
            {0 .. ary - 1} 
            |> Seq.map (fun a -> sprintf "src%d.element(src%d.linearIdxToPos(idx))" a a) 
            |> Seq.toList
        let allArgs = srcArgs
        wrt "  trgt.element(trgt.linearIdxToPos(idx)) = op(%s);" (allArgs |> cw ", "))        
    wrt "}"
    wrt ""

for ary = 0 to maxArity do
    elementwiseHeterogenousWrapper ary


// save only if content changed to preserve modification time
let contents = sw.ToString ()
let outFilename = "NDSupport.cuh"
if not (File.Exists outFilename && File.ReadAllText outFilename = contents) then
    File.WriteAllText (outFilename, contents)


