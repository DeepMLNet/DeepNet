// this file is automatically generated by GenerateNDSupport.fsx
#pragma once
#include "Utils.cuh" 

// ======================== dimensionality: 0 ==================================

struct Pos0D {
   size_t pos[1];
    template<typename TArrayND>
   _dev static Pos0D fromLinearIdx(const TArrayND &ary, size_t idx) {
     Pos0D p;
     p.pos[0] = 0;
     return p;
   }
    template<typename TArrayND>
   _dev static Pos0D fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, size_t idx) {
     Pos0D p = fromLinearIdx(ary, idx);
     return p;
    }
    template<typename TArrayND>
   _dev size_t toLinearIdx(const TArrayND &ary) const {
     return 0;
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

struct ShapeStatic0D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t shape(const size_t dim) const {
      return 0;
   }
};

struct ShapeDynamic0D {
  	_dev size_t shape(const size_t dim) const { return 0; }
};

template <size_t offset_>
struct StrideStatic0D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t stride(const size_t dim) const {
      switch (dim) {
        default: return 0;
      }
    }
   _dev size_t offset() const { return offset_; }
};

struct StrideDynamic0D {
   size_t mOffset;
   _dev size_t offset() const { return mOffset; }
  	_dev size_t stride(const size_t dim) const { return 0; }
};

template <typename TData, typename TShape, typename TStride>
struct ArrayND0D : TShape, TStride {
  typedef Pos0D Pos;
  typedef TData DataType;
  TData *mData;

  _dev size_t nDim() const { return 0; }
  _dev size_t index() const {
      return this->offset() + 0;
  }
  _dev size_t index(const size_t *pos) const {
      return this->offset() + 0;
  }
  _dev size_t index(const Pos0D &pos) const {
      return this->offset() + 0;
  }
  _dev size_t size() const {
    return 1;
  }
  _dev Pos0D linearIdxToPos(size_t idx) const { return Pos0D::fromLinearIdx(*this, idx); }
  _dev Pos0D linearIdxToPosWithLastDimSetToZero(size_t idx) const { return Pos0D::fromLinearIdxWithLastDimSetToZero(*this, idx); }
  _dev TData *data() { return mData; }
  _dev const TData *data() const { return mData; }
  _dev TData &element() {
    return data()[index()];
  }
  _dev const TData &element() const {
    return data()[index()];
  }
  _dev TData &element(const size_t *pos) { return data()[index(pos)]; }
  _dev const TData &element(const size_t *pos) const { return data()[index(pos)]; }
  _dev TData &element(const Pos0D &pos) { return data()[index(pos)]; }
  _dev const TData &element(const Pos0D &pos) const { return data()[index(pos)]; }

  template <typename TElemwiseOp, typename TTarget, typename TSrc0>
  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {
    elemwise1Ary0D(op, trgt, src0);
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary0DIndexed(const TElemwiseOp &op, TTarget &trgt) {

    const size_t *pos = nullptr;

  trgt.element() = op(pos, 0);

}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary0D(const TElemwiseOp &op, TTarget &trgt) {


  trgt.element() = op();

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary0DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t *pos = nullptr;

  trgt.element() = op(pos, 0, src0.element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary0D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {


  trgt.element() = op(src0.element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary0DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t *pos = nullptr;

  trgt.element() = op(pos, 0, src0.element(), src1.element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary0D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {


  trgt.element() = op(src0.element(), src1.element());

}

// ======================== dimensionality: 1 ==================================

struct Pos1D {
   size_t pos[1];
    template<typename TArrayND>
   _dev static Pos1D fromLinearIdx(const TArrayND &ary, size_t idx) {
     Pos1D p;
     const size_t incr0 = 1;
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     return p;
   }
    template<typename TArrayND>
   _dev static Pos1D fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, size_t idx) {
     Pos1D p = fromLinearIdx(ary, idx);
     p[0] = 0;
     return p;
    }
    template<typename TArrayND>
   _dev size_t toLinearIdx(const TArrayND &ary) const {
     const size_t incr0 = 1;
     return incr0 * pos[0];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0>
struct ShapeStatic1D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t shape(const size_t dim) const {
      switch (dim) {
        case 0: return shape0;
        default: return 0;
      }
   }
};

struct ShapeDynamic1D {
   size_t mShape[1];
  	_dev size_t shape(const size_t dim) const { return mShape[dim]; }
};

template <size_t offset_, size_t stride0>
struct StrideStatic1D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t stride(const size_t dim) const {
      switch (dim) {
        case 0: return stride0;
        default: return 0;
      }
    }
   _dev size_t offset() const { return offset_; }
};

struct StrideDynamic1D {
   size_t mOffset;
   _dev size_t offset() const { return mOffset; }
   size_t mStride[1];
  	_dev size_t stride(const size_t dim) const { return mStride[dim]; }
};

template <typename TData, typename TShape, typename TStride>
struct ArrayND1D : TShape, TStride {
  typedef Pos1D Pos;
  typedef TData DataType;
  TData *mData;

  _dev size_t nDim() const { return 1; }
  _dev size_t index(const size_t pos0) const {
      return this->offset() + this->stride(0) * pos0;
  }
  _dev size_t index(const size_t *pos) const {
      return this->offset() + this->stride(0) * pos[0];
  }
  _dev size_t index(const Pos1D &pos) const {
      return this->offset() + this->stride(0) * pos[0];
  }
  _dev size_t size() const {
    return this->shape(0);
  }
  _dev Pos1D linearIdxToPos(size_t idx) const { return Pos1D::fromLinearIdx(*this, idx); }
  _dev Pos1D linearIdxToPosWithLastDimSetToZero(size_t idx) const { return Pos1D::fromLinearIdxWithLastDimSetToZero(*this, idx); }
  _dev TData *data() { return mData; }
  _dev const TData *data() const { return mData; }
  _dev TData &element(size_t pos0) {
    return data()[index(pos0)];
  }
  _dev const TData &element(size_t pos0) const {
    return data()[index(pos0)];
  }
  _dev TData &element(const size_t *pos) { return data()[index(pos)]; }
  _dev const TData &element(const size_t *pos) const { return data()[index(pos)]; }
  _dev TData &element(const Pos1D &pos) { return data()[index(pos)]; }
  _dev const TData &element(const Pos1D &pos) const { return data()[index(pos)]; }

  template <typename TElemwiseOp, typename TTarget, typename TSrc0>
  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {
    elemwise1Ary1D(op, trgt, src0);
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary1DIndexed(const TElemwiseOp &op, TTarget &trgt) {

    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0))) {
    const size_t pos[] {pos0};

  trgt.element(pos0) = op(pos, 1);

    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary1D(const TElemwiseOp &op, TTarget &trgt) {

    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0))) {

  trgt.element(pos0) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary1DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0))) {
    const size_t pos[] {pos0};

  trgt.element(pos0) = op(pos, 1, src0.element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary1D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0))) {

  trgt.element(pos0) = op(src0.element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary1DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0))) {
    const size_t pos[] {pos0};

  trgt.element(pos0) = op(pos, 1, src0.element(pos0), src1.element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary1D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0))) {

  trgt.element(pos0) = op(src0.element(pos0), src1.element(pos0));

    }
    }
}

// ======================== dimensionality: 2 ==================================

struct Pos2D {
   size_t pos[2];
    template<typename TArrayND>
   _dev static Pos2D fromLinearIdx(const TArrayND &ary, size_t idx) {
     Pos2D p;
     const size_t incr1 = 1;
     const size_t incr0 = incr1 * ary.shape(1);
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     return p;
   }
    template<typename TArrayND>
   _dev static Pos2D fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, size_t idx) {
     Pos2D p = fromLinearIdx(ary, idx);
     p[1] = 0;
     return p;
    }
    template<typename TArrayND>
   _dev size_t toLinearIdx(const TArrayND &ary) const {
     const size_t incr1 = 1;
     const size_t incr0 = incr1 * ary.shape(1);
     return incr0 * pos[0] + incr1 * pos[1];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1>
struct ShapeStatic2D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t shape(const size_t dim) const {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        default: return 0;
      }
   }
};

struct ShapeDynamic2D {
   size_t mShape[2];
  	_dev size_t shape(const size_t dim) const { return mShape[dim]; }
};

template <size_t offset_, size_t stride0, size_t stride1>
struct StrideStatic2D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t stride(const size_t dim) const {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        default: return 0;
      }
    }
   _dev size_t offset() const { return offset_; }
};

struct StrideDynamic2D {
   size_t mOffset;
   _dev size_t offset() const { return mOffset; }
   size_t mStride[2];
  	_dev size_t stride(const size_t dim) const { return mStride[dim]; }
};

template <typename TData, typename TShape, typename TStride>
struct ArrayND2D : TShape, TStride {
  typedef Pos2D Pos;
  typedef TData DataType;
  TData *mData;

  _dev size_t nDim() const { return 2; }
  _dev size_t index(const size_t pos0, const size_t pos1) const {
      return this->offset() + this->stride(0) * pos0 + this->stride(1) * pos1;
  }
  _dev size_t index(const size_t *pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1];
  }
  _dev size_t index(const Pos2D &pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1];
  }
  _dev size_t size() const {
    return this->shape(0) * this->shape(1);
  }
  _dev Pos2D linearIdxToPos(size_t idx) const { return Pos2D::fromLinearIdx(*this, idx); }
  _dev Pos2D linearIdxToPosWithLastDimSetToZero(size_t idx) const { return Pos2D::fromLinearIdxWithLastDimSetToZero(*this, idx); }
  _dev TData *data() { return mData; }
  _dev const TData *data() const { return mData; }
  _dev TData &element(size_t pos0, size_t pos1) {
    return data()[index(pos0, pos1)];
  }
  _dev const TData &element(size_t pos0, size_t pos1) const {
    return data()[index(pos0, pos1)];
  }
  _dev TData &element(const size_t *pos) { return data()[index(pos)]; }
  _dev const TData &element(const size_t *pos) const { return data()[index(pos)]; }
  _dev TData &element(const Pos2D &pos) { return data()[index(pos)]; }
  _dev const TData &element(const Pos2D &pos) const { return data()[index(pos)]; }

  template <typename TElemwiseOp, typename TTarget, typename TSrc0>
  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {
    elemwise1Ary2D(op, trgt, src0);
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary2DIndexed(const TElemwiseOp &op, TTarget &trgt) {

    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt.element(pos0, pos1) = op(pos, 2);

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary2D(const TElemwiseOp &op, TTarget &trgt) {

    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1))) {

  trgt.element(pos0, pos1) = op();

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary2DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt.element(pos0, pos1) = op(pos, 2, src0.element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary2D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1))) {

  trgt.element(pos0, pos1) = op(src0.element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary2DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt.element(pos0, pos1) = op(pos, 2, src0.element(pos0, pos1), src1.element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary2D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1))) {

  trgt.element(pos0, pos1) = op(src0.element(pos0, pos1), src1.element(pos0, pos1));

    }
    }
    }
}

// ======================== dimensionality: 3 ==================================

struct Pos3D {
   size_t pos[3];
    template<typename TArrayND>
   _dev static Pos3D fromLinearIdx(const TArrayND &ary, size_t idx) {
     Pos3D p;
     const size_t incr2 = 1;
     const size_t incr1 = incr2 * ary.shape(2);
     const size_t incr0 = incr1 * ary.shape(1);
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     p.pos[2] = idx / incr2;
     idx -= p.pos[2] * incr2;
     return p;
   }
    template<typename TArrayND>
   _dev static Pos3D fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, size_t idx) {
     Pos3D p = fromLinearIdx(ary, idx);
     p[2] = 0;
     return p;
    }
    template<typename TArrayND>
   _dev size_t toLinearIdx(const TArrayND &ary) const {
     const size_t incr2 = 1;
     const size_t incr1 = incr2 * ary.shape(2);
     const size_t incr0 = incr1 * ary.shape(1);
     return incr0 * pos[0] + incr1 * pos[1] + incr2 * pos[2];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1, size_t shape2>
struct ShapeStatic3D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t shape(const size_t dim) const {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        default: return 0;
      }
   }
};

struct ShapeDynamic3D {
   size_t mShape[3];
  	_dev size_t shape(const size_t dim) const { return mShape[dim]; }
};

template <size_t offset_, size_t stride0, size_t stride1, size_t stride2>
struct StrideStatic3D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t stride(const size_t dim) const {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        default: return 0;
      }
    }
   _dev size_t offset() const { return offset_; }
};

struct StrideDynamic3D {
   size_t mOffset;
   _dev size_t offset() const { return mOffset; }
   size_t mStride[3];
  	_dev size_t stride(const size_t dim) const { return mStride[dim]; }
};

template <typename TData, typename TShape, typename TStride>
struct ArrayND3D : TShape, TStride {
  typedef Pos3D Pos;
  typedef TData DataType;
  TData *mData;

  _dev size_t nDim() const { return 3; }
  _dev size_t index(const size_t pos0, const size_t pos1, const size_t pos2) const {
      return this->offset() + this->stride(0) * pos0 + this->stride(1) * pos1 + this->stride(2) * pos2;
  }
  _dev size_t index(const size_t *pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1] + this->stride(2) * pos[2];
  }
  _dev size_t index(const Pos3D &pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1] + this->stride(2) * pos[2];
  }
  _dev size_t size() const {
    return this->shape(0) * this->shape(1) * this->shape(2);
  }
  _dev Pos3D linearIdxToPos(size_t idx) const { return Pos3D::fromLinearIdx(*this, idx); }
  _dev Pos3D linearIdxToPosWithLastDimSetToZero(size_t idx) const { return Pos3D::fromLinearIdxWithLastDimSetToZero(*this, idx); }
  _dev TData *data() { return mData; }
  _dev const TData *data() const { return mData; }
  _dev TData &element(size_t pos0, size_t pos1, size_t pos2) {
    return data()[index(pos0, pos1, pos2)];
  }
  _dev const TData &element(size_t pos0, size_t pos1, size_t pos2) const {
    return data()[index(pos0, pos1, pos2)];
  }
  _dev TData &element(const size_t *pos) { return data()[index(pos)]; }
  _dev const TData &element(const size_t *pos) const { return data()[index(pos)]; }
  _dev TData &element(const Pos3D &pos) { return data()[index(pos)]; }
  _dev const TData &element(const Pos3D &pos) const { return data()[index(pos)]; }

  template <typename TElemwiseOp, typename TTarget, typename TSrc0>
  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {
    elemwise1Ary3D(op, trgt, src0);
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary3DIndexed(const TElemwiseOp &op, TTarget &trgt) {

    const size_t iters2 = divCeil(trgt.shape(2), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt.element(pos0, pos1, pos2) = op(pos, 3);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary3D(const TElemwiseOp &op, TTarget &trgt) {

    const size_t iters2 = divCeil(trgt.shape(2), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2))) {

  trgt.element(pos0, pos1, pos2) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary3DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t iters2 = divCeil(trgt.shape(2), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt.element(pos0, pos1, pos2) = op(pos, 3, src0.element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary3D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t iters2 = divCeil(trgt.shape(2), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2))) {

  trgt.element(pos0, pos1, pos2) = op(src0.element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary3DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t iters2 = divCeil(trgt.shape(2), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt.element(pos0, pos1, pos2) = op(pos, 3, src0.element(pos0, pos1, pos2), src1.element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary3D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t iters2 = divCeil(trgt.shape(2), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2))) {

  trgt.element(pos0, pos1, pos2) = op(src0.element(pos0, pos1, pos2), src1.element(pos0, pos1, pos2));

    }
    }
    }
    }
}

// ======================== dimensionality: 4 ==================================

struct Pos4D {
   size_t pos[4];
    template<typename TArrayND>
   _dev static Pos4D fromLinearIdx(const TArrayND &ary, size_t idx) {
     Pos4D p;
     const size_t incr3 = 1;
     const size_t incr2 = incr3 * ary.shape(3);
     const size_t incr1 = incr2 * ary.shape(2);
     const size_t incr0 = incr1 * ary.shape(1);
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     p.pos[2] = idx / incr2;
     idx -= p.pos[2] * incr2;
     p.pos[3] = idx / incr3;
     idx -= p.pos[3] * incr3;
     return p;
   }
    template<typename TArrayND>
   _dev static Pos4D fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, size_t idx) {
     Pos4D p = fromLinearIdx(ary, idx);
     p[3] = 0;
     return p;
    }
    template<typename TArrayND>
   _dev size_t toLinearIdx(const TArrayND &ary) const {
     const size_t incr3 = 1;
     const size_t incr2 = incr3 * ary.shape(3);
     const size_t incr1 = incr2 * ary.shape(2);
     const size_t incr0 = incr1 * ary.shape(1);
     return incr0 * pos[0] + incr1 * pos[1] + incr2 * pos[2] + incr3 * pos[3];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3>
struct ShapeStatic4D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t shape(const size_t dim) const {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        default: return 0;
      }
   }
};

struct ShapeDynamic4D {
   size_t mShape[4];
  	_dev size_t shape(const size_t dim) const { return mShape[dim]; }
};

template <size_t offset_, size_t stride0, size_t stride1, size_t stride2, size_t stride3>
struct StrideStatic4D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t stride(const size_t dim) const {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        default: return 0;
      }
    }
   _dev size_t offset() const { return offset_; }
};

struct StrideDynamic4D {
   size_t mOffset;
   _dev size_t offset() const { return mOffset; }
   size_t mStride[4];
  	_dev size_t stride(const size_t dim) const { return mStride[dim]; }
};

template <typename TData, typename TShape, typename TStride>
struct ArrayND4D : TShape, TStride {
  typedef Pos4D Pos;
  typedef TData DataType;
  TData *mData;

  _dev size_t nDim() const { return 4; }
  _dev size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3) const {
      return this->offset() + this->stride(0) * pos0 + this->stride(1) * pos1 + this->stride(2) * pos2 + this->stride(3) * pos3;
  }
  _dev size_t index(const size_t *pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1] + this->stride(2) * pos[2] + this->stride(3) * pos[3];
  }
  _dev size_t index(const Pos4D &pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1] + this->stride(2) * pos[2] + this->stride(3) * pos[3];
  }
  _dev size_t size() const {
    return this->shape(0) * this->shape(1) * this->shape(2) * this->shape(3);
  }
  _dev Pos4D linearIdxToPos(size_t idx) const { return Pos4D::fromLinearIdx(*this, idx); }
  _dev Pos4D linearIdxToPosWithLastDimSetToZero(size_t idx) const { return Pos4D::fromLinearIdxWithLastDimSetToZero(*this, idx); }
  _dev TData *data() { return mData; }
  _dev const TData *data() const { return mData; }
  _dev TData &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) {
    return data()[index(pos0, pos1, pos2, pos3)];
  }
  _dev const TData &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) const {
    return data()[index(pos0, pos1, pos2, pos3)];
  }
  _dev TData &element(const size_t *pos) { return data()[index(pos)]; }
  _dev const TData &element(const size_t *pos) const { return data()[index(pos)]; }
  _dev TData &element(const Pos4D &pos) { return data()[index(pos)]; }
  _dev const TData &element(const Pos4D &pos) const { return data()[index(pos)]; }

  template <typename TElemwiseOp, typename TTarget, typename TSrc0>
  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {
    elemwise1Ary4D(op, trgt, src0);
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary4DIndexed(const TElemwiseOp &op, TTarget &trgt) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt.element(pos0, pos1, pos2, pos3) = op(pos, 4);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary4D(const TElemwiseOp &op, TTarget &trgt) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3))) {

  trgt.element(pos0, pos1, pos2, pos3) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary4DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt.element(pos0, pos1, pos2, pos3) = op(pos, 4, src0.element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary4D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3))) {

  trgt.element(pos0, pos1, pos2, pos3) = op(src0.element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary4DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt.element(pos0, pos1, pos2, pos3) = op(pos, 4, src0.element(pos0, pos1, pos2, pos3), src1.element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary4D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3))) {

  trgt.element(pos0, pos1, pos2, pos3) = op(src0.element(pos0, pos1, pos2, pos3), src1.element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

// ======================== dimensionality: 5 ==================================

struct Pos5D {
   size_t pos[5];
    template<typename TArrayND>
   _dev static Pos5D fromLinearIdx(const TArrayND &ary, size_t idx) {
     Pos5D p;
     const size_t incr4 = 1;
     const size_t incr3 = incr4 * ary.shape(4);
     const size_t incr2 = incr3 * ary.shape(3);
     const size_t incr1 = incr2 * ary.shape(2);
     const size_t incr0 = incr1 * ary.shape(1);
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     p.pos[2] = idx / incr2;
     idx -= p.pos[2] * incr2;
     p.pos[3] = idx / incr3;
     idx -= p.pos[3] * incr3;
     p.pos[4] = idx / incr4;
     idx -= p.pos[4] * incr4;
     return p;
   }
    template<typename TArrayND>
   _dev static Pos5D fromLinearIdxWithLastDimSetToZero(const TArrayND &ary, size_t idx) {
     Pos5D p = fromLinearIdx(ary, idx);
     p[4] = 0;
     return p;
    }
    template<typename TArrayND>
   _dev size_t toLinearIdx(const TArrayND &ary) const {
     const size_t incr4 = 1;
     const size_t incr3 = incr4 * ary.shape(4);
     const size_t incr2 = incr3 * ary.shape(3);
     const size_t incr1 = incr2 * ary.shape(2);
     const size_t incr0 = incr1 * ary.shape(1);
     return incr0 * pos[0] + incr1 * pos[1] + incr2 * pos[2] + incr3 * pos[3] + incr4 * pos[4];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3, size_t shape4>
struct ShapeStatic5D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t shape(const size_t dim) const {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        case 4: return shape4;
        default: return 0;
      }
   }
};

struct ShapeDynamic5D {
   size_t mShape[5];
  	_dev size_t shape(const size_t dim) const { return mShape[dim]; }
};

template <size_t offset_, size_t stride0, size_t stride1, size_t stride2, size_t stride3, size_t stride4>
struct StrideStatic5D {
   char mDummy; // FIX: if struct is empty, MSVC and NVCC see different struct sizes
  	_dev size_t stride(const size_t dim) const {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        case 4: return stride4;
        default: return 0;
      }
    }
   _dev size_t offset() const { return offset_; }
};

struct StrideDynamic5D {
   size_t mOffset;
   _dev size_t offset() const { return mOffset; }
   size_t mStride[5];
  	_dev size_t stride(const size_t dim) const { return mStride[dim]; }
};

template <typename TData, typename TShape, typename TStride>
struct ArrayND5D : TShape, TStride {
  typedef Pos5D Pos;
  typedef TData DataType;
  TData *mData;

  _dev size_t nDim() const { return 5; }
  _dev size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3, const size_t pos4) const {
      return this->offset() + this->stride(0) * pos0 + this->stride(1) * pos1 + this->stride(2) * pos2 + this->stride(3) * pos3 + this->stride(4) * pos4;
  }
  _dev size_t index(const size_t *pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1] + this->stride(2) * pos[2] + this->stride(3) * pos[3] + this->stride(4) * pos[4];
  }
  _dev size_t index(const Pos5D &pos) const {
      return this->offset() + this->stride(0) * pos[0] + this->stride(1) * pos[1] + this->stride(2) * pos[2] + this->stride(3) * pos[3] + this->stride(4) * pos[4];
  }
  _dev size_t size() const {
    return this->shape(0) * this->shape(1) * this->shape(2) * this->shape(3) * this->shape(4);
  }
  _dev Pos5D linearIdxToPos(size_t idx) const { return Pos5D::fromLinearIdx(*this, idx); }
  _dev Pos5D linearIdxToPosWithLastDimSetToZero(size_t idx) const { return Pos5D::fromLinearIdxWithLastDimSetToZero(*this, idx); }
  _dev TData *data() { return mData; }
  _dev const TData *data() const { return mData; }
  _dev TData &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) {
    return data()[index(pos0, pos1, pos2, pos3, pos4)];
  }
  _dev const TData &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) const {
    return data()[index(pos0, pos1, pos2, pos3, pos4)];
  }
  _dev TData &element(const size_t *pos) { return data()[index(pos)]; }
  _dev const TData &element(const size_t *pos) const { return data()[index(pos)]; }
  _dev TData &element(const Pos5D &pos) { return data()[index(pos)]; }
  _dev const TData &element(const Pos5D &pos) const { return data()[index(pos)]; }

  template <typename TElemwiseOp, typename TTarget, typename TSrc0>
  _dev static void elemwise1Ary(const TElemwiseOp &op, TTarget &trgt, TSrc0 &src0) {
    elemwise1Ary5D(op, trgt, src0);
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary5DIndexed(const TElemwiseOp &op, TTarget &trgt) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3) * trgt.shape(4), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t incr4 = incr3 * trgt.shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3)) && (pos4 < trgt.shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt.element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary5D(const TElemwiseOp &op, TTarget &trgt) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3) * trgt.shape(4), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t incr4 = incr3 * trgt.shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3)) && (pos4 < trgt.shape(4))) {

  trgt.element(pos0, pos1, pos2, pos3, pos4) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary5DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3) * trgt.shape(4), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t incr4 = incr3 * trgt.shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3)) && (pos4 < trgt.shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt.element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5, src0.element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary5D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3) * trgt.shape(4), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t incr4 = incr3 * trgt.shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3)) && (pos4 < trgt.shape(4))) {

  trgt.element(pos0, pos1, pos2, pos3, pos4) = op(src0.element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary5DIndexed(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3) * trgt.shape(4), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t incr4 = incr3 * trgt.shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3)) && (pos4 < trgt.shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt.element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5, src0.element(pos0, pos1, pos2, pos3, pos4), src1.element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary5D(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t itersRest = divCeil(trgt.shape(2) * trgt.shape(3) * trgt.shape(4), gridDim.z * blockDim.z);
    const size_t iters1 = divCeil(trgt.shape(1), gridDim.y * blockDim.y);
    const size_t iters0 = divCeil(trgt.shape(0), gridDim.x * blockDim.x);
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * trgt.shape(2);
    const size_t incr4 = incr3 * trgt.shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt.shape(0)) && (pos1 < trgt.shape(1)) && (pos2 < trgt.shape(2)) && (pos3 < trgt.shape(3)) && (pos4 < trgt.shape(4))) {

  trgt.element(pos0, pos1, pos2, pos3, pos4) = op(src0.element(pos0, pos1, pos2, pos3, pos4), src1.element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0AryHeterogenous(const TElemwiseOp &op, TTarget &trgt) {

    const size_t iters = divCeil(trgt.size(), gridDim.x * blockDim.x);
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < trgt.size()) {

  trgt.element(trgt.linearIdxToPos(idx)) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1AryHeterogenous(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0) {

    const size_t iters = divCeil(trgt.size(), gridDim.x * blockDim.x);
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < trgt.size()) {

  trgt.element(trgt.linearIdxToPos(idx)) = op(src0.element(src0.linearIdxToPos(idx)));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2AryHeterogenous(const TElemwiseOp &op, TTarget &trgt, const TSrc0 &src0, const TSrc1 &src1) {

    const size_t iters = divCeil(trgt.size(), gridDim.x * blockDim.x);
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < trgt.size()) {

  trgt.element(trgt.linearIdxToPos(idx)) = op(src0.element(src0.linearIdxToPos(idx)), src1.element(src1.linearIdxToPos(idx)));

    }
    }
}

