// this file is automatically generated by GenerateNDSupport.fsx
#pragma once
#include "Utils.cuh" 

// ======================== dimensionality: 0 ==================================

class Shape0D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        default: return 0;
      }
};

template <size_t offset_>
class Stride0D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index() {
      return offset_ + 0;
    }
};

template <typename TShape, typename TStride>
class NDArray0D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return 1;
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element() {
    return data()[Stride::index()];
  }
  _dev const float &element() const {
    return data()[Stride::index()];
  }
};

template <typename TUnaryElementwiseOp, typename TTarget, typename TA>
__global__ void elementwiseUnary0D(TTarget *trgt, const TA *a) {
  TUnaryElementwiseOp op;

  trgt->element() = op(a->element());
}

template <typename TBinaryElementwiseOp, typename TTarget, typename TA, typename TB>
__global__ void elementwiseUnary0D(TTarget *trgt, const TA *a, const TB *b) {
  TBinaryElementwiseOp op;

  trgt->element() = op(a->element(), b->element());
}

// ======================== dimensionality: 1 ==================================

template <size_t shape0>
class Shape1D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        default: return 0;
      }
};

template <size_t offset, size_t stride0>
class Stride1D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0) {
      return offset_ + stride0 * pos0;
    }
};

template <typename TShape, typename TStride>
class NDArray1D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0) {
    return data()[Stride::index(pos0)];
  }
  _dev const float &element(size_t pos0) const {
    return data()[Stride::index(pos0)];
  }
};

template <typename TUnaryElementwiseOp, typename TTarget, typename TA>
__global__ void elementwiseUnary1D(TTarget *trgt, const TA *a) {
  TUnaryElementwiseOp op;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)))) return;

  trgt->element(pos0) = op(a->element(pos0));
}

template <typename TBinaryElementwiseOp, typename TTarget, typename TA, typename TB>
__global__ void elementwiseUnary1D(TTarget *trgt, const TA *a, const TB *b) {
  TBinaryElementwiseOp op;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)))) return;

  trgt->element(pos0) = op(a->element(pos0), b->element(pos0));
}

// ======================== dimensionality: 2 ==================================

template <size_t shape0, size_t shape1>
class Shape2D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1>
class Stride2D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1) {
      return offset_ + stride0 * pos0 + stride1 * pos1;
    }
};

template <typename TShape, typename TStride>
class NDArray2D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1) {
    return data()[Stride::index(pos0, pos1)];
  }
  _dev const float &element(size_t pos0, size_t pos1) const {
    return data()[Stride::index(pos0, pos1)];
  }
};

template <typename TUnaryElementwiseOp, typename TTarget, typename TA>
__global__ void elementwiseUnary2D(TTarget *trgt, const TA *a) {
  TUnaryElementwiseOp op;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)))) return;

  trgt->element(pos0, pos1) = op(a->element(pos0, pos1));
}

template <typename TBinaryElementwiseOp, typename TTarget, typename TA, typename TB>
__global__ void elementwiseUnary2D(TTarget *trgt, const TA *a, const TB *b) {
  TBinaryElementwiseOp op;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)))) return;

  trgt->element(pos0, pos1) = op(a->element(pos0, pos1), b->element(pos0, pos1));
}

// ======================== dimensionality: 3 ==================================

template <size_t shape0, size_t shape1, size_t shape2>
class Shape3D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1, size_t stride2>
class Stride3D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2;
    }
};

template <typename TShape, typename TStride>
class NDArray3D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2) {
    return data()[Stride::index(pos0, pos1, pos2)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2) const {
    return data()[Stride::index(pos0, pos1, pos2)];
  }
};

template <typename TUnaryElementwiseOp, typename TTarget, typename TA>
__global__ void elementwiseUnary3D(TTarget *trgt, const TA *a) {
  TUnaryElementwiseOp op;
  const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)))) return;

  trgt->element(pos0, pos1, pos2) = op(a->element(pos0, pos1, pos2));
}

template <typename TBinaryElementwiseOp, typename TTarget, typename TA, typename TB>
__global__ void elementwiseUnary3D(TTarget *trgt, const TA *a, const TB *b) {
  TBinaryElementwiseOp op;
  const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)))) return;

  trgt->element(pos0, pos1, pos2) = op(a->element(pos0, pos1, pos2), b->element(pos0, pos1, pos2));
}

// ======================== dimensionality: 4 ==================================

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3>
class Shape4D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1, size_t stride2, size_t stride3>
class Stride4D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2 + stride3 * pos3;
    }
};

template <typename TShape, typename TStride>
class NDArray4D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2) * shape(3);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) {
    return data()[Stride::index(pos0, pos1, pos2, pos3)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) const {
    return data()[Stride::index(pos0, pos1, pos2, pos3)];
  }
};

template <typename TUnaryElementwiseOp, typename TTarget, typename TA>
__global__ void elementwiseUnary4D(TTarget *trgt, const TA *a) {
  TUnaryElementwiseOp op;

  size_t posRest = threadIdx.z + blockIdx.z * blockDim.z;
  const size_t incr2 = 1;
  const size_t incr3 = incr2 * TTarget::shape(2);
  const size_t pos3 = posRest / incr3;
  posRest -= pos3 * incr3;
  const size_t pos2 = posRest / incr2;
  posRest -= pos2 * incr2;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)))) return;

  trgt->element(pos0, pos1, pos2, pos3) = op(a->element(pos0, pos1, pos2, pos3));
}

template <typename TBinaryElementwiseOp, typename TTarget, typename TA, typename TB>
__global__ void elementwiseUnary4D(TTarget *trgt, const TA *a, const TB *b) {
  TBinaryElementwiseOp op;

  size_t posRest = threadIdx.z + blockIdx.z * blockDim.z;
  const size_t incr2 = 1;
  const size_t incr3 = incr2 * TTarget::shape(2);
  const size_t pos3 = posRest / incr3;
  posRest -= pos3 * incr3;
  const size_t pos2 = posRest / incr2;
  posRest -= pos2 * incr2;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)))) return;

  trgt->element(pos0, pos1, pos2, pos3) = op(a->element(pos0, pos1, pos2, pos3), b->element(pos0, pos1, pos2, pos3));
}

// ======================== dimensionality: 5 ==================================

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3, size_t shape4>
class Shape5D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        case 4: return shape4;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1, size_t stride2, size_t stride3, size_t stride4>
class Stride5D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        case 4: return stride4;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3, const size_t pos4) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2 + stride3 * pos3 + stride4 * pos4;
    }
};

template <typename TShape, typename TStride>
class NDArray5D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2) * shape(3) * shape(4);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) {
    return data()[Stride::index(pos0, pos1, pos2, pos3, pos4)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) const {
    return data()[Stride::index(pos0, pos1, pos2, pos3, pos4)];
  }
};

template <typename TUnaryElementwiseOp, typename TTarget, typename TA>
__global__ void elementwiseUnary5D(TTarget *trgt, const TA *a) {
  TUnaryElementwiseOp op;

  size_t posRest = threadIdx.z + blockIdx.z * blockDim.z;
  const size_t incr2 = 1;
  const size_t incr3 = incr2 * TTarget::shape(2);
  const size_t incr4 = incr3 * TTarget::shape(3);
  const size_t pos4 = posRest / incr4;
  posRest -= pos4 * incr4;
  const size_t pos3 = posRest / incr3;
  posRest -= pos3 * incr3;
  const size_t pos2 = posRest / incr2;
  posRest -= pos2 * incr2;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4)))) return;

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(a->element(pos0, pos1, pos2, pos3, pos4));
}

template <typename TBinaryElementwiseOp, typename TTarget, typename TA, typename TB>
__global__ void elementwiseUnary5D(TTarget *trgt, const TA *a, const TB *b) {
  TBinaryElementwiseOp op;

  size_t posRest = threadIdx.z + blockIdx.z * blockDim.z;
  const size_t incr2 = 1;
  const size_t incr3 = incr2 * TTarget::shape(2);
  const size_t incr4 = incr3 * TTarget::shape(3);
  const size_t pos4 = posRest / incr4;
  posRest -= pos4 * incr4;
  const size_t pos3 = posRest / incr3;
  posRest -= pos3 * incr3;
  const size_t pos2 = posRest / incr2;
  posRest -= pos2 * incr2;
  const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y;
  const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x;
  if (!((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4)))) return;

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(a->element(pos0, pos1, pos2, pos3, pos4), b->element(pos0, pos1, pos2, pos3, pos4));
}

