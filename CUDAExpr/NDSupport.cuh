// this file is automatically generated by GenerateNDSupport.fsx
#pragma once
#include "Utils.cuh" 

// ======================== dimensionality: 0 ==================================

class Shape0D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        default: return 0;
      }
};

template <size_t offset_>
class Stride0D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index() {
      return offset_ + 0;
    }
};

template <typename TShape, typename TStride>
class NDArray0D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return 1;
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element() {
    return data()[Stride::index()];
  }
  _dev const float &element() const {
    return data()[Stride::index()];
  }
};

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary0DIndexed(TTarget *trgt) {
  TElemwiseOp op;

    const size_t pos[] {};

  trgt->element() = op(pos, 0);

}

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary0D(TTarget *trgt) {
  TElemwiseOp op;


  trgt->element() = op();

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary0DIndexed(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t pos[] {};

  trgt->element() = op(pos, 0, src0->element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary0D(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;


  trgt->element() = op(src0->element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary0DIndexed(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t pos[] {};

  trgt->element() = op(pos, 0, src0->element(), src1->element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary0D(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;


  trgt->element() = op(src0->element(), src1->element());

}

// ======================== dimensionality: 1 ==================================

template <size_t shape0>
class Shape1D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        default: return 0;
      }
};

template <size_t offset, size_t stride0>
class Stride1D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0) {
      return offset_ + stride0 * pos0;
    }
};

template <typename TShape, typename TStride>
class NDArray1D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0) {
    return data()[Stride::index(pos0)];
  }
  _dev const float &element(size_t pos0) const {
    return data()[Stride::index(pos0)];
  }
};

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary1DIndexed(TTarget *trgt) {
  TElemwiseOp op;

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {
    const size_t pos[] {pos0};

  trgt->element(pos0) = op(pos, 1);

    }
    }
}

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary1D(TTarget *trgt) {
  TElemwiseOp op;

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {

  trgt->element(pos0) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary1DIndexed(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {
    const size_t pos[] {pos0};

  trgt->element(pos0) = op(pos, 1, src0->element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary1D(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {

  trgt->element(pos0) = op(src0->element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary1DIndexed(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {
    const size_t pos[] {pos0};

  trgt->element(pos0) = op(pos, 1, src0->element(pos0), src1->element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary1D(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {

  trgt->element(pos0) = op(src0->element(pos0), src1->element(pos0));

    }
    }
}

// ======================== dimensionality: 2 ==================================

template <size_t shape0, size_t shape1>
class Shape2D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1>
class Stride2D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1) {
      return offset_ + stride0 * pos0 + stride1 * pos1;
    }
};

template <typename TShape, typename TStride>
class NDArray2D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1) {
    return data()[Stride::index(pos0, pos1)];
  }
  _dev const float &element(size_t pos0, size_t pos1) const {
    return data()[Stride::index(pos0, pos1)];
  }
};

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary2DIndexed(TTarget *trgt) {
  TElemwiseOp op;

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt->element(pos0, pos1) = op(pos, 2);

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary2D(TTarget *trgt) {
  TElemwiseOp op;

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {

  trgt->element(pos0, pos1) = op();

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary2DIndexed(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt->element(pos0, pos1) = op(pos, 2, src0->element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary2D(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {

  trgt->element(pos0, pos1) = op(src0->element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary2DIndexed(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt->element(pos0, pos1) = op(pos, 2, src0->element(pos0, pos1), src1->element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary2D(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {

  trgt->element(pos0, pos1) = op(src0->element(pos0, pos1), src1->element(pos0, pos1));

    }
    }
    }
}

// ======================== dimensionality: 3 ==================================

template <size_t shape0, size_t shape1, size_t shape2>
class Shape3D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1, size_t stride2>
class Stride3D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2;
    }
};

template <typename TShape, typename TStride>
class NDArray3D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2) {
    return data()[Stride::index(pos0, pos1, pos2)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2) const {
    return data()[Stride::index(pos0, pos1, pos2)];
  }
};

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary3DIndexed(TTarget *trgt) {
  TElemwiseOp op;

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt->element(pos0, pos1, pos2) = op(pos, 3);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary3D(TTarget *trgt) {
  TElemwiseOp op;

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {

  trgt->element(pos0, pos1, pos2) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary3DIndexed(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt->element(pos0, pos1, pos2) = op(pos, 3, src0->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary3D(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {

  trgt->element(pos0, pos1, pos2) = op(src0->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary3DIndexed(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt->element(pos0, pos1, pos2) = op(pos, 3, src0->element(pos0, pos1, pos2), src1->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary3D(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {

  trgt->element(pos0, pos1, pos2) = op(src0->element(pos0, pos1, pos2), src1->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

// ======================== dimensionality: 4 ==================================

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3>
class Shape4D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1, size_t stride2, size_t stride3>
class Stride4D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2 + stride3 * pos3;
    }
};

template <typename TShape, typename TStride>
class NDArray4D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2) * shape(3);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) {
    return data()[Stride::index(pos0, pos1, pos2, pos3)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) const {
    return data()[Stride::index(pos0, pos1, pos2, pos3)];
  }
};

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary4DIndexed(TTarget *trgt) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt->element(pos0, pos1, pos2, pos3) = op(pos, 4);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary4D(TTarget *trgt) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {

  trgt->element(pos0, pos1, pos2, pos3) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary4DIndexed(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt->element(pos0, pos1, pos2, pos3) = op(pos, 4, src0->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary4D(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {

  trgt->element(pos0, pos1, pos2, pos3) = op(src0->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary4DIndexed(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt->element(pos0, pos1, pos2, pos3) = op(pos, 4, src0->element(pos0, pos1, pos2, pos3), src1->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary4D(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {

  trgt->element(pos0, pos1, pos2, pos3) = op(src0->element(pos0, pos1, pos2, pos3), src1->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

// ======================== dimensionality: 5 ==================================

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3, size_t shape4>
class Shape5D {
public:
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        case 4: return shape4;
        default: return 0;
      }
};

template <size_t offset, size_t stride0, size_t stride1, size_t stride2, size_t stride3, size_t stride4>
class Stride5D {
public:
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        case 4: return stride4;
        default: return 0;
      }
    }

   _dev static size_t offset() {
      return offset_;
    }

  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3, const size_t pos4) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2 + stride3 * pos3 + stride4 * pos4;
    }
};

template <typename TShape, typename TStride>
class NDArray5D {
public:
  typedef TShape Shape;
  typedef TStride Stride;
  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2) * shape(3) * shape(4);
  }
  _dev float *data() { return reinterpret_cast<float *>(this); }
  _dev const float *data() const { return reinterpret_cast<const float *>(this); }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) {
    return data()[Stride::index(pos0, pos1, pos2, pos3, pos4)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) const {
    return data()[Stride::index(pos0, pos1, pos2, pos3, pos4)];
  }
};

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary5DIndexed(TTarget *trgt) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
__global__ void elemwise0Ary5D(TTarget *trgt) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary5DIndexed(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5, src0->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
__global__ void elemwise1Ary5D(TTarget *trgt, const TSrc0 *src0) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(src0->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary5DIndexed(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5, src0->element(pos0, pos1, pos2, pos3, pos4), src1->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
__global__ void elemwise2Ary5D(TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {
  TElemwiseOp op;

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(src0->element(pos0, pos1, pos2, pos3, pos4), src1->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

