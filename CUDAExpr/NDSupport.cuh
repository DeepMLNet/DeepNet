// this file is automatically generated by GenerateNDSupport.fsx
#pragma once
#include "Utils.cuh" 

// ======================== dimensionality: 0 ==================================

struct Pos0D {
   size_t pos[1];
    template<typename TNDArray>
   _dev static Pos0D fromIdx(size_t idx) {
     Pos0D p;
     p.pos[0] = 0;
     return p;
   }
    template<typename TNDArray>
   _dev static Pos0D fromIdxWithLastDimSetToZero(size_t idx) {
     Pos0D p = fromIdx<TNDArray>(idx);
     return p;
    }
    template<typename TNDArray>
   _dev size_t toIdx() const {
     return 0;
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

struct ShapeStatic0D {
  	_dev static size_t shape(const size_t dim) {
      return 0;
   }
};

template <size_t offset_>
struct StrideStatic0D {
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        default: return 0;
      }
    }
   _dev static size_t offset() {
      return offset_;
    }
  	_dev static size_t index() {
      return offset_ + 0;
    }
  	_dev static size_t index(const size_t *pos) {
      return offset_ + 0;
    }
  	_dev static size_t index(const Pos0D &pos) {
      return offset_ + 0;
    }
};

template <typename TShape, typename TStride>
struct NDArrayStatic0D {
  typedef TShape Shape;
  typedef TStride Stride;
  typedef Pos0D Pos;
  float *mData;

  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t nDim() { return 0; }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return 1;
  }
  _dev static Pos0D idxToPos(size_t idx) { return Pos0D::fromIdx<Shape>(idx); }
  _dev static Pos0D idxToPosWithLastDimSetToZero(size_t idx) { return Pos0D::fromIdxWithLastDimSetToZero<Shape>(idx); }
  _dev float *data() { return mData; }
  _dev const float *data() const { return mData; }
  _dev float &element() {
    return data()[Stride::index()];
  }
  _dev const float &element() const {
    return data()[Stride::index()];
  }
  _dev float &element(const size_t *pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const size_t *pos) const {
    return data()[Stride::index(pos)];
  }
  _dev float &element(const Pos0D &pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const Pos0D &pos) const {
    return data()[Stride::index(pos)];
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary0DIndexed(const TElemwiseOp &op, TTarget *trgt) {

    const size_t *pos = nullptr;

  trgt->element() = op(pos, 0);

}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary0D(const TElemwiseOp &op, TTarget *trgt) {


  trgt->element() = op();

}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary0DHeterogenous(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary0DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t *pos = nullptr;

  trgt->element() = op(pos, 0, src0->element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary0D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {


  trgt->element() = op(src0->element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary0DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary0DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t *pos = nullptr;

  trgt->element() = op(pos, 0, src0->element(), src1->element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary0D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {


  trgt->element() = op(src0->element(), src1->element());

}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary0DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)), src1->element(src1->idxToPos(idx)));

    }
    }
}

// ======================== dimensionality: 1 ==================================

struct Pos1D {
   size_t pos[1];
    template<typename TNDArray>
   _dev static Pos1D fromIdx(size_t idx) {
     Pos1D p;
     const size_t incr0 = 1;
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     return p;
   }
    template<typename TNDArray>
   _dev static Pos1D fromIdxWithLastDimSetToZero(size_t idx) {
     Pos1D p = fromIdx<TNDArray>(idx);
     p[0] = 0;
     return p;
    }
    template<typename TNDArray>
   _dev size_t toIdx() const {
     const size_t incr0 = 1;
     return incr0 * pos[0];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0>
struct ShapeStatic1D {
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        default: return 0;
      }
   }
};

template <size_t offset_, size_t stride0>
struct StrideStatic1D {
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        default: return 0;
      }
    }
   _dev static size_t offset() {
      return offset_;
    }
  	_dev static size_t index(const size_t pos0) {
      return offset_ + stride0 * pos0;
    }
  	_dev static size_t index(const size_t *pos) {
      return offset_ + stride0 * pos[0];
    }
  	_dev static size_t index(const Pos1D &pos) {
      return offset_ + stride0 * pos[0];
    }
};

template <typename TShape, typename TStride>
struct NDArrayStatic1D {
  typedef TShape Shape;
  typedef TStride Stride;
  typedef Pos1D Pos;
  float *mData;

  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t nDim() { return 1; }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0);
  }
  _dev static Pos1D idxToPos(size_t idx) { return Pos1D::fromIdx<Shape>(idx); }
  _dev static Pos1D idxToPosWithLastDimSetToZero(size_t idx) { return Pos1D::fromIdxWithLastDimSetToZero<Shape>(idx); }
  _dev float *data() { return mData; }
  _dev const float *data() const { return mData; }
  _dev float &element(size_t pos0) {
    return data()[Stride::index(pos0)];
  }
  _dev const float &element(size_t pos0) const {
    return data()[Stride::index(pos0)];
  }
  _dev float &element(const size_t *pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const size_t *pos) const {
    return data()[Stride::index(pos)];
  }
  _dev float &element(const Pos1D &pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const Pos1D &pos) const {
    return data()[Stride::index(pos)];
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary1DIndexed(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {
    const size_t pos[] {pos0};

  trgt->element(pos0) = op(pos, 1);

    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary1D(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {

  trgt->element(pos0) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary1DHeterogenous(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary1DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {
    const size_t pos[] {pos0};

  trgt->element(pos0) = op(pos, 1, src0->element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary1D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {

  trgt->element(pos0) = op(src0->element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary1DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary1DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {
    const size_t pos[] {pos0};

  trgt->element(pos0) = op(pos, 1, src0->element(pos0), src1->element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary1D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0))) {

  trgt->element(pos0) = op(src0->element(pos0), src1->element(pos0));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary1DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)), src1->element(src1->idxToPos(idx)));

    }
    }
}

// ======================== dimensionality: 2 ==================================

struct Pos2D {
   size_t pos[2];
    template<typename TNDArray>
   _dev static Pos2D fromIdx(size_t idx) {
     Pos2D p;
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     return p;
   }
    template<typename TNDArray>
   _dev static Pos2D fromIdxWithLastDimSetToZero(size_t idx) {
     Pos2D p = fromIdx<TNDArray>(idx);
     p[1] = 0;
     return p;
    }
    template<typename TNDArray>
   _dev size_t toIdx() const {
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     return incr0 * pos[0] + incr1 * pos[1];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1>
struct ShapeStatic2D {
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        default: return 0;
      }
   }
};

template <size_t offset_, size_t stride0, size_t stride1>
struct StrideStatic2D {
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        default: return 0;
      }
    }
   _dev static size_t offset() {
      return offset_;
    }
  	_dev static size_t index(const size_t pos0, const size_t pos1) {
      return offset_ + stride0 * pos0 + stride1 * pos1;
    }
  	_dev static size_t index(const size_t *pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1];
    }
  	_dev static size_t index(const Pos2D &pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1];
    }
};

template <typename TShape, typename TStride>
struct NDArrayStatic2D {
  typedef TShape Shape;
  typedef TStride Stride;
  typedef Pos2D Pos;
  float *mData;

  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t nDim() { return 2; }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1);
  }
  _dev static Pos2D idxToPos(size_t idx) { return Pos2D::fromIdx<Shape>(idx); }
  _dev static Pos2D idxToPosWithLastDimSetToZero(size_t idx) { return Pos2D::fromIdxWithLastDimSetToZero<Shape>(idx); }
  _dev float *data() { return mData; }
  _dev const float *data() const { return mData; }
  _dev float &element(size_t pos0, size_t pos1) {
    return data()[Stride::index(pos0, pos1)];
  }
  _dev const float &element(size_t pos0, size_t pos1) const {
    return data()[Stride::index(pos0, pos1)];
  }
  _dev float &element(const size_t *pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const size_t *pos) const {
    return data()[Stride::index(pos)];
  }
  _dev float &element(const Pos2D &pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const Pos2D &pos) const {
    return data()[Stride::index(pos)];
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary2DIndexed(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt->element(pos0, pos1) = op(pos, 2);

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary2D(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {

  trgt->element(pos0, pos1) = op();

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary2DHeterogenous(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary2DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt->element(pos0, pos1) = op(pos, 2, src0->element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary2D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {

  trgt->element(pos0, pos1) = op(src0->element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary2DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary2DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {
    const size_t pos[] {pos0, pos1};

  trgt->element(pos0, pos1) = op(pos, 2, src0->element(pos0, pos1), src1->element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary2D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1))) {

  trgt->element(pos0, pos1) = op(src0->element(pos0, pos1), src1->element(pos0, pos1));

    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary2DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)), src1->element(src1->idxToPos(idx)));

    }
    }
}

// ======================== dimensionality: 3 ==================================

struct Pos3D {
   size_t pos[3];
    template<typename TNDArray>
   _dev static Pos3D fromIdx(size_t idx) {
     Pos3D p;
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     const size_t incr2 = incr1 * TNDArray::shape(1);
     p.pos[2] = idx / incr2;
     idx -= p.pos[2] * incr2;
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     return p;
   }
    template<typename TNDArray>
   _dev static Pos3D fromIdxWithLastDimSetToZero(size_t idx) {
     Pos3D p = fromIdx<TNDArray>(idx);
     p[2] = 0;
     return p;
    }
    template<typename TNDArray>
   _dev size_t toIdx() const {
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     const size_t incr2 = incr1 * TNDArray::shape(1);
     return incr0 * pos[0] + incr1 * pos[1] + incr2 * pos[2];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1, size_t shape2>
struct ShapeStatic3D {
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        default: return 0;
      }
   }
};

template <size_t offset_, size_t stride0, size_t stride1, size_t stride2>
struct StrideStatic3D {
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        default: return 0;
      }
    }
   _dev static size_t offset() {
      return offset_;
    }
  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2;
    }
  	_dev static size_t index(const size_t *pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1] + stride2 * pos[2];
    }
  	_dev static size_t index(const Pos3D &pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1] + stride2 * pos[2];
    }
};

template <typename TShape, typename TStride>
struct NDArrayStatic3D {
  typedef TShape Shape;
  typedef TStride Stride;
  typedef Pos3D Pos;
  float *mData;

  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t nDim() { return 3; }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2);
  }
  _dev static Pos3D idxToPos(size_t idx) { return Pos3D::fromIdx<Shape>(idx); }
  _dev static Pos3D idxToPosWithLastDimSetToZero(size_t idx) { return Pos3D::fromIdxWithLastDimSetToZero<Shape>(idx); }
  _dev float *data() { return mData; }
  _dev const float *data() const { return mData; }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2) {
    return data()[Stride::index(pos0, pos1, pos2)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2) const {
    return data()[Stride::index(pos0, pos1, pos2)];
  }
  _dev float &element(const size_t *pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const size_t *pos) const {
    return data()[Stride::index(pos)];
  }
  _dev float &element(const Pos3D &pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const Pos3D &pos) const {
    return data()[Stride::index(pos)];
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary3DIndexed(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt->element(pos0, pos1, pos2) = op(pos, 3);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary3D(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {

  trgt->element(pos0, pos1, pos2) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary3DHeterogenous(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary3DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt->element(pos0, pos1, pos2) = op(pos, 3, src0->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary3D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {

  trgt->element(pos0, pos1, pos2) = op(src0->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary3DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary3DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {
    const size_t pos[] {pos0, pos1, pos2};

  trgt->element(pos0, pos1, pos2) = op(pos, 3, src0->element(pos0, pos1, pos2), src1->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary3D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters2 = TTarget::shape(2) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iter2 = 0; iter2 < iters2; iter2++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    const size_t pos2 = threadIdx.z + blockIdx.z * blockDim.z + iter2 * (gridDim.z * blockDim.z);
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2))) {

  trgt->element(pos0, pos1, pos2) = op(src0->element(pos0, pos1, pos2), src1->element(pos0, pos1, pos2));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary3DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)), src1->element(src1->idxToPos(idx)));

    }
    }
}

// ======================== dimensionality: 4 ==================================

struct Pos4D {
   size_t pos[4];
    template<typename TNDArray>
   _dev static Pos4D fromIdx(size_t idx) {
     Pos4D p;
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     const size_t incr2 = incr1 * TNDArray::shape(1);
     const size_t incr3 = incr2 * TNDArray::shape(2);
     p.pos[3] = idx / incr3;
     idx -= p.pos[3] * incr3;
     p.pos[2] = idx / incr2;
     idx -= p.pos[2] * incr2;
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     return p;
   }
    template<typename TNDArray>
   _dev static Pos4D fromIdxWithLastDimSetToZero(size_t idx) {
     Pos4D p = fromIdx<TNDArray>(idx);
     p[3] = 0;
     return p;
    }
    template<typename TNDArray>
   _dev size_t toIdx() const {
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     const size_t incr2 = incr1 * TNDArray::shape(1);
     const size_t incr3 = incr2 * TNDArray::shape(2);
     return incr0 * pos[0] + incr1 * pos[1] + incr2 * pos[2] + incr3 * pos[3];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3>
struct ShapeStatic4D {
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        default: return 0;
      }
   }
};

template <size_t offset_, size_t stride0, size_t stride1, size_t stride2, size_t stride3>
struct StrideStatic4D {
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        default: return 0;
      }
    }
   _dev static size_t offset() {
      return offset_;
    }
  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2 + stride3 * pos3;
    }
  	_dev static size_t index(const size_t *pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1] + stride2 * pos[2] + stride3 * pos[3];
    }
  	_dev static size_t index(const Pos4D &pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1] + stride2 * pos[2] + stride3 * pos[3];
    }
};

template <typename TShape, typename TStride>
struct NDArrayStatic4D {
  typedef TShape Shape;
  typedef TStride Stride;
  typedef Pos4D Pos;
  float *mData;

  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t nDim() { return 4; }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2) * shape(3);
  }
  _dev static Pos4D idxToPos(size_t idx) { return Pos4D::fromIdx<Shape>(idx); }
  _dev static Pos4D idxToPosWithLastDimSetToZero(size_t idx) { return Pos4D::fromIdxWithLastDimSetToZero<Shape>(idx); }
  _dev float *data() { return mData; }
  _dev const float *data() const { return mData; }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) {
    return data()[Stride::index(pos0, pos1, pos2, pos3)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3) const {
    return data()[Stride::index(pos0, pos1, pos2, pos3)];
  }
  _dev float &element(const size_t *pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const size_t *pos) const {
    return data()[Stride::index(pos)];
  }
  _dev float &element(const Pos4D &pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const Pos4D &pos) const {
    return data()[Stride::index(pos)];
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary4DIndexed(const TElemwiseOp &op, TTarget *trgt) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt->element(pos0, pos1, pos2, pos3) = op(pos, 4);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary4D(const TElemwiseOp &op, TTarget *trgt) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {

  trgt->element(pos0, pos1, pos2, pos3) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary4DHeterogenous(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary4DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt->element(pos0, pos1, pos2, pos3) = op(pos, 4, src0->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary4D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {

  trgt->element(pos0, pos1, pos2, pos3) = op(src0->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary4DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary4DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {
    const size_t pos[] {pos0, pos1, pos2, pos3};

  trgt->element(pos0, pos1, pos2, pos3) = op(pos, 4, src0->element(pos0, pos1, pos2, pos3), src1->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary4D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3))) {

  trgt->element(pos0, pos1, pos2, pos3) = op(src0->element(pos0, pos1, pos2, pos3), src1->element(pos0, pos1, pos2, pos3));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary4DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)), src1->element(src1->idxToPos(idx)));

    }
    }
}

// ======================== dimensionality: 5 ==================================

struct Pos5D {
   size_t pos[5];
    template<typename TNDArray>
   _dev static Pos5D fromIdx(size_t idx) {
     Pos5D p;
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     const size_t incr2 = incr1 * TNDArray::shape(1);
     const size_t incr3 = incr2 * TNDArray::shape(2);
     const size_t incr4 = incr3 * TNDArray::shape(3);
     p.pos[4] = idx / incr4;
     idx -= p.pos[4] * incr4;
     p.pos[3] = idx / incr3;
     idx -= p.pos[3] * incr3;
     p.pos[2] = idx / incr2;
     idx -= p.pos[2] * incr2;
     p.pos[1] = idx / incr1;
     idx -= p.pos[1] * incr1;
     p.pos[0] = idx / incr0;
     idx -= p.pos[0] * incr0;
     return p;
   }
    template<typename TNDArray>
   _dev static Pos5D fromIdxWithLastDimSetToZero(size_t idx) {
     Pos5D p = fromIdx<TNDArray>(idx);
     p[4] = 0;
     return p;
    }
    template<typename TNDArray>
   _dev size_t toIdx() const {
     const size_t incr0 = 1;
     const size_t incr1 = incr0 * TNDArray::shape(0);
     const size_t incr2 = incr1 * TNDArray::shape(1);
     const size_t incr3 = incr2 * TNDArray::shape(2);
     const size_t incr4 = incr3 * TNDArray::shape(3);
     return incr0 * pos[0] + incr1 * pos[1] + incr2 * pos[2] + incr3 * pos[3] + incr4 * pos[4];
   }
  	_dev size_t &operator[] (const size_t dim) { return pos[dim]; }
  	_dev const size_t &operator[] (const size_t dim) const { return pos[dim]; }
};

template <size_t shape0, size_t shape1, size_t shape2, size_t shape3, size_t shape4>
struct ShapeStatic5D {
  	_dev static size_t shape(const size_t dim) {
      switch (dim) {
        case 0: return shape0;
        case 1: return shape1;
        case 2: return shape2;
        case 3: return shape3;
        case 4: return shape4;
        default: return 0;
      }
   }
};

template <size_t offset_, size_t stride0, size_t stride1, size_t stride2, size_t stride3, size_t stride4>
struct StrideStatic5D {
  	_dev static size_t stride(const size_t dim) {
      switch (dim) {
        case 0: return stride0;
        case 1: return stride1;
        case 2: return stride2;
        case 3: return stride3;
        case 4: return stride4;
        default: return 0;
      }
    }
   _dev static size_t offset() {
      return offset_;
    }
  	_dev static size_t index(const size_t pos0, const size_t pos1, const size_t pos2, const size_t pos3, const size_t pos4) {
      return offset_ + stride0 * pos0 + stride1 * pos1 + stride2 * pos2 + stride3 * pos3 + stride4 * pos4;
    }
  	_dev static size_t index(const size_t *pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1] + stride2 * pos[2] + stride3 * pos[3] + stride4 * pos[4];
    }
  	_dev static size_t index(const Pos5D &pos) {
      return offset_ + stride0 * pos[0] + stride1 * pos[1] + stride2 * pos[2] + stride3 * pos[3] + stride4 * pos[4];
    }
};

template <typename TShape, typename TStride>
struct NDArrayStatic5D {
  typedef TShape Shape;
  typedef TStride Stride;
  typedef Pos5D Pos;
  float *mData;

  _dev static size_t shape(const size_t dim) { return Shape::shape(dim); }
  _dev static size_t stride(const size_t dim) { return Stride::stride(dim); }
  _dev static size_t nDim() { return 5; }
  _dev static size_t offset() { return Stride::offset(); }
  _dev static size_t size() {
    return shape(0) * shape(1) * shape(2) * shape(3) * shape(4);
  }
  _dev static Pos5D idxToPos(size_t idx) { return Pos5D::fromIdx<Shape>(idx); }
  _dev static Pos5D idxToPosWithLastDimSetToZero(size_t idx) { return Pos5D::fromIdxWithLastDimSetToZero<Shape>(idx); }
  _dev float *data() { return mData; }
  _dev const float *data() const { return mData; }
  _dev float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) {
    return data()[Stride::index(pos0, pos1, pos2, pos3, pos4)];
  }
  _dev const float &element(size_t pos0, size_t pos1, size_t pos2, size_t pos3, size_t pos4) const {
    return data()[Stride::index(pos0, pos1, pos2, pos3, pos4)];
  }
  _dev float &element(const size_t *pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const size_t *pos) const {
    return data()[Stride::index(pos)];
  }
  _dev float &element(const Pos5D &pos) {
    return data()[Stride::index(pos)];
  }
  _dev const float &element(const Pos5D &pos) const {
    return data()[Stride::index(pos)];
  }
};

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary5DIndexed(const TElemwiseOp &op, TTarget *trgt) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5);

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary5D(const TElemwiseOp &op, TTarget *trgt) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op();

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget>
_dev void elemwise0Ary5DHeterogenous(const TElemwiseOp &op, TTarget *trgt) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op();

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary5DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5, src0->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary5D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(src0->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0>
_dev void elemwise1Ary5DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)));

    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary5DIndexed(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {
    const size_t pos[] {pos0, pos1, pos2, pos3, pos4};

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(pos, 5, src0->element(pos0, pos1, pos2, pos3, pos4), src1->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary5D(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t itersRest = (TTarget::shape(2) * TTarget::shape(3) * TTarget::shape(4)) / (gridDim.z * blockDim.z) + 1;
    const size_t iters1 = TTarget::shape(1) / (gridDim.y * blockDim.y) + 1;
    const size_t iters0 = TTarget::shape(0) / (gridDim.x * blockDim.x) + 1;
    for (size_t iterRest = 0; iterRest < itersRest; iterRest++) {
    for (size_t iter1 = 0; iter1 < iters1; iter1++) {
    for (size_t iter0 = 0; iter0 < iters0; iter0++) {
    size_t posRest = threadIdx.z + blockIdx.z * blockDim.z + iterRest * (gridDim.z * blockDim.z);
    const size_t incr2 = 1;
    const size_t incr3 = incr2 * TTarget::shape(2);
    const size_t incr4 = incr3 * TTarget::shape(3);
    const size_t pos4 = posRest / incr4;
    posRest -= pos4 * incr4;
    const size_t pos3 = posRest / incr3;
    posRest -= pos3 * incr3;
    const size_t pos2 = posRest / incr2;
    posRest -= pos2 * incr2;
    const size_t pos1 = threadIdx.y + blockIdx.y * blockDim.y + iter1 * (gridDim.y * blockDim.y);
    const size_t pos0 = threadIdx.x + blockIdx.x * blockDim.x + iter0 * (gridDim.x * blockDim.x);
    if ((pos0 < trgt->shape(0)) && (pos1 < trgt->shape(1)) && (pos2 < trgt->shape(2)) && (pos3 < trgt->shape(3)) && (pos4 < trgt->shape(4))) {

  trgt->element(pos0, pos1, pos2, pos3, pos4) = op(src0->element(pos0, pos1, pos2, pos3, pos4), src1->element(pos0, pos1, pos2, pos3, pos4));

    }
    }
    }
    }
}

template <typename TElemwiseOp, typename TTarget, typename TSrc0, typename TSrc1>
_dev void elemwise2Ary5DHeterogenous(const TElemwiseOp &op, TTarget *trgt, const TSrc0 *src0, const TSrc1 *src1) {

    const size_t iters = TTarget::size() / (gridDim.x * blockDim.x) + 1;
    for (size_t iter = 0; iter < iters; iter++) {
    const size_t idx = threadIdx.x + blockIdx.x * blockDim.x + iter * (gridDim.x * blockDim.x);
    if (idx < TTarget::size()) {

  trgt->element(trgt->idxToPos(idx)) = op(src0->element(src0->idxToPos(idx)), src1->element(src1->idxToPos(idx)));

    }
    }
}

