<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Msagl</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Msagl.Core.AlgorithmBase">
            <summary>
            Base class for algorithms that are cancelable and report progress
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.Run">
            <summary>
            Runs the algorithm.
            Inherits any preexisting cancel tokens.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.Run(Microsoft.Msagl.Core.CancelToken)">
            <summary>
            Runs the algorithm, setting up the cancel token and reverting to the old cancel token before finishing
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.RunInternal">
            <summary>
            Executes the actual algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.SetCancelToken(Microsoft.Msagl.Core.CancelToken)">
            <summary>
            Set the cancel token.  Returns the old cancel token, in case you need to revert at some stage.
            </summary>
            <param name="cancelToken">new cancel token</param>
            <returns>old cancel token</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.Cancel">
            <summary>
            Cancels the algorithm that is currently in progress.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.AlgorithmBase.IsCanceled">
            <summary>
            True if the algorithm has been canceled.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.ThrowIfCanceled">
            <summary>
            Throws an OperationCanceledException if the current algorithm has been canceled.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.threadStaticCancelToken">
            <summary>
            The current cancel token - one per thread, cached by cancelToken, below.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.cancelToken">
            <summary>
            ThreadStatic field above has about 10X the lookup cost of a local field, so we
            cache its value in cancelToken
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.AlgorithmBase.CancelToken">
            <summary>
            the current cancel token
            </summary>
        </member>
        <member name="E:Microsoft.Msagl.Core.AlgorithmBase.ProgressChanged">
            <summary>
            notifies whenever progress is made by the algorithm.  ProgressChangedEventArgs report
            0 &lt; progressRatio &lt;= 1
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.progressRatio">
            <summary>
            Total progress to date
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.localProgressStepSize">
            <summary>
            Step size to increment progressRatio when ProgressStep is called
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.localProgressSpecified">
            <summary>
            True if the progress step count has been specified using StartListenToLocalProgress.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.localStepCount">
            <summary>
            The number of times ProgressStep has been called.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.stageStartRatio">
            <summary>
            When running sub-algorithms this gives the progressRatio start point
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.stageEndRatio">
            <summary>
            When running sub-algorithms this gives the progressRatio end point
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.AlgorithmBase.LocalProgressStepSizeDefault">
            <summary>
            if StartListenToLocalProgress is not used to setup step size the following will be the
            (rather arbitrary) default.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.StartListenToLocalProgress(System.Int32,System.Double)">
            <summary>
            setup to start listening to ProgressStep() invocations from this algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.StartListenToProgress(Microsoft.Msagl.Core.AlgorithmBase,System.Double)">
            <summary>
            When starting a sub-algorithm start listening to its progress, transforming
            the progressRatio it reports (between 0 and 1) to between progressRatio and progressRatio+stageRatio
            </summary>
            <param name="childAlgorithm">The child algorithm.</param>
            <param name="stageRatio">The fraction of time the child algorithm will take of the parent algorithm.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.StopListenToProgress(Microsoft.Msagl.Core.AlgorithmBase)">
            <summary>
            When the sub-algorithm is completed this reverts us to listening to local progress
            </summary>
            <param name="childAlgorithm"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.RunChildAlgorithm(Microsoft.Msagl.Core.AlgorithmBase,System.Double)">
            <summary>
            Runs the child algorithm and listens for progress changes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.ProgressComplete">
            <summary>
            Call this to report 100% progress if your algorithm finishes early
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.ProgressStep">
            <summary>
            Checks for cancel, increases progress, and notifies any listeners of progress.
            Call whenever the algorithm makes progress.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.ProgressSteps(System.Int32)">
            <summary>
            Checks for cancel, increases progress, and notifies any listeners of progress.
            Call whenever the algorithm makes progress.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.AlgorithmBase.NotifyProgressChanged(System.Object,Microsoft.Msagl.Core.ProgressChangedEventArgs)">
            <summary>
            notifies whenever progress is made by the algorithm.  ProgressChangedEventArgs report
            0 &lt; progressRatio &lt;= 1.  Progress from sub-algorithms are converted to the correct ratio
            of the local progress
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.CollectionUtilities">
            <summary>
            various utilities for collections
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.CollectionUtilities.SafeAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            Add	key,value to dictionary if the key is not yet presented
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.CollectionUtilities.AddToMap``3(System.Collections.Generic.Dictionary{``1,``2},``1,``0)">
            <summary>
            Add	value to dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.CollectionUtilities.RemoveFromMap``3(System.Collections.Generic.Dictionary{``1,``2},``1,``0)">
            <summary>
            Remove value from dictionary
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp`1">
            <summary>
            A generic version priority queue based on the binary heap algorithm where
            the priority of each element is passed as a parameter and priority ties are broken by timestamp.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp`1.cache">
            <summary>
            it is a mapping from queue elements and their correspondent HeapElements
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp`1.DecreasePriority(`0,System.Double)">
            <summary>
            sets the object priority to c
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp`1.Test">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueueWithTimestamp`1.GetEnumerator">
            <summary>
            enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.GenericHeapElementWithTimestamp`1">
            <summary>
            A priority queue element that is compared by priority and timestamp
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.Size">
            <summary>
            Size structure
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.DataStructures.Size.Width">
            <summary>
            width
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.DataStructures.Size.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Size.#ctor(System.Double,System.Double)">
            <summary>
            constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Size.op_Division(Microsoft.Msagl.Core.DataStructures.Size,System.Double)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Size.op_Multiply(Microsoft.Msagl.Core.DataStructures.Size,System.Double)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Size.Pad(System.Double)">
            <summary>
            padding the size ( from both sides!)
            </summary>
            <param name="padding"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.SymmetricTuple`1">
            <summary>
            a tuple such that (a,b)==(b,a) for any a and b
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.SymmetricTuple`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.SymmetricTuple`1.#ctor(`0,`0)">
            <summary>
            constructor
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.SymmetricTuple`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue">
            <summary>
            A priority queue based on the binary heap algorithm
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue._priors">
            <summary>
            the array of priorities
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue.#ctor(System.Int32)">
            <summary>
            the constructor
            we suppose that all integers inserted into the queue will be less then n
            </summary>
            <param name="n">it is the number of different integers that will be inserted into the queue </param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue.Dequeue">
            <summary>
            return the first element of the queue and removes it from the queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.BinaryHeapPriorityQueue.DecreasePriority(System.Int32,System.Double)">
            <summary>
            sets the object priority to c
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.BinaryHeapWithComparer`1">
            <summary>
            A priority queue based on the binary heap algorithm.
            This class needs a comparer object to compare elements of the queue.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue`1">
            <summary>
            A generic version priority queue based on the binary heap algorithm where
            the priority of each element is passed as a parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue`1.cache">
            <summary>
            it is a mapping from queue elements and their correspondent HeapElements
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue`1.DecreasePriority(`0,System.Double)">
            <summary>
            sets the object priority to c
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue`1.Test">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue`1.GetEnumerator">
            <summary>
            enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.GenericBinaryHeapPriorityQueue`1.Peek(System.Double@)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.RBNode`1.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.RbTree`1.FindFirst(System.Func{`0,System.Boolean})">
            <summary>
            find the first, minimal, node in the tree such that predicate holds
            </summary>
            <param name="predicate">Has to be monotone in the sense that if it holds for t then it holds for any t' greater or equal than t
            so the predicate values have a form (false, false, ..., false, true, true, ..., true)
            </param>
            <returns>the first node where predicate holds or null</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.RbTree`1.FindLast(System.Func{`0,System.Boolean})">
            <summary>
            find the last, maximal, node in the tree such that predicate holds
            </summary>
            <param name="predicate">Has to be monotone in the sense that if it holds for t then it holds for any t' less or equal than t
            so the predicate values on the tree have a form (true, true, ..., true, false, false, ..., false)
            </param>
            <returns>the last node where predicate holds or null</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.RealNumberSpan">
            <summary>
            this class behaves like one dimensional bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.DataStructures.RealNumberSpan.Length">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.DataStructures.Set`1">
            <summary>
            Implementation of Set.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Insert(`0)">
            <summary>
            inserts an element into the set
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Contains(`0)">
            <summary>
            returns true when the set contains the element
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Delete(`0)">
            <summary>
            deletes the element from the set
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Remove(`0)">
            <summary>
            deletes the element from the set
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.DataStructures.Set`1.Count">
            <summary>
            returns the number elements in the set
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.GetEnumerator">
            <summary>
            returns the set entities enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.DataStructures.Set`1.IsReadOnly">
            <summary>
            the read only flag
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.CopyTo(`0[],System.Int32)">
            <summary>
            copies to an array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Clear">
            <summary>
            cleans the set
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Clone">
            <summary>
            clones the set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            constructor
            </summary>
            <param name="enumerableCollection"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.ToArray(System.Type)">
            <summary>
            creates an array from the set elements
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.op_Addition(Microsoft.Msagl.Core.DataStructures.Set{`0},Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
            overloading plus operator
            </summary>
            <param name="set0"></param>
            <param name="set1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.op_Subtraction(Microsoft.Msagl.Core.DataStructures.Set{`0},Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
            overloading plus operator
            </summary>
            <param name="set0"></param>
            <param name="set1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.op_Equality(Microsoft.Msagl.Core.DataStructures.Set{`0},Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
            overloading the == operator
            </summary>
            <param name="set0"></param>
            <param name="set1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.op_Inequality(Microsoft.Msagl.Core.DataStructures.Set{`0},Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
            overloading the == operator
            </summary>
            <param name="set0"></param>
            <param name="set1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.op_Multiply(Microsoft.Msagl.Core.DataStructures.Set{`0},Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
            intersection
            </summary>
            <param name="set0"></param>
            <param name="set1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Equals(System.Object)">
            <summary>
            the equality
            </summary>
            <param name="obj">the object to compare to</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.GetHashCode">
            <summary>
            hash code
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Add(Microsoft.Msagl.Core.DataStructures.Set{`0},Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
            a friendly add, union, operator
            </summary>
            <param name="set0"></param>
            <param name="set1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.InsertRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            inserts a range of elements into the set
            </summary>
            <param name="elements">elements to insert</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.IsContained(Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
             checks the set is contained in the "otherSet"
            </summary>
            <param name="otherSet"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.DataStructures.Set`1.Contains(Microsoft.Msagl.Core.DataStructures.Set{`0})">
            <summary>
             checks that this set conains the "otherSet"
            </summary>
            <param name="otherSet"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.ApproximateComparer">
            <summary>
            Class that provides methods for doing approximate comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
            return true if the points are close enough
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            return true if the points are close enough
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close(System.Double,System.Double)">
            <summary>
            return true if the numbers are close enough
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle,System.Double)">
            <summary>
            return true if the two rects are nearly identical (ignoring precision errors smaller than DistanceEpsilon)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Close(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            return true if the two rects are nearly identical (ignoring precision errors smaller than DistanceEpsilon)
            </summary>
            <param name="rect1">first Rectangle</param>
            <param name="rect2">second Rectangle</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Compare(System.Double,System.Double)">
            <summary>
            The usual Compare operation, but within Curve.DistanceEpsilon.
            </summary>
            <param name="numberA"></param>
            <param name="numberB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Greater(System.Double,System.Double)">
            <summary>
            The usual > operation, but within Curve.DistanceEpsilon.
            </summary>
            <param name="numberA"></param>
            <param name="numberB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.GreaterOrEqual(System.Double,System.Double)">
            <summary>
            The usual >= operation, but within Curve.DistanceEpsilon.
            </summary>
            <param name="numberA"></param>
            <param name="numberB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Less(System.Double,System.Double)">
            <summary>
            The usual less operation, but within Curve.DistanceEpsilon.
            </summary>
            <param name="numberA"></param>
            <param name="numberB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.LessOrEqual(System.Double,System.Double)">
            <summary>
            The usual less operation, but within Curve.DistanceEpsilon.
            </summary>
            <param name="numberA"></param>
            <param name="numberB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.CloseIntersections(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns true if two intersections points are close enough
            </summary>
            <param name="intersectionPoint0"></param>
            <param name="intersectionPoint1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Sign(System.Double)">
            <summary>
            0  iff value is close to zero;
            1  iff value is strictly greater than zero;
            -1 iff value is strictly lower than zero;
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilon">
            <summary>
            The distance for two points considered to be the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ApproximateComparer.SquareOfDistanceEpsilon">
            <summary>
            The square of the distance epsilon for two points considered to be the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ApproximateComparer.DistanceEpsilonPrecision">
            <summary>
            The digits of precision for the distance for two points considered to be the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ApproximateComparer.IntersectionEpsilon">
            <summary>
            The distance for two intersection points considered to be the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ApproximateComparer.Tolerance">
            <summary>
            The distance where to real numbers are considered the same
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ApproximateComparer.UserDefinedTolerance">
            <summary>
            A tolerance that is settable by users of MSAGL to adjust performance.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ApproximateComparer.NumberOfDigitsToRound">
            <summary>
            point coordinates will be rounded to NumberOfDigitsToRound for comparison
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.ConvexHull">
            <summary>
            Creates the convex hull of a set of points following "Computational Geometry, second edition" of O'Rourke
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConvexHull.CalculateConvexHull(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            calculates the convex hull of the given set of points
            </summary>
            <param name="pointsOfTheBody">Point of the convex hull.</param>
            <returns>The list of extreme points of the hull boundaries in the clockwise order</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.HullPointComparer.System#Collections#Generic#IComparer{Microsoft#Msagl#Core#Geometry#HullPoint}#Compare(Microsoft.Msagl.Core.Geometry.HullPoint,Microsoft.Msagl.Core.Geometry.HullPoint)">
            <summary>
            note that this function can change "deleted" member for collinear points
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect">
            <summary>
            A rectanglular curve with rounded corners
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.curve">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Curve">
            <summary>
             underlying curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.RadiusX">
            <summary>
            The horizontal radius of the corner ellipse segments
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.RadiusY">
            <summary>
            The vertical radius of the corner ellipse segments
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.#ctor(Microsoft.Msagl.Core.Geometry.Rectangle,System.Double,System.Double)">
            <summary>
            Create a rounded rectangle geometry
            </summary>
            <param name="bounds">rounded rectangle will fit these bounds</param>
            <param name="radiusX">horizontal radius of the corner ellipse segments</param>
            <param name="radiusY">vertical radius of the corner ellipse segments</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.FitTo(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Create a new RoundedRect with the same CornerRadius inside the target bounds
            </summary>
            <param name="target">target bounds</param>
            <returns>new RoundedRect with the same CornerRadius inside the target bounds</returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Derivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.BoundingBox">
            <summary>
            XY bounding box of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Trim(System.Double,System.Double)">
            <summary>
            returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.TrimWithWrap(System.Double,System.Double)">
            <summary>
            Returns the trimmed curve, wrapping around the end if start is greater than end.
            </summary>
            <param name="start">The starting parameter</param>
            <param name="end">The ending parameter</param>
            <returns>The trimmed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ScaleFromOrigin(System.Double,System.Double)">
            <summary>
            Returns the curved with all points scaled from the original by x and y
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t] - not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.OffsetCurve(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.GetParameterAtLength(System.Double)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ClosestParameterWithinBounds(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            returns a parameter t such that the distance between curve[t] and targetPoint is minimal 
            and t belongs to the closed segment [low,high]
            </summary>
            <param name="targetPoint">the point to find the closest point</param>
            <param name="high">the upper bound of the parameter</param>
            <param name="low">the low bound of the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.ClosestParameter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.LeftDerivative(System.Double)">
            <summary>
            The left derivative at t. 
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.RightDerivative(System.Double)">
            <summary>
            the right derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.Curvature(System.Double)">
            <summary>
            the signed curvature of the segment at t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.CurvatureDerivative(System.Double)">
            <summary>
            the derivative of the curvature at t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RoundedRect.CurvatureSecondDerivative(System.Double)">
            <summary>
            the derivative of CurvatureDerivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment">
            <summary>
            Cubic Bezier Segment
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.LeftDerivative(System.Double)">
            <summary>
            left derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.RightDerivative(System.Double)">
            <summary>
            right derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.b">
            <summary>
            control points
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.l">
            <summary>
            coefficients
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.e">
            <summary>
            coefficients
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.c">
            <summary>
            coefficients
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.B(System.Int32)">
            <summary>
            get a control point
            </summary>
            <param name="controlPointIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Trim(System.Double,System.Double)">
            <summary>
            Returns the trimmed curve
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.TrimWithWrap(System.Double,System.Double)">
            <summary>
            Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
            </summary>
            <param name="start">The starting parameter</param>
            <param name="end">The ending parameter</param>
            <returns>The trimmed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Derivative(System.Double)">
            <summary>
            first derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            the constructor
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ScaleFromOrigin(System.Double,System.Double)">
            <summary>
            Returns the curved scaled by x and y
            </summary>
            <param name="xScale"></param>
            <param name="yScale"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.OffsetCurve(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.LengthOnControlPolygon(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.BoundingBox">
            <summary>
            the segment bounding box
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ClosestParameterWithinBounds(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            returns a parameter t such that the distance between curve[t] and targetPoint is minimal 
            and t belongs to the closed segment [low,high]
            </summary>
            <param name="targetPoint">the point to find the closest point</param>
            <param name="high">the upper bound of the parameter</param>
            <param name="low">the low bound of the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Curvature(System.Double)">
            <summary>
            the signed curvature of the segment at t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.G(System.Double)">
            <summary>
            G(t) is the denomenator of the curvature
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Xp(System.Double)">
            <summary>
            the first derivative of x-coord
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Ypp(System.Double)">
            <summary>
            the second derivativ of y-coordinate
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Yp(System.Double)">
            <summary>
            the first derivative of y-coord
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Xpp(System.Double)">
            <summary>
            the seconde derivative of x coord
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Xppp(System.Double)">
            <summary>
            the third derivative of x coordinate
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.Yppp(System.Double)">
            <summary>
            the third derivative of y coordinate
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.CurvatureDerivative(System.Double)">
            <summary>
            the derivative of the curvature at t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.ClosestParameter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.MaximalCurvaturePoints">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.CurvatureSecondDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment.GetParameterAtLength(System.Double)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="curve"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.Item(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.Derivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.SecondDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.ThirdDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.ParStart">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.CurvatureDerivative.ParEnd">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.Curve">
            <summary>
            Curve: keeps a sequence of connected ICurves
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate(System.Double,Microsoft.Msagl.Core.Geometry.Point,System.Double,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double)">
            <summary>
            interpolates the curve between parameters a and side1 as by a sequence of line segments
            </summary>
            <param name="startParameter">start parameter of the interpolation</param>
            <param name="start">start point of the interpolation</param>
            <param name="endParameter">end parameter of the interpolation</param>
            <param name="end">end point of the interpolation</param>
            <param name="curve">the interpolated curve</param>
            <param name="epsilon">the maximal allowed distance between the curve and its inerpolation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Interpolate(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point@,System.Double,Microsoft.Msagl.Core.Geometry.Point@,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            this function always produces at least two segments
            </summary>
            <param name="eps"></param>
            <param name="a"></param>
            <param name="ap"></param>
            <param name="b"></param>
            <param name="bp"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.#ctor">
            <summary>
            Constructs the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.#ctor(System.Int32)">
            <summary>
            Constructs a curve with an initial segment capacity.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.TrimWithWrap(System.Double,System.Double)">
            <summary>
            Returns the trimmed curve, wrapping around the end if start is greater than end.
            </summary>
            <param name="start">The starting parameter</param>
            <param name="end">The ending parameter</param>
            <returns>The trimmed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.AddSegment(Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            Adds a segment to the curve
            </summary>
            <param name="curve">the curve that we add a segment to</param>
            <returns>the new curve extended with the segment</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.IncreaseSegmentCapacity(System.Int32)">
            <summary>
            Increases the capacity of the segment list.
            Call this before adding a bunch of segments to prevent the list from having to resize multiple times.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.Segments">
            <summary>
            Returns the list of the curve segments
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveCurveIntersectionOne(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Boolean)">
            <summary>
            finds an intersection between to curves, 
            </summary>
            <param name="curve0"></param>
            <param name="curve1"></param>
            <param name="liftIntersection">if set to true parameters of the intersection point will be given in the curve parametrization</param>
            <returns>InterseciontInfo or null if there are no intersections</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.GetAllIntersections(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Boolean)">
            <summary>
            calculates all intersections between curve0 and curve1
            </summary>
            <param name="curve0"></param>
            <param name="curve1"></param>
            <param name="liftIntersections">if set to true parameters of the intersection point will be given in the curve parametrization</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.OldIntersection(System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo},Microsoft.Msagl.Core.Geometry.Point@)">
            <summary>
            returns true if the intersection exists already
            </summary>
            <param name="intersections"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.LineSegmentThreshold">
            <summary>
            The distance between the start and end point of a curve segment for which we consider the segment as a line segment
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.GetSegmentAndParameter(System.Double,System.Double@,Microsoft.Msagl.Core.Geometry.Curves.ICurve@)">
            <summary>
            returns the segment correspoinding to t and the segment parameter
            </summary>
            <param name="t"></param>
            <param name="par"></param>
            <param name="segment"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Derivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.PointRelativeToCurveLocation(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            Decides if the point lies inside, outside or on the curve
            </summary>
            <param name="point">the point under test</param>
            <param name="curve">a closed curve</param>
            <returns>the point position characteristic</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.RealCutWithClosedCurve(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo,Microsoft.Msagl.Core.Geometry.Curves.Curve,System.Boolean)">
            <summary>
            Returns true if curves do not touch in the intersection point
            </summary>
            <param name="xx"></param>
            <param name="polygon"></param>
            <param name="onlyFromInsideCuts">if set to true and first curve is closed will return true 
            only when the second curve cuts the first one from the inside</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.RealCut(Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo,Microsoft.Msagl.Core.Geometry.Curves.Curve,System.Boolean)">
            <summary>
            
            </summary>
            <param name="xx"></param>
            <param name="polyline"></param>
            <param name="onlyFromInsideCuts">consider a cut good only if the segment cuts the polygon from inside</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.OffsetCurve(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.BoundingBox">
            <summary>
            The bounding rectangle of the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.GetParameterAtLength(System.Double)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosestParameterWithinBounds(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            returns a parameter t such that the distance between curve[t] and targetPoint is minimal 
            and t belongs to the closed segment [low,high]
            </summary>
            <param name="targetPoint">the point to find the closest point</param>
            <param name="high">the upper bound of the parameter</param>
            <param name="low">the low bound of the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosestParameter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment(Microsoft.Msagl.Core.Geometry.Curves.Curve,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            adds a line segment to the curve
            </summary>
            <param name="curve"></param>
            <param name="pointA"></param>
            <param name="pointB"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.AddLineSegment(Microsoft.Msagl.Core.Geometry.Curves.Curve,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            adds a line segment to the curve
            </summary>
            <param name="curve"></param>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment(Microsoft.Msagl.Core.Geometry.Curves.Curve,System.Double,System.Double)">
            <summary>
            adds a line segment to the curve
            </summary>
            <param name="c"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ContinueWithLineSegment(Microsoft.Msagl.Core.Geometry.Curves.Curve,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            adds a line segment to the curve
            </summary>
            <param name="c"></param>
            <param name="x"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.CloseCurve(Microsoft.Msagl.Core.Geometry.Curves.Curve)">
            <summary>
            
            </summary>
            <param name="curve"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.LeftDerivative(System.Double)">
            <summary>
            left derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.RightDerivative(System.Double)">
            <summary>
            right derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosestParameterWithPoint(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point@)">
            <summary>
            gets the closest point together with its parameter
            </summary>
            <param name="curve"></param>
            <param name="location"></param>
            <param name="pointOnCurve"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosestPoint(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            gets the point on the curve that is closest to the given point
            </summary>
            <param name="curve">the curve to examine</param>
            <param name="location">the target point</param>
            <returns>the closest point</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.CurveIsInsideOther(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            Tests whether the first curve is inside the second.
            We suppose that the curves are convex and they are 
            not degenerated into a point
            </summary>
            <param name="innerCurve"></param>
            <param name="outerCurve"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ClosedCurveInteriorsIntersect(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            Tests whether the interiors of two closed convex curves intersect
            </summary>
            <param name="curve1">convex closed curve</param>
            <param name="curve2">convex closed curve</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Curvature(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvatureDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvatureSecondDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.CurvesIntersect(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            </summary>
            <returns>True if the curves intersect each other.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.PolylineAroundClosedCurve(Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            
            </summary>
            <param name="curve"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.RefineEllipse(Microsoft.Msagl.Core.Geometry.Curves.Ellipse)">
            <summary>
            this code only works for the standard ellipse
            </summary>
            <param name="ellipse"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.PolyFromBox(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Create a closed Polyline from a rectangle
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.CreateLineCurve(System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            Convert points to line curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.ScaleFromOrigin(System.Double,System.Double)">
            <summary>
            Returns the curved scaled by x and y
            </summary>
            <param name="xScale"></param>
            <param name="yScale"></param>
            <returns></returns>     
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.LengthWithInterpolation(Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            An approximate length of the curve calculated using the interpolation
            </summary>
            <param name="curve"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Curve.LengthWithInterpolationAndThreshold(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double)">
            <summary>
            An approximate length of the curve calculated using the interpolation
            </summary>
            <param name="curve"></param>
            <param name="threshold"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Curve.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory">
            <summary>
            the helper class to create curves
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateEllipse(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates an ellipse by the length of axes and the center
            </summary>
            <param name="radiusInXDirection"></param>
            <param name="radiusInYDirection"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateCircle(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates an ellipse by the length of axes and the center
            </summary>
            <param name="radius"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangleWithRoundedCorners(System.Double,System.Double,System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Create a rectangle with smoothed corners
            </summary>
            <param name="width">the rectangle width</param>
            <param name="height">the rectangle height</param>
            <param name="radiusInXDirection">the length of the x axis of the corner smoothing ellipse</param>
            <param name="radiusInYDirection">the length of the y axis of the corner smoothing ellipse</param>
            <param name="center">the rectangle center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangleWithRoundedCorners(Microsoft.Msagl.Core.Geometry.Curves.Curve,System.Double,System.Double,System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Create in the specified curve, a rectangle with smoothed corners
            </summary>
            <param name="c"></param>
            <param name="width">the rectangle width</param>
            <param name="height">the rectangle height</param>
            <param name="radiusInXDirection">the length of the x axis of the corner smoothing ellipse</param>
            <param name="radiusInYDirection">the length of the y axis of the corner smoothing ellipse</param>
            <param name="center">the rectangle center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            create a box of the given width and height at center.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle(Microsoft.Msagl.Core.Geometry.Curves.Curve,System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            create a box of the given width and height at center.
            </summary>
            <param name="c"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateRectangle(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Create a polyline curve for the given rectangle
            </summary>
            <param name="rectangle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateHouse(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a curve resembling a house large enough to inscribe within it a rectangle of the 
            given width and height at center.
            </summary>
            <param name="width">the house width - the rectangle width</param>
            <param name="height">the height of the inscribed rectangle; the house will be half-again higher</param>
            <param name="center">the center of the inscribed rectangle</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateInteriorHouse(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates curve resembling a house within the rectangle formed by width and height at center
            (if the rectangle is a square, the house has the shape of home plate in baseball).
            </summary>
            <param name="width">the bounding rectangle width</param>
            <param name="height">the bounding rectangle height</param>
            <param name="center">the bounding rectangle center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateInvertedHouse(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a curve resembling an inverted house
            </summary>
            <param name="width">the house width</param>
            <param name="height">the house heigth</param>
            <param name="center">the house center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateDiamond(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a curve resembling a diamond large enough to inscribe within it a rectangle of the 
            given width and height at center.
            </summary>
            <param name="width">the width of the inscribed rectangle</param>
            <param name="height">the height of the inscribed rectangle</param>
            <param name="center">the diamond center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateInteriorDiamond(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a curve resembling a diamond within the rectangle formed by width and height at center.
            </summary>
            <param name="width">the bounding rectangle width</param>
            <param name="height">the bounding rectangle height</param>
            <param name="center">the bounding rectangle center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateOctagon(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a curve of the form of an octagon large enough to inscribe a rectangle
            of width and height around center.
            </summary>
            <param name="width">the inscribed rectangle width</param>
            <param name="height">the inscribed rectangle height</param>
            <param name="center">the inscribed rectangle (and octagon) center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateHexagon(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a curve of the form of an hexagon large enough to inscribe a rectangle
            of width and height around center.
            </summary>
            <param name="width">the inscribed rectangle width</param>
            <param name="height">the inscribed rectangle height</param>
            <param name="center">the inscribed rectangle (and hexagon) center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateInteriorOctagon(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a curve in the form of an octagon within the rectangle formed by width and height at center.
            </summary>
            <param name="width">the bounding rectangle width</param>
            <param name="height">the bounding rectangle height</param>
            <param name="center">the bounding rectangle center</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateTestShape(System.Double,System.Double)">
            <summary>
            testing, don't use
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateInteriorTriangle(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            create a triangle inside the box formed by width and height.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.RotateCurveAroundCenterByRadian(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
            Rotate a curve around a given point using radians
            </summary>
            <param name="curve"></param>
            <param name="center"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.RotateCurveAroundCenterByDegree(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
            Rotate a curve around a given point using degrees
            </summary>
            <param name="curve"></param>
            <param name="center"></param>
            <param name="degree"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveFactory.CreateStar(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            </summary>
            <param name="width"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.CurveTangent">
            <summary>
            used to calculate the around curve 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.CurveTangent.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="touch"></param>
            <param name="direction"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.Ellipse">
            <summary>
            A class representing an ellipse.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.OffsetCurve(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            offsets the curve in the given direction
            </summary>
            <param name="offset">the width of the offset</param>
            <param name="dir">the direction of the offset</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Reverse">
            <summary>
            Reverse the ellipe: not implemented.
            </summary>
            <returns>returns the reversed curve</returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Start">
            <summary>
            Returns the start point of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.End">
            <summary>
            Returns the end point of the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Trim(System.Double,System.Double)">
            <summary>
            Trims the curve
            </summary>
            <param name="start">the trim start parameter</param>
            <param name="end">the trim end parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.TrimWithWrap(System.Double,System.Double)">
            <summary>
            Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
            </summary>
            <param name="start">The starting parameter</param>
            <param name="end">The ending parameter</param>
            <returns>The trimmed curve</returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.AxisA">
            <summary>
            the X axis of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.AxisB">
            <summary>
            the Y axis of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Center">
            <summary>
            the center of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.BoundingBox">
            <summary>
            The bounding box of the ellipse
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Derivative(System.Double)">
            <summary>
            first derivative
            </summary>
            <param name="t">the p</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ParallelogramNodeOverICurve">
            <summary>
            a tree of ParallelogramNodes covering the edge
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ParStart">
            <summary>
            the start of the parameter domain
            </summary>   
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.#ctor(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            The point on the ellipse corresponding to the parameter t is calculated by 
            the formula center + cos(t)*axis0 + sin(t) * axis1.
            To get an ellipse rotating clockwise use, for example,
            axis0=(-1,0) and axis1=(0,1)
            <param name="parStart">start angle in radians</param>
            <param name="parEnd">end angle in radians</param>
            <param name="axis0">x radius</param>
            <param name="axis1">y radius</param>
            <param name="center">the ellipse center</param>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.#ctor(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            The point on the ellipse corresponding to the parameter t is calculated by 
            the formula center + cos(t)*axis0 + sin(t) * axis1.
            To get an ellipse rotating clockwise use, for example,
            axis0=(-1,0) and axis1=(0,1)
            </summary>
            <param name="parStart">start angle in radians</param>
            <param name="parEnd">end angle in radians</param>
            <param name="axis0">the x axis</param>
            <param name="axis1">the y axis</param>
            <param name="centerX">x coordinate of the center</param>
            <param name="centerY">y coordinate of the center</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Construct a full ellipse by two axes
            </summary>
            <param name="axis0">an axis</param>
            <param name="axis1">an axis</param>
            <param name="center"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.#ctor(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Constructs a full ellipse with axes aligned to X and Y directions
            </summary>
            <param name="axisA">the length of the X axis</param>
            <param name="axisB">the length of the Y axis</param>
            <param name="center"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Moves the ellipse to the delta vector
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ScaleFromOrigin(System.Double,System.Double)">
            <summary>
            Scales the ellipse by x and by y
            </summary>
            <param name="xScale"></param>
            <param name="yScale"></param>
            <returns>the moved ellipse</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.GetParameterAtLength(System.Double)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Transforms the ellipse
            </summary>
            <param name="transformation"></param>
            <returns>the transformed ellipse</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ClosestParameterWithinBounds(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            returns a parameter t such that the distance between curve[t] and targetPoint is minimal 
            and t belongs to the closed segment [low,high]
            </summary>
            <param name="targetPoint">the point to find the closest point</param>
            <param name="high">the upper bound of the parameter</param>
            <param name="low">the low bound of the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] : not implemented
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Length">
            <summary>
            Return the length of the ellipse curve: not implemented
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.ClosestParameter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns>the parameter of the closest point</returns>     
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.LeftDerivative(System.Double)">
            <summary>
            left derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.RightDerivative(System.Double)">
            <summary>
            right derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.Curvature(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CurvatureDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.CurvatureSecondDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.OrientedCounterclockwise">
            <summary>
            returns true if the ellipse goes counterclockwise
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.FullBox">
            <summary>
            returns the box of the ellipse that this ellipse is a part of
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Ellipse.IsArc">
            <summary>
            is it a proper circle?
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.ICurve">
            <summary>
            The interface for curves: instances of ICurve inside of GLEE
            are BSpline,Curve,LineSeg, Ellipse,CubicBezierSeg and ArrowTipCurve.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Derivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.BoundingBox">
            <summary>
            XY bounding box of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve between start and end, without wrap
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.TrimWithWrap(System.Double,System.Double)">
            <summary>
            Returns the trim curve between start and end, with wrap, if supported by the implementing class.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Moves the curve by the delta.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.ScaleFromOrigin(System.Double,System.Double)">
            <summary>
            Returns the curved with all points scaled from the original by x and y
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.OffsetCurve(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.GetParameterAtLength(System.Double)">
            <summary>
            gets the parameter at a specific length from the start along the curve
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.ClosestParameterWithinBounds(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            returns a parameter t such that the distance between curve[t] and targetPoint is minimal 
            and t belongs to the closed segment [low,high]
            </summary>
            <param name="targetPoint">the point to find the closest point</param>
            <param name="high">the upper bound of the parameter</param>
            <param name="low">the low bound of the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.ClosestParameter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.LeftDerivative(System.Double)">
            <summary>
            The left derivative at t. 
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.RightDerivative(System.Double)">
            <summary>
            the right derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.Curvature(System.Double)">
            <summary>
            the signed curvature of the segment at t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.CurvatureDerivative(System.Double)">
            <summary>
            the derivative of the curvature at t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ICurve.CurvatureSecondDerivative(System.Double)">
            <summary>
            the derivative of CurvatureDerivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.IFunction">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IFunction.Item(System.Double)">
            <summary>
            Returns the falue on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.IFunction.Derivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.IFunction.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.IFunction.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IFunction.ParStart">
            <summary>
            the domain of the function is the [ParStart, ParEnd] segment
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IFunction.ParEnd">
            <summary>
            the domain of the function is the [ParStart, ParEnd] segment
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo">
            <summary>
            Contains the result of the intersection of two ICurves.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.Par0">
            <summary>
            the parameter on the first curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.Par1">
            <summary>
            the parameter on the second curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.IntersectionPoint">
            <summary>
            the intersection point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.Segment0">
            <summary>
            the segment of the first curve where the intersection point belongs
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.Segment1">
            <summary>
            the segment of the second curve where the intersection point belongs
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.#ctor(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            the constructor
            </summary>
            <param name="pr0"></param>
            <param name="pr1"></param>
            <param name="x"></param>
            <param name="s0"></param>
            <param name="s1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.IntersectionInfo.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.LinearSystem2">
            <summary>
            solves a linear system of two equations with to unknown variables
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.LineSegment">
            <summary>
            Line segment
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.OffsetCurve(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Start">
            <summary>
            the line start point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.End">
            <summary>
            the line end point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ParStart">
            <summary>
            the start parameter
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ParEnd">
            <summary>
            the end parameter
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Trim(System.Double,System.Double)">
            <summary>
            Returns the trim curve
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.TrimWithWrap(System.Double,System.Double)">
            <summary>
            Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
            </summary>
            <param name="start">The starting parameter</param>
            <param name="end">The ending parameter</param>
            <returns>The trimmed curve</returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            construct a line segment
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.#ctor(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            constructs a line segment
            </summary>
            <param name="a">the first point</param>
            <param name="x">x-coordinate of the second point</param>
            <param name="y">y-coordinate of the second point</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            constructs a line segment
            </summary>
            <param name="x0">x-coordinate of the first point</param>
            <param name="y0">y-coordinate of the first point</param>
            <param name="x1">x-coordinate of the second point</param>
            <param name="y1">y-coordinate of the second point</param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Item(System.Double)">
            <summary>
            Returns the point on the curve corresponding to parameter t
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Derivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ToString">
            <summary>
            This is the rounded form; DebuggerDisplay shows the unrounded form.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ScaleFromOrigin(System.Double,System.Double)">
            <summary>
            Scale (multiply) from zero by x and y
            </summary>
            <param name="xScale"></param>
            <param name="yScale"></param>
            <returns>scaled copy</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.GetParameterAtLength(System.Double)">
            <summary>
            gets the parameter at a specific length from the start along the curve
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Return the transformed curve
            </summary>
            <param name="transformation"></param>
            <returns>the transformed curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ClosestParameterWithinBounds(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            returns a parameter t such that the distance between curve[t] and targetPoint is minimal 
            and t belongs to the closed segment [low,high]
            </summary>
            <param name="targetPoint">the point to find the closest point</param>
            <param name="high">the upper bound of the parameter</param>
            <param name="low">the low bound of the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.BoundingBox">
            <summary>
            The bounding box of the line
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.ClosestParameter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns a parameter t such that the distance between curve[t] and a is minimal
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.LeftDerivative(System.Double)">
            <summary>
            left derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.RightDerivative(System.Double)">
            <summary>
            right derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Intersect(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point@)">
            <summary>
            returns true if segments are not parallel and are intesecting
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="d"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.Curvature(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.CurvatureDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.CurvatureSecondDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.LineSegment.MinDistBetweenLineSegments(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double@,System.Double@)">
            <summary>
            [a,b] and [c,d] are the segments. u and v are the corresponding closest point params
            see http://www.geometrictools.com/Documentation/DistanceLine3Line3.pdf
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="d"></param>
            <param name="parab"></param>
            <param name="parcd"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve">
            <summary>
            Implements the minimal distance between curves functionality
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            constructor
            </summary>
            <param name="curveAPar">first curve</param>
            <param name="curveBPar">second curve</param>
            <param name="lowBound0">the first curve minimal parameter</param>
            <param name="upperBound0">the first curve maximal parameter</param>
            <param name="lowBound1">the second curve minimal parameter</param>
            <param name="upperBound1">the first curve maximal parameter</param>
            <param name="guess0"></param>
            <param name="guess1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.MinDistCurveCurve.Delta(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            xy - the first row
            uw - the second row
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="u"></param>
            <param name="w"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.VertexId">
            <summary>
            Parallelogram vertex type. 
            The clockwise order of vertices is Corner, A, OtherCorner,B
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.VertexId.Corner">
            <summary>
            the basic corner vertex
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.VertexId.VertexA">
            <summary>
            a vertex adjacent to the basic corner
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.VertexId.OtherCorner">
            <summary>
            the corner opposite to the basic corner
            </summary>           
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.VertexId.VertexB">
            <summary>
            another vertex adjacent to the basic corner
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram">
            <summary>
            It is a parallelogram with the vertices corner, corner+coeff,corner+coeff+side1 and corner+side1.
            Parallelograms are used by GLEE in curve intersections routines.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.ToString">
            <summary>
            to string 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Constructs the parallelogram by the corner and two sides.
            </summary>
            <param name="corner">the corner</param>
            <param name="sideA">a side</param>
            <param name="sideB">another side</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Contains(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Return true if the parallelogram contains the point
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Area">
            <summary>
            return the area of the parallelogram
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Vertex(Microsoft.Msagl.Core.Geometry.Curves.VertexId)">
            <summary>
            Return the correspoingin vertex of the parallelogram
            </summary>
            <param name="vertexPar">vertex kind</param>
            <returns>vertex value</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.Intersect(Microsoft.Msagl.Core.Geometry.Curves.Parallelogram,Microsoft.Msagl.Core.Geometry.Curves.Parallelogram)">
            <summary>
            returns true if parallelograms intersect
            </summary>
            <param name="parallelogram0"></param>
            <param name="parallelogram1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Parallelogram.GetParallelogramOfAGroup(System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Curves.Parallelogram})">
            <summary>
            create a Parallelogram over a group
            </summary>
            <param name="boxes">group of boxes</param>
            <returns>xy box</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramBinaryTreeNode">
            <summary>
            Keeps left and right sons of the node. Is used in curve intersections routines.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode">
            <summary>
            An internal node of ParallelogramNodeOverICurve hierarchy.
            Is used in curve intersections routines.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramInternalTreeNode.Children">
            <summary>
            children of the node
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramLeaf">
            <summary>
            A leaf of the ParallelogramNodeOverICurve hierarchy.
            Is used in curve intersectons routine.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode">
            <summary>
            Represents a node containing a parallelogram.
            Is used in curve intersections routines.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNode.Parallelogram">
            <summary>
            gets or sets the parallelogram of the node
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve">
            <summary>
            Serves to hold a Parallelogram and a ICurve,
            and is used in curve intersections routines.
            The node can be a top of the hierarchy if its sons are non-nulls.
            The sons are either both nulls or both non-nulls
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.Seg">
            <summary>
            The segment bounded by the parallelogram
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.LeafBoxesOffset">
            <summary>
            The leafs of this node are as tight as the offset
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramNodeForCurveSegment(Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.ParallelogramNodeOverICurve.CreateParallelogramOnSubSeg(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.Parallelogram@,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Creates a bounding parallelogram on a curve segment
            We suppose here that the segment is convex or concave from start to end,
            that is the region bounded by the straight segment seg[start], seg[end] and the curve seg is convex
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth">
            <summary>
            Works for convex curves by calculating a value which might be slightly greater than the exact penetration depth
            It is presize on convex polygons.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PenetrationVector(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            Calculates a vector of minimal length by which to move the first curve to avoid intersections of interiors.
            It is presize on polylines and will be slightly longer on curves.
            </summary>
            <param name="curve0"></param>
            <param name="curve1"></param>
            <returns>the shortest vector d such that d+curve0 does not intersect the interiou curve1</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PolylineAroundClosedCurve(Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            returns a polyline around the curve
            </summary>
            <param name="curve"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PenetrationDepth.PenetrationDepthForPolylines(Microsoft.Msagl.Core.Geometry.Curves.Polyline,Microsoft.Msagl.Core.Geometry.Curves.Polyline)">
            <summary>
            Calculates a vector of minimal length by which to move the first polyline to avoid intersection of interiors
            </summary>
            <param name="poly0"></param>
            <param name="poly1"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation">
            <summary>
            2 by 3 matrix of plane affine transformations
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.GetHashCode">
            <summary>
            hash function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Elements">
            <summary>
            the matrix elements
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Item(System.Int32,System.Int32)">
            <summary>
            i,j th element
            </summary>
            <param name="rowIndex"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.#ctor">
            <summary>
            constructs the an identity transformation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            first row, second row
            </summary>
            <param name="matrixElement00">0,0</param>
            <param name="matrixElement01">0,1</param>
            <param name="matrixElement02">0,2</param>
            <param name="matrixElement10">1,0</param>
            <param name="matrixElement11">1,1</param>
            <param name="matrixElement12">1,2</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            the matrix by point multiplication
            </summary>
            <param name="transformation"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Multiply(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Point by matrix multiplication
            </summary>
            <param name="transformation"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Multiply(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            matrix matrix multiplication
            </summary>
            <param name="transformation"></param>][
            <param name="transformation0"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Multiply(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            matrix matrix multiplication
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Division(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            matrix divided by matrix
            </summary>
            <param name="transform0"></param>
            <param name="transform1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Divide(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Divid matrix by a matrix
            </summary>
            <param name="transformation0"></param>
            <param name="transformation1"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Inverse">
            <summary>
            returns the inversed matrix
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.UnitTransformation">
            <summary>
            unit matrix
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Rotation(System.Double)">
            <summary>
            Rotation matrix
            </summary>
            <param name="angle">the angle of rotation</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.IsIdentity">
            <summary>
            checks if the matrix is an identity one
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Offset">
            <summary>
            returns the point of the matrix offset
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Equality(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.op_Inequality(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation,Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            the inequality operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.Clone">
            <summary>
            clones the transform
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation.ScaleAroundCenterTransformation(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="scale"></param>
            <param name="center"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.point">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.Point">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.Next">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.Prev">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.Polyline">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.NextOnPolyline">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint.PrevOnPolyline">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.PointLocation">
            <summary>
            Point positions relative to a closed curve enumeration
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Outside">
            <summary>
            The point is outside of the curve
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Boundary">
            <summary>
            The point is on the curve boundary
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Curves.PointLocation.Inside">
            <summary>
            The point is inside of the curve
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.Polyline">
            <summary>
            class representing a polyline
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.RequireInit">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.PolylinePoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.StartPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.EndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Closed">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Item(System.Double)">
            <summary>
            the value of the curve at the parameter
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Derivative(System.Double)">
            <summary>
            first derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.LeftDerivative(System.Double)">
            <summary>
            left derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.RightDerivative(System.Double)">
            <summary>
            right derivative at t
            </summary>
            <param name="t">the parameter where the derivative is calculated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.SecondDerivative(System.Double)">
            <summary>
            second derivative
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.ThirdDerivative(System.Double)">
            <summary>
            third derivative
            </summary>
            <param name="t">the parameter of the derivative</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.ParallelogramNodeOverICurve">
            <summary>
            A tree of ParallelogramNodes covering the curve. 
            This tree is used in curve intersections routines.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.BoundingBox">
            <summary>
            bounding box of the polyline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.ParStart">
            <summary>
            the start of the parameter domain
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.ParEnd">
            <summary>
            the end of the parameter domain
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Trim(System.Double,System.Double)">
            <summary>
            Returns the trimmed polyline. Does not change this polyline. Reversed start and end if start is less than end.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.TrimWithWrap(System.Double,System.Double)">
            <summary>
            Returns the trimmed polyline, wrapping around the end if start is greater than end.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Returns the curved moved by delta
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.ScaleFromOrigin(System.Double,System.Double)">
            <summary>
            Returns the curved with all points scaled from the original by x and y
            </summary>
            <param name="xScale"></param>
            <param name="yScale"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.AddPoint(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            adds a point to the polyline
            </summary>
            <param name="point"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Start">
            <summary>
            this[ParStart]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.End">
            <summary>
            this[ParEnd]
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Reverse">
            <summary>
            this[Reverse[t]]=this[ParEnd+ParStart-t]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.OffsetCurve(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Offsets the curve in the direction of dir
            </summary>
            <param name="offset"></param>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.LengthPartial(System.Double,System.Double)">
            <summary>
            return length of the curve segment [start,end] 
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Length">
            <summary>
            Get the length of the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.GetParameterAtLength(System.Double)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            returns the transformed polyline
            </summary>
            <param name="transformation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.ClosestParameterWithinBounds(Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            returns a parameter t such that the distance between curve[t] and targetPoint is minimal 
            and t belongs to the closed segment [low,high]
            </summary>
            <param name="targetPoint">the point to find the closest point</param>
            <param name="high">the upper bound of the parameter</param>
            <param name="low">the low bound of the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.ClosestParameter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            gets the parameter of the closest point
            </summary>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Microsoft#Msagl#Core#Geometry#Curves#ICurve#Clone">
            <summary>
            clones the curve. 
            </summary>
            <returns>the cloned curve</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            creates a polyline from a point enumeration
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            creating a polyline from two points
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.#ctor(Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.IsClockwise">
            <summary>
            true in general for convex polylines
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.GetPointLocation(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint@)">
            <summary>
            Returns the point location value. The assumption is that the polyline goes clockwise and is closed and convex.
            </summary>
            <param name="point">Point to find.</param>
            <param name="witness">if the point belongs to the boundary then witness is
                    the first point of the boundary segment containing p </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.GetPointLocation(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point@,Microsoft.Msagl.Core.Geometry.Point@)">
            <summary>
            Returns the point location value and the edge containing it if it belongs to a boundary. 
            The assumption is that the polyline goes clockwise and is closed and convex.
            </summary>
            <param name="point">Point to find</param>
            <param name="edgeStart">The starting point of the boundary hit, if any</param>
            <param name="edgeEnd">The ending point of the boundary hit, if any</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Shift(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            shift the given polyline by delta
            </summary>
            <param name="delta"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.Curvature(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.CurvatureDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.Polyline.CurvatureSecondDerivative(System.Double)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Curves.RootFinder">
            <summary>
            looking for a root of a function on a given segment
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Curves.RootFinder.TryToFindRoot(Microsoft.Msagl.Core.Geometry.Curves.IFunction,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
            implements the Newton method
            </summary>
            <param name="f"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="guess"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.ColumnPacking`1">
            <summary>
            Flow fill of columns to some maximum height
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ColumnPacking`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.RectangleToPack{`0}},System.Double)">
            <summary>
            Constructor for packing, call Run to do the actual pack.
            Each RectangleToPack.Rectangle is updated in place.
            Pack rectangles tallest to shortest, left to right until wrapWidth is reached, 
            then wrap to right-most rectangle still with vertical space to fit the next rectangle
            </summary>
            <param name="rectangles"></param>
            <param name="maxHeight"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ColumnPacking`1.RunInternal">
            <summary>
            Pack columns by iterating over rectangle enumerator until column height exceeds wrapHeight.
            When that happens, create a new column at position PackedWidth.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.OptimalColumnPacking`1">
            <summary>
            Pack rectangles (without rotation) into a given aspect ratio
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OptimalColumnPacking`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.RectangleToPack{`0}},System.Double)">
            <summary>
            Constructor for packing, call Run to do the actual pack.
            Each RectangleToPack.Rectangle is updated in place.
            Performs a Golden Section Search on packing width for the 
            closest aspect ratio to the specified desired aspect ratio
            </summary>
            <param name="rectangles"></param>
            <param name="aspectRatio"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OptimalColumnPacking`1.RunInternal">
            <summary>
            Performs a Golden Section Search on packing height for the 
            closest aspect ratio to the specified desired aspect ratio
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.OptimalPacking`1">
            <summary>
            Pack rectangles (without rotation) into a given aspect ratio
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OptimalPacking`1.PackedWidth">
            <summary>
            The width of the widest row in the packed solution
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OptimalPacking`1.PackedHeight">
            <summary>
            The height of the bounding box of the packed solution
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OptimalPacking`1.GoldenSectionSearch(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            recursively searches a weakly unimodal function f(x) between x1 and x3 for the minimum.  It is assumed x2 \le x1 and x2 \le x3
            and x2-x1=a \lt b=x3-x2.  The recursion generates a fourth point x4-x1=b \gt a=x3-x4 where x4-x2=c and b=a+c and:
            if f(x4) \lt f(x2) we search in the range [x2, x3]
            else if f(x2) \lt f(x4) we search in the range [x1, x4]
            else 
            f(x2)==f(x4) and we know that f is only weakly unimodal (not strongly unimodal) and we must search both branches.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.OptimalRectanglePacking`1">
            <summary>
            Pack rectangles (without rotation) into a given aspect ratio
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OptimalRectanglePacking`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.RectangleToPack{`0}},System.Double)">
            <summary>
            Constructor for packing, call Run to do the actual pack.
            Each RectangleToPack.Rectangle is updated in place.
            Performs a Golden Section Search on packing width for the 
            closest aspect ratio to the specified desired aspect ratio
            </summary>
            <param name="rectangles"></param>
            <param name="aspectRatio"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OptimalRectanglePacking`1.RunInternal">
            <summary>
            Performs a Golden Section Search on packing width for the 
            closest aspect ratio to the specified desired aspect ratio
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.BorderInfo">
            <summary>
            Specifies information for one of the four borders of a rectangular cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.BorderInfo.InnerMargin">
            <summary>
            Space between the border and any nodes or clusters within it, in addition
            to any internode padding specified for the ConstraintGenerator.  This effectively
            sets the outer border margin to the outermost node's outer border plus this
            InnerMargin (unless fixed, in which case the FixedPosition is the outer border
            and it is assumed to include space for InnerMargin).
            Does not apply to nodes or clusters outside the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.BorderInfo.FixedPosition">
            <summary>
            A fixed border position calculated by the application; nodes and clusters
            inside or outside the border will move in relation to it but the border
            remains stationary.  This is the axis coordinate of the outer border edge
            of the cluster on this side.  This value is NoFixedPosition if not set, and
            may be set to NoFixedPosition to clear it.  In order for the position to
            remain "fixed", set Weight to some large value, such as DefaultFixedWeight.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.BorderInfo.Weight">
            <summary>
            Border weight; set high to enforce FixedPosition.  By default it is low
            to allow the border to move freely, sizing the cluster according to the
            movement of its contained nodes and clusters.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.BorderInfo.IsFixedPosition">
            <summary>
            Returns whether FixedPosition has been set.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.BorderInfo.DefaultFreeWeight">
            <summary>
            Default weight for an unfixed border's Weight property; the property may be overridden
            by the application.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.BorderInfo.DefaultFixedWeight">
            <summary>
            Default weight for a fixed border's Weight property; the property may be overridden
            by the application.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.BorderInfo.NoFixedPosition">
            <summary>
            Value gotten from or set to FixedPosition indicating that it's not set.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.SetFixed(System.Double,System.Double)">
            <summary>
            Sets the border to fixed (resistant to movement).
            </summary>
            <param name="position">desired position</param>
            <param name="weight">coefficient of allowed movement relative to other terms; higher
                    weight is more resistant to movement.  High-weight borders can still move each other
                    due to constraint satisfaction of intervening clusters/variables.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.SetUnfixed">
            <summary>
            Sets the border to unfixed (freely moving).
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.#ctor(System.Double)">
             <summary>
             Constructor taking only a margin-width value.
             </summary>
            <param name="innerMargin"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructor taking values for margin, fixed position, and weight.
            </summary>
            <param name="innerMargin"></param>
            <param name="fixedPosition"></param>
            <param name="weight"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.ToString">
            <summary>
            Generate a string representation of the BorderInfo.
            </summary>
            <returns>A string representation of the BorderInfo.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.GetHashCode">
            <summary>
            Return a hashcode based upon data members.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.Equals(System.Object)">
            <summary>
            Compare objects based upon data members.
            </summary>
            <param name="obj">Object to be compared to the current object.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.op_Equality(Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo)">
            <summary>
            Compare two BorderInfo objects for equality of data members.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.op_Inequality(Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo)">
            <summary>
            Compare two BorderInfo objects for inequality of data members.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.op_LessThan(Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo)">
            <summary>
            Compare two BorderInfo objects for ordering based upon data members.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.BorderInfo.op_GreaterThan(Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo)">
            Compare two BorderInfo objects for ordering based upon data members.
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.PointPair">
            <summary>
            A segment line wrapper used for creation Dictionary of pairs of points
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Packing">
            <summary>
            Algorithm to pack rectangles
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Packing.PackedWidth">
            <summary>
            The width of the widest row in the packed solution
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Packing.PackedHeight">
            <summary>
            The height of the bounding box of the packed solution
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Packing.PackedAspectRatio">
            <summary>
            Aspect ratio of the bounding box of the packed solution
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.PackingConstants">
            <summary>
            Constants used by OptimalRectanglePacking
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatio">
            <summary>
            The greeks thought the GoldenRatio was a good aspect ratio: Phi = (1 + Math.Sqrt(5)) / 2
            </summary>
            <remarks>we also use this internally in our golden section search</remarks>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.PackingConstants.GoldenRatioRemainder">
            <summary>
            equiv to 1 - (1/Phi) where Phi is the Golden Ratio: i.e. the smaller of the two sections
            if you divide a unit length by the golden ratio
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.RectangleToPack`1">
            <summary>
            A rectangle and associated data that need to be packed
            </summary>
            <typeparam name="TData"></typeparam>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleToPack`1.Rectangle">
            <summary>
            Rectangle to be packed - packing will translate the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleToPack`1.Data">
            <summary>
            data associated with rectangle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleToPack`1.#ctor(Microsoft.Msagl.Core.Geometry.Rectangle,`0)">
            <summary>
            Associate a rectangle with a data item to be packed
            </summary>
            <param name="rectangle"></param>
            <param name="data"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.RectanglePacking`1">
            <summary>
            Greedily pack rectangles (without rotation) into a given aspect ratio
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectanglePacking`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.RectangleToPack{`0}},System.Double,System.Boolean)">
            <summary>
            Constructor for packing, call Run to do the actual pack.
            Each RectangleToPack.Rectangle is updated in place.
            Pack rectangles tallest to shortest, left to right until wrapWidth is reached, 
            then wrap to right-most rectangle still with vertical space to fit the next rectangle
            </summary>
            <param name="rectangles"></param>
            <param name="wrapWidth"></param>
            <param name="rectanglesPresorted">If the rectangles are already sorted into the order to pack, then specify true</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectanglePacking`1.SortRectangles(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.RectangleToPack{`0}})">
            <summary>
            Sort rectangles by height
            </summary>
            <param name="rectangles"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectanglePacking`1.RunInternal">
            <summary>
            Pack rectangles tallest to shortest, left to right until wrapWidth is reached, 
            then wrap to right-most rectangle still with vertical space to fit the next rectangle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectanglePacking`1.Pack(System.Collections.Generic.IEnumerator{Microsoft.Msagl.Core.Geometry.RectangleToPack{`0}})">
            <summary>
            Traverses the rectangleEnumerator and places rectangles at the next available slot beneath the current parent,
            until the parent is filled or until maxRowWidth is reached.  Each successfully placed rectangle is pushed onto
            a stack, when there is no room for the rectangle we pop the stack for a new parent and try again.
            </summary>
            <param name="rectangleEnumerator">rectangles to pack</param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.IntervalNode`1">
            <summary>
            Represents a node containing a box and some user data.
            Is used in curve intersections routines.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalNode`1.Count">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.#ctor">
            <summary>
            creates an empty node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.#ctor(`0,Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="rect"></param>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.IntervalNode`1.interval">
            <summary>
            This field provides direct internal access to the value type Interval, which RTree and other callers
            modify directly with .Add(); the auto-property returns a temporary value-by-copy that is immediately discarded.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalNode`1.Interval">
            <summary>
            gets or sets the interval of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalNode`1.IsLeaf">
            <summary>
            false if it is an internal node and true if it is a leaf
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalNode`1.Left">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalNode`1.Right">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalNode`1.UserData">
            <summary>
            The actual data if a leaf node, else null or a value-type default.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalNode`1.Parent">
            <summary>
            Parent of this node.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.FirstHitNode(System.Double,System.Func{System.Double,`0,Microsoft.Msagl.Core.Geometry.HitTestBehavior})">
            <summary>
            brings the first leaf which interval was hit and the delegate is happy with the object
            </summary>
            <param name="point"></param>
            <param name="hitTestFordoubleDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.FirstIntersectedNode(Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            brings the first leaf which interval was intersected
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.FirstHitNode(System.Double)">
            <summary>
            brings the first leaf which interval was hit and the delegate is happy with the object
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.AllHitItems(Microsoft.Msagl.Layout.LargeGraphLayout.Interval,System.Func{`0,System.Boolean})">
            <summary>
            returns all leaf nodes for which the interval was hit and the delegate is happy with the object
            </summary>
            <param name="intervalPar"></param>
            <param name="hitTestAccept"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.AllHitItems(System.Double)">
            <summary>
            returns all items for which the interval contains the point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.VisitTree(System.Func{`0,Microsoft.Msagl.Core.Geometry.HitTestBehavior},Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            Returns all leaves whose intervals intersect hitInterval (or all leaves before hitTest returns false).
            </summary>
            <param name="hitTest"></param>
            <param name="hitInterval"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.GetNodeItemsIntersectingInterval(Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            yields all leaves which intervals intersect the given one. We suppose that leaves are all nodes having UserData not a null.
            </summary>
            <param name="intervalPar"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.GetLeafIntervalNodesIntersectingInterval(Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            yields all leaves whose intervals intersect the given one. We suppose that leaves are all nodes having UserData not a null.
            </summary>
            <param name="intervalPar"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.GetAllLeaves">
            <summary>
            Walk the tree and return the data from all leaves
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.CreateIntervalNodeOnEnumeration(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.IntervalNode{`0}})">
            <summary>
            calculates a tree based on the given nodes
            </summary>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.CreateIntervalNodeOnData(System.Collections.Generic.IEnumerable{`0},System.Func{`0,Microsoft.Msagl.Layout.LargeGraphLayout.Interval})">
            <summary>
            calculates a tree based on the given nodes
            </summary>
            <param name="dataEnumeration"></param>
            <param name="intervalDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.CreateIntervalNodeOnListOfNodes(System.Collections.Generic.IList{Microsoft.Msagl.Core.Geometry.IntervalNode{`0}})">
            <summary>
            
            </summary>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNode`1.TraverseHierarchy(Microsoft.Msagl.Core.Geometry.IntervalNode{`0},System.Action{Microsoft.Msagl.Core.Geometry.IntervalNode{`0}})">
            <summary>
            Walk the tree from node down and apply visitor to all nodes
            </summary>
            <param name="node"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.FindIntersectionWithProperty``1(Microsoft.Msagl.Core.Geometry.IntervalNode{``0},Microsoft.Msagl.Core.Geometry.IntervalNode{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            returns true if "property" holds for some pair
            </summary>
            <typeparam name="TA"></typeparam>
            <param name="a"></param>
            <param name="b"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalNodeUtils.HandleEquality``1(Microsoft.Msagl.Core.Geometry.IntervalNode{``0},System.Action{``0,``0})">
            <summary>
            we need to avoid calling action twice for the same pair
            </summary>
            <typeparam name="TA"></typeparam>
            <param name="a"></param>
            <param name="action"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.IntervalRTree`1">
            <summary>
            A search tree for rapid lookup of TData objects keyed by rectangles inside a given rectangular region
            It is very similar to "R-TREES. A DYNAMIC INDEX STRUCTURE FOR SPATIAL SEARCHING" by Antonin Guttman
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.RootNode">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.Msagl.Layout.LargeGraphLayout.Interval,`0}})">
            <summary>
            Create the query tree for a given enumerable of TData keyed by Intervals
            </summary>
            <param name="rectsAndData"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.#ctor(Microsoft.Msagl.Core.Geometry.IntervalNode{`0})">
            <summary>
            Create a query tree for a given root node
            </summary>
            <param name="rootNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.Count">
            <summary>
            The number of data elements in the tree (number of leaf nodes)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.Add(Microsoft.Msagl.Layout.LargeGraphLayout.Interval,`0)">
            <summary>
            Add the given key, value pair
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.Rebuild">
            <summary>
            rebuild the whole tree
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.GetAllLeaves">
            <summary>
            return all the data elements stored at the leaves of the BSPTree in an IEnumerable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.GetAllIntersecting(Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            Get all data items with rectangles intersecting the specified rectangular region
            </summary>
            <param name="queryRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.GetAllLeavesIntersectingInterval(Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            Get all leaf nodes with rectangles intersecting the specified rectangular region
            </summary>
            <param name="queryRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.IsIntersecting(Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            Does minimal work to determine if any objects in the tree intersect with the query region
            </summary>
            <param name="queryRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.Contains(Microsoft.Msagl.Layout.LargeGraphLayout.Interval,`0)">
            <summary>
            return true iff there is a node with the rectangle and UserData that equals to the parameter "userData"
            </summary>
            <param name="rectangle"></param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.Remove(Microsoft.Msagl.Layout.LargeGraphLayout.Interval,`0)">
            <summary>
            </summary>
            <param name="rectangle"></param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.IntervalRTree`1.Clean">
            <summary>
            Removes everything from the tree
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.FindIntersectionWithProperty``1(Microsoft.Msagl.Core.Geometry.RectangleNode{``0},Microsoft.Msagl.Core.Geometry.RectangleNode{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            returns true if "property" holds for some pair
            </summary>
            <typeparam name="TA"></typeparam>
            <param name="a"></param>
            <param name="b"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNodeUtils.HandleEquality``1(Microsoft.Msagl.Core.Geometry.RectangleNode{``0},System.Action{``0,``0})">
            <summary>
            we need to avoid calling action twice for the same pair
            </summary>
            <typeparam name="TA"></typeparam>
            <param name="a"></param>
            <param name="action"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Site">
            <summary>
            A class for keeping polyline points in a double linked list
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Site.previouisBezierCoefficient">
            <summary>
            the coeffiecient used to calculate the first and the second control points of the 
            Bezier segment for the fillet at the site
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Site.PreviousBezierSegmentFitCoefficient">
            <summary>
            used to calculate the first control points: the formula is kPrev * a + (1 - kPrev) * b
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Site.nextBezierCoefficient">
            <summary>
            the coeffiecient used to calculate the third and the fourth control points of the 
            Bezier segment for the fillet at the site
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Site.NextBezierSegmentFitCoefficient">
            <summary>
            the coefficient tells how tight the segment fits to the segment after the site; the formula is kNext * c + (1 - kNext) * b
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Site.PreviousTangentCoefficient">
            <summary>
            used to calculate the second control point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Site.NextTangentCoefficient">
            <summary>
            used to calculate the third control point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Site.Point">
            <summary>
            gets the site point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Site.Previous">
            <summary>
            gets the previous site
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Site.Next">
            <summary>
            gets the next site
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Site.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            the constructor
            </summary>
            <param name="sitePoint"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Site.#ctor(Microsoft.Msagl.Core.Geometry.Site,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            a constructor
            </summary>
            <param name="previousSite"></param>
            <param name="sitePoint"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Site.#ctor(Microsoft.Msagl.Core.Geometry.Site,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Site)">
            <summary>
            a constructor
            </summary>
            <param name="previousSite"></param>
            <param name="sitePoint"></param>
            <param name="nextSite"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Site.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Disc">
            <summary>
            Disc for use in Minimum Enclosing Disc computation
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Disc.c">
            <summary>
            disc centre
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Disc.Center">
            <summary>
            disc centre
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Disc.r">
            <summary>
            radius
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Disc.Radius">
            <summary>
            Radius of disc
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.Distance2(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            squared distance from the centre of this disc to point
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.Contains(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Test if point is contained in this disc
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.Contains(Microsoft.Msagl.Core.Geometry.Point[],System.Int32[])">
            <summary>
            test if all specified points (apart from the except list) are contained in this disc
            </summary>
            <param name="points">points to test for containment</param>
            <param name="except">short list of exclusions</param>
            <returns>true if all points are contained in the disc</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            create a zero radius disc centred at center
            </summary>
            <param name="center">center of disc</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.midPoint(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            find the point mid-way between two points
            </summary>
            <param name="startPoint"></param>
            <param name="endPoint"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Create the smallest possible disc with the specified points on the boundary
            </summary>
            <param name="firstBoundaryPoint"></param>
            <param name="secondBoundaryPoint"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.OnBoundary(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            test if a point lies on (within a small delta of) the boundary of this disc
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.centre(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            computes the centre of the disc with the 3 specified points on the boundary
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.Collinear(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            if the area of the triangle formed by the 3 points is 0 then the points are collinear
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Disc.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Create a disc with the specified points on the boundary
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.MoveToFront">
            <summary>
            implementation of the "MoveToFront" method for computing the minimum enclosing disc of a collection of points.
            Runs in time linear in the number of points.  After Welzl'1991.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.MoveToFront.disc">
            <summary>
            minimum enclosing disc
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.MoveToFront.boundary">
            <summary>
            list of 2 or 3 points lying on the boundary
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MoveToFront.#ctor(Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            Constructs the minimum enclosing disc for the specified points
            </summary>
            <param name="ps"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.MinimumEnclosingDisc">
            <summary>
            static methods for obtaining a minimum enclosing disc of a collection of points
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MinimumEnclosingDisc.LinearComputation(Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            linear-time computation using the move-to-front heuristic by Welzl
            </summary>
            <param name="points">points that must be enclosed</param>
            <returns>Smallest disc that encloses all the points</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MinimumEnclosingDisc.SlowComputation(Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            Computing the minimum enclosing disc the slow stupid way.  Just for testing purposes.
            </summary>
            <param name="points"></param>
            <returns>Smallest disc that encloses all the points</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary">
            <summary>
            Clusters can (optionally) have a rectangular border which is respected by overlap avoidance.
            Currently, this is controlled by FastIncrementalLayoutSettings.RectangularClusters.
            If FastIncrementalLayoutSettings.RectangularClusters is true, then the 
            FastIncrementalLayout constructor will create a RectangularBoundary in each cluster.
            Otherwise it will be null.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.#ctor">
            <summary>
            Set margins to zero which also initializes other members.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.LeftMargin">
            <summary>
            Left margin of this cluster (additional space inside the cluster border).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.RightMargin">
            <summary>
            Right margin of this cluster (additional space inside the cluster border).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.TopMargin">
            <summary>
            Top margin of this cluster (additional space inside the cluster border).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.BottomMargin">
            <summary>
            Bottom margin of this cluster (additional space inside the cluster border).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.LeftBorderInfo">
            <summary>
            Information for the Left border of the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.RightBorderInfo">
            <summary>
            Information for the Right border of the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.TopBorderInfo">
            <summary>
            Information for the Top border of the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.BottomBorderInfo">
            <summary>
            Information for the Bottom border of the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.GenerateFixedConstraints">
            <summary>
            When this is set, the OverlapRemovalCluster will generate equality constraints rather than inequalities
            to keep its children within its bounds.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.GenerateFixedConstraintsDefault">
            <summary>
            The default value that GenerateFixedConstraints will be reverted to when a lock is released
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.RectangularHull">
            <summary>
            The rectangular hull of all the points of all the nodes in the cluster, as set by
            ProjectionSolver.Solve().
            Note: This rectangle may not originate at the barycenter.  Drawing uses only the results
            of this function; the barycenter is used only for gravity computations.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.Rect">
            <summary>
            Will only return something useful if FastIncrementalLayoutSettings.AvoidOverlaps is true.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.InnerRect">
            <summary>
            Returns (bounding) Rect with margins subtracted
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.DefaultLeftMargin">
            <summary>
            The default margin stored by StoreDefaultMargin
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.DefaultTopMargin">
            <summary>
            The default margin stored by StoreDefaultMargin
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.DefaultRightMargin">
            <summary>
            The default margin stored by StoreDefaultMargin
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.DefaultBottomMargin">
            <summary>
            The default margin stored by StoreDefaultMargin
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.StoreDefaultMargin">
            <summary>
            store a the current margin as the default which we can revert to later with the RestoreDefaultMargin
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.StoreDefaultMargin(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            store a default margin which we can revert to later with the RestoreDefaultMargin
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.RestoreDefaultMargin">
            <summary>
            revert to a previously stored default margin
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.TranslateRectangle(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Move the bounding box by delta
            </summary>
            <param name="delta"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.RadiusX">
            <summary>
            Radius on the X axis
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.RadiusY">
            <summary>
            Radius on the Y axis
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.Lock(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a lock on all four borders
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="top"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.Unlock">
            <summary>
            Releases the lock on all four borders
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.Lock">
            <summary>
            Locks all four borders at their current positions
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.MinWidth">
            <summary>
            boundary can shrink no more than this
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangularClusterBoundary.MinHeight">
            <summary>
            boundary can shrink no more than this
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.RTree`1">
            <summary>
            A search tree for rapid lookup of TData objects keyed by rectangles inside a given rectangular region
            It is very similar to "R-TREES. A DYNAMIC INDEX STRUCTURE FOR SPATIAL SEARCHING" by Antonin Guttman
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RTree`1.RootNode">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.Msagl.Core.Geometry.Rectangle,`0}})">
            <summary>
            Create the query tree for a given enumerable of TData keyed by Rectangles
            </summary>
            <param name="rectsAndData"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.#ctor(Microsoft.Msagl.Core.Geometry.RectangleNode{`0})">
            <summary>
            Create a query tree for a given root node
            </summary>
            <param name="rootNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RTree`1.Count">
            <summary>
            The number of data elements in the tree (number of leaf nodes)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.Add(Microsoft.Msagl.Core.Geometry.Rectangle,`0)">
            <summary>
            Add the given key, value pair
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.Rebuild">
            <summary>
            rebuild the whole tree
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.GetAllLeaves">
            <summary>
            return all the data elements stored at the leaves of the BSPTree in an IEnumerable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.GetAllIntersecting(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Get all data items with rectangles intersecting the specified rectangular region
            </summary>
            <param name="queryRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.GetAllLeavesIntersectingRectangle(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Get all leaf nodes with rectangles intersecting the specified rectangular region
            </summary>
            <param name="queryRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.IsIntersecting(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Does minimal work to determine if any objects in the tree intersect with the query region
            </summary>
            <param name="queryRegion"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.Contains(Microsoft.Msagl.Core.Geometry.Rectangle,`0)">
            <summary>
            return true iff there is a node with the rectangle and UserData that equals to the parameter "userData"
            </summary>
            <param name="rectangle"></param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.Remove(Microsoft.Msagl.Core.Geometry.Rectangle,`0)">
            <summary>
            </summary>
            <param name="rectangle"></param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RTree`1.Clear">
            <summary>
            Removes everything from the tree
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Point">
            <summary>
            Two dimensional point
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Equals(System.Object)">
            <summary>
            overrides the equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Point.Length">
            <summary>
            the point norm
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Point.LengthSquared">
            <summary>
            point norm squared (faster to compute than Length)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Equality(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            overrides the equality
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_LessThan(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            overrides the less operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_LessThanOrEqual(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            overrides the less or equal operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_GreaterThanOrEqual(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            overrides the greater or equal operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_GreaterThan(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            overrides the greater operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Inequality(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            the inequality operator
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_UnaryNegation(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
             the negation operator
            </summary>
            <param name="point0"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Negate">
            <summary>
            the negation operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Addition(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
             the addition
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Add(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
             the addition
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Subtraction(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            overrides the substraction
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Subtract(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            overrides the substraction
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Multiply(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            othe internal product
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.CrossProduct(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            cross product
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Scale(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            the multipliction by scalar in x and y
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Multiply(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            the multipliction by scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Multiply(Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
            multiplication on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Multiply(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
             multiplication on coefficient scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Multiply(Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
             multiplication on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Division(Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
             division on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.op_Division(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            division on coefficient scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Divide(Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
            division on coefficient scalar
            </summary>
            <param name="point"></param>
            <param name="coefficient"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Divide(System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            division on coefficient scalar
            </summary>
            <param name="coefficient"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.ToString">
            <summary>
            Rounded representation of the points.  DebuggerDisplay shows the unrounded form.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Point.X">
            <summary>
            the x coordinate
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Point.Y">
            <summary>
            the y coordinate
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.#ctor(System.Double,System.Double)">
            <summary>
            construct the point from x and y coordinates
            </summary>
            <param name="xCoordinate"></param>
            <param name="yCoordinate"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Rotate(System.Double)">
            <summary>
            returns this rotated by the angle counterclockwise; does not change "this" value
            </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Normalize">
            <summary>
            creates coefficient new point with the norm 1, does not change "this" point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Angle(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            The counter-clockwise angle when rotating point1 towards point3 around point2
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Angle(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            The angle you need to turn "side0" counterclockwise to make it collinear with "side1"
            </summary>
            <param name="side0"></param>
            <param name="side1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.GetOrientationOf3Vectors(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            computes orientation of three vectors with a common source
            (compare polar angles of v1 and v2 with respect to v0)
            </summary>
            <returns>
             -1 if the orientation is v0 v1 v2
              1 if the orientation is v0 v2 v1
              0  if v1 and v2 are collinear and codirectinal
            </returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.SignedDoubledTriangleArea(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            If the area is negative then C lies to the right of the line [cornerA, cornerB] or, in another words, the triangle (A , B, C) is oriented clockwize
            If it is positive then C lies ot he left of the line [A,B] another words, the triangle A,B,C is oriented counter-clockwize.
            Otherwise A ,B and C are collinear.
            </summary>
            <param name="cornerA"></param>
            <param name="cornerB"></param>
            <param name="cornerC"></param>
            <returns></returns>        
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientation(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            figures out the triangle on the plane orientation: positive- counterclockwise, negative - clockwise
            </summary>
            <param name="cornerA"></param>
            <param name="cornerB"></param>
            <param name="cornerC"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithIntersectionEpsilon(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            figures out the triangle on the plane orientation: positive- counterclockwise, negative - clockwise
            </summary>
            <param name="cornerA"></param>
            <param name="cornerB"></param>
            <param name="cornerC"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.GetTriangleOrientationWithNoEpsilon(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            figures out the triangle on the plane orientation: positive- counterclockwise, negative - clockwise
            </summary>
            <param name="cornerA"></param>
            <param name="cornerB"></param>
            <param name="cornerC"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.CanProject(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns true if an orthogonal projection of point on [segmentStart,segmentEnd] exists
            </summary>
            <param name="point"></param>
            <param name="segmentStart"></param>
            <param name="segmentEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.ProjectionToLine(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            projects a point to an infinite line
            </summary>
            <param name="pointOnLine0"> a point on the line </param>
            <param name="pointOnLine1"> a point on the line </param>
            <param name="point"> the point to project </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.DistToLineSegment(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double@)">
            <summary>
            The closest point on the segment [segmentStart,segmentEnd] to "point". 
            See the drawing DistToLineSegment.gif.
            </summary>
            <param name="point"></param>
            <param name="segmentStart"></param>
            <param name="segmentEnd"></param>
            <param name="parameter">the parameter of the closest point</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.ClosestPointAtLineSegment(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            The closest point on the segment [segmentStart,segmentEnd] to "point". 
            See the drawing DistToLineSegment.gif.
            </summary>
            <param name="point"></param>
            <param name="segmentStart"></param>
            <param name="segmentEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.ClosestParameterOnLineSegment(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            return parameter on the segment [segStart, segEnd] which is closest to the "point"
            see the drawing DistToLineSegment.gif
            </summary>
            <param name="point"></param>
            <param name="segmentStart"></param>
            <param name="segmentEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.LineLineIntersection(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point@)">
            <summary>
            get the intersection of two infinite lines
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="d"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.SegmentSegmentIntersection(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point@)">
            <summary>
            get the intersection of two line segments
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="d"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLineOrOnLine(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
             <summary>
            returns true if "point" lies to the left of or on the line linePoint0, linePoint1 
             </summary>
             <param name="point"></param>
             <param name="linePoint0"></param>
             <param name="linePoint1"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.PointToTheLeftOfLine(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
             returns true if "point" lies to the left of the line linePoint0, linePoint1 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLineOrOnLine(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
             <summary>
            returns true if "point" lies to the right of the line linePoint0, linePoint1 
             </summary>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.PointToTheRightOfLine(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.CompareTo(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            compares two points in the lexigraphical order
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Point.CompassDirection">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Point.L1">
            <summary>
            the L1 norm
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Rotate90Ccw">
            <summary>
            rotates the point 90 degrees counterclockwise
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.Rotate90Cw">
            <summary>
            rotates the point 90 degrees counterclockwise
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Point.RandomPoint">
            <summary>
            creates random unit point
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.SmoothedPolyline">
            <summary>
            represents the polyline of an edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.FromPoints(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Point})">
             <summary>
             creates the polyline from corner points
             </summary>
            <param name="points">points of the polyline</param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.HeadSite">
            <summary>
            the first site of the polyline
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.Clone">
            <summary>
            clones the polyline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.#ctor(Microsoft.Msagl.Core.Geometry.Site)">
            <summary>
            a constructor
            </summary>
            <param name="head"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.LastSite">
            <summary>
            the last site of the polyline
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.CreateCurve">
            <summary>
            Creates a curve by using the underlying polyline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.GetEnumerator">
            <summary>
            the enumerator of the polyline corners
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.SmoothedPolyline.Reverse">
            <summary>
            returns the reversed smoothed polyline and does not change "this"
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.TriangleOrientation">
            <summary>
            triangle orientations
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.TriangleOrientation.Clockwise">
            <summary>
            clockwise orientation
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.TriangleOrientation.Counterclockwise">
            <summary>
            counter clockwise orientation
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.TriangleOrientation.Collinear">
            <summary>
            the points are collinear
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling">
            <summary>
            Classical Multidimensional Scaling. Given a set of proximities or
            dissimilarities ordistances between objects, multidimensional scaling
            recovers low-dimensional coordinates for these objects with these
            distances.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DoubleCenter(System.Double[][])">
            <summary>
            Double-centers a matrix in such a way that the center of gravity is zero.
            After double-centering, each row and each column sums up to zero.
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SquareEntries(System.Double[][])">
            <summary>
            Squares all entries of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Multiply(System.Double[][],System.Double)">
            <summary>
            Multiplies a matrix with a scalar factor.
            </summary>
            <param name="matrix">A matrix.</param>
            <param name="factor">A scalar factor.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Multiply(System.Double[][],System.Double[])">
            <summary>
            Multiply a square matrix and a vector. 
            Note that matrix width and vector length
            have to be equal, otherwise null is returned.
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.</param>
            <returns>The resulting product vector, or null if matrix and vector
            are incompatible.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Norm(System.Double[])">
            <summary>
            Gives the norm of a vector, that is, its length in
            vector.length dimensional Euclidean space.
            </summary>
            <param name="x">A vector.</param>
            <returns>The norm of the vector.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.Normalize(System.Double[])">
            <summary>
            Normalizes a vector to unit length (1.0) in
            vector.length dimensional Euclidean space.
            If the vector is the 0-vector, nothing is done.
            </summary>
            <param name="x">A vector.</param>
            <returns>The norm of the vector.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.RandomUnitLengthVector(System.Int32,System.Int32)">
            <summary>`
            Gives a random unit Euclidean length vector of a given size.
            </summary>
            <param name="n">The size ofthe vector.</param>
            <param name="seed">A seed for the random number generator.</param>
            <returns>A random vector.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SpectralDecomposition(System.Double[][],System.Double[]@,System.Double@,System.Double[]@,System.Double@)">
            <summary>
            Computes the two dominant eigenvectors and eigenvalues of a symmetric
            square matrix.
            </summary>
            <param name="A">A matrix.</param>
            <param name="u1">First eigenvector.</param>
            <param name="lambda1">First eigenvalue.</param>
            <param name="u2">Second eigenvector.</param>
            <param name="lambda2">Second eigenvalue.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.SpectralDecomposition(System.Double[][],System.Double[]@,System.Double@,System.Double[]@,System.Double@,System.Int32,System.Double)">
            <summary>
            Computes the two dominant eigenvectors and eigenvalues of a symmetric
            square matrix.
            </summary>
            <param name="A">A matrix.</param>
            <param name="u1">First eigenvector.</param>
            <param name="lambda1">First eigenvalue.</param>
            <param name="u2">Second eigenvector.</param>
            <param name="lambda2">Second eigenvalue.</param>
            <param name="maxIterations"></param>
            <param name="epsilon"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DotProduct(System.Double[],System.Double[])">
            <summary>
            Gives the inner product of two vectors of the same size.
            </summary>
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            <returns>The inner product of the two vectors.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.MakeOrthogonal(System.Double[],System.Double[])">
            <summary>
            Orthogonalizes a vector against another vector, so that
            their scalar product is 0.
            </summary>
            <param name="x">Vector to be orthogonalized.</param>
            <param name="y">Vector to orthogonalize against.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.ClassicalScaling(System.Double[][],System.Double[]@,System.Double[]@)">
            <summary>
            Classical multidimensional scaling.  Computes two-dimensional coordinates
            for a given distance matrix by computing the two largest eigenvectors
            and eigenvalues of a matrix assiciated with the distance matrix (called
            "fitting inner products").
            </summary>
            <param name="d">The distance matrix.</param>
            <param name="x">The first eigenvector (scaled by the root of its eigenvalue)</param>
            <param name="y">The second eigenvector (scaled by the root of its eigenvalue)</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DistanceScalingSubset(System.Double[][],System.Double[],System.Double[],System.Double[][],System.Int32)">
            <summary>
            Multidimensional scaling.  Computes two-dimensional coordinates
            for a given distance matrix by fitting the coordinates to these distances
            iteratively by majorization (called "distance fitting").
            Only objects that have rows in the distance/weight matrix
            is subject to iterative relocation.
            </summary>
            <param name="d">A distance matrix.</param>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
            <param name="w">Weight matrix.</param>
            <param name="numberOfIterations">Number of iteration steps.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.DistanceScaling(System.Double[][],System.Double[],System.Double[],System.Double[][],System.Int32)">
            <summary>
            Multidimensional scaling.  Computes two-dimensional coordinates
            for a given distance matrix by fitting the coordinates to these distances
            iteratively by majorization (called "distance fitting").
            (McGee, Kamada-Kawai)
            </summary>
            <param name="d">A distance matrix.</param>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
            <param name="w">Weight matrix.</param>
            <param name="iter">Number of iteration steps.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.ExponentialWeightMatrix(System.Double[][],System.Double)">
            <summary>
            Convenience method for generating a weight matrix from a distance matrix.
            Each output entry is the corresponding input entry powered by a constant
            exponent.
            </summary>
            <param name="d">A distance matrix.</param>
            <param name="exponent">The exponent.</param>
            <returns>A weight matrix.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.EuclideanDistanceMatrix(System.Double[],System.Double[])">
            <summary>
            Convenience method for all Euclidean distances within two-dimensional
            positions.
            </summary>
            <param name="x">Coordinates.</param>
            <param name="y">Coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.MultidimensionalScaling.LandmarkClassicalScaling(System.Double[][],System.Double[]@,System.Double[]@,System.Int32[])">
            <summary>
            Approximation to classical multidimensional scaling.
            Computes two-dimensional coordinates
            for a given rectangular distance matrix.
            </summary>
            <param name="d">The distance matrix.</param>
            <param name="x">The first eigenvector (scaled by the root of its eigenvalue)</param>
            <param name="y">The second eigenvector (scaled by the root of its eigenvalue)</param>
            <param name="pivotArray">index of pivots</param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster">
            <summary>
            A cluster is a structure that acts as a Node for Nodes and Clusters at a sibling level,
            and can also contain other Clusters and/or Nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.IsEmpty">
            <summary>
            Empty clusters are ignored on positioning.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.TranslateChildren">
            <summary>
            If the following is true then constraints will be generated the prevent children coming
            any closer to the cluster boundaries.  In effect, this means that the cluster and all
            it's children will be translated together rather than being "compressed" if there are
            overlaps with external nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.LeftBorderNode">
            <summary>
            The internal Node containing the Variable to which left-border constraints are made.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.RightBorderNode">
            <summary>
            The internal Node containing the Variable to which right-border constraints are made.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.OpenBorderInfo">
            <summary>
            Opening margin of this cluster (additional space inside the cluster border)
            along the primary axis; on Left if horizontal, else on Top.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CloseBorderInfo">
            <summary>
            Closing margin of this cluster (additional space inside the cluster border)
            along the primary axis; on Right if horizontal, else on Bottom.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.OpenBorderInfoP">
            <summary>
            Opening margin of this cluster (additional space inside the cluster border)
            along the secondary (Perpendicular) axis; on Top if horizontal, else on Left.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.CloseBorderInfoP">
            <summary>
            Closing margin of this cluster (additional space inside the cluster border)
            along the secondary (Perpendicular) axis; on Bottom if horizontal, else on Right.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.MinimumSize">
            <summary>
            Minimum size along the primary axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.MinimumSizeP">
            <summary>
            Minimum size along the perpendicular axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.NodePadding">
            <summary>
            Padding of nodes within the cluster in the parallel direction.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.NodePaddingP">
            <summary>
            Padding of nodes within the cluster in the perpendicular direction.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ClusterPadding">
            <summary>
            Padding outside the cluster in the parallel direction.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ClusterPaddingP">
            <summary>
            Padding outside the cluster in the perpendicular direction.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.IsRootCluster">
            <summary>
            The Root Cluster is a special case, functioning as the "infinite" root cluster of a hierarchy
            with no border nodes.  If a size is desired then create a single cluster in the root.  Leaving
            the root cluster "infinite" means we don't have to generate the constraints for nodes and clusters
            in the root, which may be numerous.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.ToString">
            <summary>
            Generate a string representation of the Cluster.
            </summary>
            <returns>A string representation of the Cluster.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.SqueezeNonFixedBorderPositions">
            <summary>
            If a border is not fixed swap its position with the opposite border to ensure
            cluster is tight to its contents.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.Event.ToString">
            <summary>
            Generate a string representation of the Event.
            </summary>
            <returns>A string representation of the Event.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.Event.CompareTo(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster.Event)">
            <summary>
            Compare the current event's position to that of rhs in ascending left-to-right order,
            with Close events for the same position coming before Open events (so we don't generate
            unnecessary constraints for adjacent nodes).
            </summary>
            <param name="other">The right-hand side of the comparison</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration">
            <summary>
            Global configuration constants for the OverlapRemoval namespace.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.ClusterDefaultFreeWeight">
            <summary>
            Default weight for a freely movable cluster border; overridable per BorderInfo instance.
            Should be very small compared to default node weight (1) so that it has no visible effect on layout.
            Too large and it will cause clusters to be squashed by their bounding variables (since OverlapRemovalCluster
            swaps the positions of Left/Right, Top/Bottom nodes to ensure that cluster bounds tightly fit their contents after a solve).
            Too small and you will see cluster boundaries "sticking" to nodes outside the cluster (because such constraints will not be
            split when they can be because the lagrangian multipliers will be so small as to be ignored before solver termination).
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.ClusterDefaultFixedWeight">
            <summary>
            Default weight for an unfixed (freely movable) cluster border; overridable per BorderInfo instance.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.ClusterDefaultBorderWidth">
            <summary>
            Default width of cluster borders; overridable per BorderInfo instance via BorderInfo.InnerMargin.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.OverlapRemovalGlobalConfiguration.EventComparisonEpsilon">
            <summary>
            For comparing event positions, the rounding epsilon.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters">
            <summary>
            Per-instance parameters for OverlapRemoval.ConstraintGenerator.Generate()/Solve().
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.AllowDeferToVertical">
            <summary>
            If true and the current instance's IsHorizontal property is true, then by default
            constraints will not be generated on the horizontal pass if a vertical constraint
            would result in less movement.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.ConsiderProportionalOverlap">
            <summary>
            The calculation to choose in deciding which way to resolve overlap (horizontally or vertically)
            between two nodes u and v.
            If this is false the calculation is simply HOverlap > VOverlap, otherwise we use:
            HOverlap / (u.Width + v.Width) > VOverlap / (u.Height + v.Height)
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.SolverParameters">
            <summary>
            Parameters to the Solver, used in Generate as well as passed through to the Solver.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.#ctor(Microsoft.Msagl.Core.ProjectionSolver.Parameters)">
            <summary>
            Constructor taking solver parameters.
            </summary>
            <param name="solverParameters"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.#ctor(System.Boolean,Microsoft.Msagl.Core.ProjectionSolver.Parameters)">
            <summary>
            Constructor taking OverlapRemoval parameter and solver parameters.
            </summary>
            <param name="allowDeferToVertical"></param>
            <param name="solverParameters"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters.Clone">
            <summary>
            Deep-copy the SolverParameters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.ConstraintGenerator">
            <summary>
            ConstraintGenerator is the driving class for overlap removal.  The caller
            adds variables (so it is similar to ProjectionSolver in that way, and in
            fact the variables added here are passed to the ProjectionSolver to solve
            the generated constraints).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.ClusterHierarchies">
            <summary>
            Read-only enumeration of the ClusterHierarchies; new cluster hierarchies are created
            by calling AddCluster 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.DefaultClusterHierarchy">
            <summary>
            The initial, default ClusterHierarchy; a "flat" graph (with no user-defined clusters)
            lives entirely in this cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.Padding">
            <summary>
            Padding in the direction of the primary axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.PaddingP">
            <summary>
            Padding in the secondary (Perpendicular) axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.ClusterPadding">
            <summary>
            Padding outside clusters in the parallel direction.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.ClusterPaddingP">
            <summary>
            Padding outside clusters in the perpendicular direction.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.DefaultPadding">
            <summary>
            Default padding value that is used (in both axes) if no padding is specified when
            calling the ConstraintGenerator constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.IsHorizontal">
            <summary>
            As passed to ctor; if this is true, we are doing horizontal (x) constraint generation,
            and must therefore consider whether a smaller vertical movement would remove the overlap.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.#ctor(System.Boolean)">
            <summary>
            This form of the constructor uses default values for the padding parameters.
            <param name="isHorizontal">Whether to generate horizontal or vertical constraints</param>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.#ctor(System.Boolean,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            This form of the constructor uses specifies the padding parameters.
            <param name="isHorizontal">Whether to generate horizontal or vertical constraints</param>
            <param name="padding">Padding outside nodes in the parallel direction</param>
            <param name="paddingP">Padding outside nodes in the perpendicular direction</param>
            <param name="clusterPadding">Padding outside clusters in the parallel direction</param>
            <param name="clusterPaddingP">Padding outside clusters in the perpendicular direction</param>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.#ctor(System.Boolean,System.Double,System.Double)">
            <summary>
            Alternate form of the constructor to allow overriding the default padding.
            </summary>
            <param name="isHorizontal">Whether to generate horizontal or vertical constraints</param>
            <param name="padding">Minimal space between node or cluster rectangles in the primary axis.</param>
            <param name="paddingP">Minimal space between node or cluster rectangles in the secondary (Perpendicular) axis;
                                    used only when isHorizontal is true, to optimize the direction of movement.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.AddNode(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster,System.Object,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Add a new variable to the ConstraintGenerator.
            </summary>
            <param name="initialCluster">The cluster this node is to be a member of.  It may not be null; pass
                                DefaultClusterHierarchy to create a node at the lowest level.  Subsequently a node 
                                may be added to additional clusters, but only to one cluster per hierarchy.</param>
            <param name="userData">An object that is passed through.</param>
            <param name="position">Position of the node in the primary axis; if isHorizontal, it contains horizontal
                                position and size, else it contains vertical position and size.</param>
            <param name="size">Size of the node in the primary axis.</param>
            <param name="positionP">Position of the node in the secondary (Perpendicular) axis.</param>
            <param name="sizeP">Size of the node in the secondary (Perpendicular) axis.</param>
            <param name="weight">Weight of the node (indicates how freely it should move).</param>
            <returns>The created node.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.AddCluster(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster,System.Object,Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo)">
            <summary>
            Creates a new cluster with no minimum size within the specified parent cluster.  Clusters allow creating a subset of
            nodes that must be within a distinct rectangle.
            </summary>
            <param name="parentCluster">The cluster this cluster is to be a member of; if null, this is the root of a
                                        new hierarchy, otherwise must be non-NULL (perhaps DefaultClusterHierarchy).</param>
            <param name="userData">An object that is passed through.</param>
            <param name="openBorderInfo">Information about the Left (if isHorizontal, else Top) border.</param>
            <param name="closeBorderInfo">Information about the Right (if isHorizontal, else Bottom) border.</param>
            <param name="openBorderInfoP">Same as OpenBorder, but in the secondary (Perpendicular) axis.</param>
            <param name="closeBorderInfoP">Same as CloseBorder, but in the secondary (Perpendicular) axis.</param>
            <returns>The new Cluster.</returns>
            
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.AddCluster(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster,System.Object,System.Double,System.Double,Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo,Microsoft.Msagl.Core.Geometry.BorderInfo)">
            <summary>
            Creates a new cluster with a minimum size within the specified parent cluster.  Clusters allow creating a subset of
            nodes that must be within a distinct rectangle.
            </summary>
            <param name="parentCluster">The cluster this cluster is to be a member of; if null, this is the root of a
                                        new hierarchy, otherwise must be non-NULL (perhaps DefaultClusterHierarchy).</param>
            <param name="userData">An object that is passed through.</param>
            <param name="minimumSize">Minimum cluster size along the primary axis.</param>
            <param name="minimumSizeP">Minimum cluster size along the perpendicular axis.</param>
            <param name="openBorderInfo">Information about the Left (if isHorizontal, else Top) border.</param>
            <param name="closeBorderInfo">Information about the Right (if isHorizontal, else Bottom) border.</param>
            <param name="openBorderInfoP">Same as OpenBorder, but in the secondary (Perpendicular) axis.</param>
            <param name="closeBorderInfoP">Same as CloseBorder, but in the secondary (Perpendicular) axis.</param>
            <returns>The new Cluster.</returns>
            
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.AddCluster(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster,System.Object)">
            <summary>
            Add a Cluster with default border information and no minimum sizes.
            </summary>
            <param name="parentCluster">The cluster this cluster is to be a member of; if null, this is the root of a
                                        new hierarchy, otherwise must be non-NULL (perhaps DefaultClusterHierarchy).</param>
            <param name="userData">An object that is passed through.</param>
            <returns>The new Cluster.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.AddCluster(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster,System.Object,System.Double,System.Double)">
            <summary>
            Add a Cluster with default border information and specified minimum sizes.
            </summary>
            <param name="parentCluster">The cluster this cluster is to be a member of; if null, this is the root of a
                                        new hierarchy, otherwise must be non-NULL (perhaps DefaultClusterHierarchy).</param>
            <param name="userData">An object that is passed through.</param>
            <param name="minimumSize">Minimum cluster size along the primary axis.</param>
            <param name="minimumSizeP">Minimum cluster size along the perpendicular axis.</param>
            <returns>The new Cluster.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.AddNodeToCluster(Microsoft.Msagl.Core.Geometry.OverlapRemovalCluster,Microsoft.Msagl.Core.Geometry.OverlapRemovalNode)">
            <summary>
            Add a node to a cluster in another hierarchy (a node can be in only one cluster per hierarchy).
            </summary>
            <param name="cluster"></param>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.Generate(Microsoft.Msagl.Core.ProjectionSolver.Solver,Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters)">
            <summary>
            Generate the necessary constraints to ensure there is no overlap (unless we're doing
            a horizontal pass and deferring some movement, which would be smaller, to the vertical pass).
            </summary>
            <param name="solver">The solver to generate into.</param>
            <param name="parameters">Parameters to OverlapRemoval and ProjectionSolver.Solver.Solve().</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.ConstraintGenerator.Solve(Microsoft.Msagl.Core.ProjectionSolver.Solver,Microsoft.Msagl.Core.Geometry.OverlapRemovalParameters,System.Boolean)">
            <summary>
            Generates and solves the constraints.
            </summary>
            <param name="solver">The solver to generate into and solve.  May be null, in which case one
                                is created by the method.</param>
            <param name="parameters">Parameters to OverlapRemoval and ProjectionSolver.Solver.Solve().</param>
            <param name="doGenerate">Generate constraints before solving; if false, solver is assumed to
                                have already been populated by this.Generate().</param>
            <returns>The set of OverlapRemoval.Constraints that were unsatisfiable, or NULL.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode">
            <summary>
            A node essentially wraps the coordinates of a Variable for the Open and Close Events for
            that Variable.  It contains the list of left and right nodes which are immediate neighbours,
            where immediate is defined as overlapping or some subset of the closest non-overlapping
            Variables (currently this subset is the first one encountered on any event, since it is
            transitive; if there is a second non-overlapping node, then the first non-overlapping
            node will have a constraint on it).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.UserData">
            <summary>
            Passed through as a convenience to the caller; it is not used by OverlapRemoval directly
            (except in VERIFY/VERBOSE where it uses ToString()).  When Solve() is complete, the caller
            should copy the Node.Position property into whatever property the class specialization for this has.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.UserDataString">
            <summary>
            The string representing the user data object, or a null indicator string.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.Variable">
            <summary>
            The Variable representing this Node (or Cluster border) in the ProjectionSolver passed to
            Generate().  Once Solve() is called, this is cleared out.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.Position">
            <summary>
            The coordinate of the Node along the primary axis.  Updated by ConstraintGenerator.Solve().
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.PositionP">
            <summary>
            The coordinate of the Node along the secondary (Perpendicular) axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.Size">
            <summary>
            The size of the Node along the primary axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.SizeP">
            <summary>
            The size of the Node along the secondary (Perpendicular) axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.Open">
            <summary>
            The opening border of the Node along the primary axis; Left if horizontal,
            Top if Vertical.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.Close">
            <summary>
            The closing border of the Node along the primary axis; Right if horizontal,
            Bottom if Vertical.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.OpenP">
            <summary>
            The opening border of the Node along the secondary (Perpendicular) axis; Top if horizontal,
            Bottom if Vertical.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.CloseP">
            <summary>
            The closing border of the Node along the secondary (Perpendicular) axis; Bottom if horizontal,
            Right if Vertical.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.Weight">
            <summary>
            The weight of the node along the primary axis.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.CreateVariable(Microsoft.Msagl.Core.ProjectionSolver.Solver)">
            <summary>
            Create the backing Variable for this Node in the solver.
            </summary>
            <param name="solver"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.ToString">
            <summary>
            Generate a string representation of the Node.
            </summary>
            <returns>A string representation of the Node.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.CompareTo(Microsoft.Msagl.Core.Geometry.OverlapRemovalNode)">
            <summary>
            Compare the Nodes by ActualPos in ascending left-to-right order (this == lhs, other == rhs).
            </summary>
            <param name="other">The object being compared to.</param>
            <returns>-1 if 'this' is "less"; +1 if 'this' is "greater"; 0 if 'this' and rhs are equal.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.OverlapRemovalNode.CompareTo(System.Object)">
            <summary>
            Compare the Nodes by ActualPos in ascending left-to-right order (this == lhs, other == rhs).
            </summary>
            <param name="obj">The object being compared to.</param>
            <returns>-1 if 'this' is "less"; +1 if 'this' is "greater"; 0 if 'this' and rhs are equal.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.NodeComparer.Compare(Microsoft.Msagl.Core.Geometry.OverlapRemovalNode,Microsoft.Msagl.Core.Geometry.OverlapRemovalNode)">
            <summary>
            Compare the points by point ActualPos in ascending left-to-right order.
            </summary>
            <param name="lhs">Left-hand side of the comparison.</param>
            <param name="rhs">Right-hand side of the comparison.</param>
            <returns>-1 if lhs is less than rhs; +1 if lhs is greater than rhs; else 0.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.HitTestBehavior">
            <summary>
            continue or stop the hit tree traversal
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.HitTestBehavior.Continue">
            <summary>
            continue the hit tree traversal
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.HitTestBehavior.Stop">
            <summary>
            stop the hit tree traversal
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.RectangleNode`1">
            <summary>
            Represents a node containing a box and some user data.
            Is used in curve intersections routines.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleNode`1.Count">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.#ctor">
            <summary>
            creates an empty node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.#ctor(`0,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="rect"></param>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.RectangleNode`1.rectangle">
            <summary>
            This field provides direct internal access to the value type Rectangle, which RTree and other callers
            modify directly with .Add(); the auto-property returns a temporary value-by-copy that is immediately discarded.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleNode`1.Rectangle">
            <summary>
            gets or sets the rectangle of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleNode`1.IsLeaf">
            <summary>
            false if it is an internal node and true if it is a leaf
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleNode`1.Left">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleNode`1.Right">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleNode`1.UserData">
            <summary>
            The actual data if a leaf node, else null or a value-type default.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.RectangleNode`1.Parent">
            <summary>
            Parent of this node.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.FirstHitNode(Microsoft.Msagl.Core.Geometry.Point,System.Func{Microsoft.Msagl.Core.Geometry.Point,`0,Microsoft.Msagl.Core.Geometry.HitTestBehavior})">
            <summary>
            brings the first leaf which rectangle was hit and the delegate is happy with the object
            </summary>
            <param name="point"></param>
            <param name="hitTestForPointDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.FirstIntersectedNode(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            brings the first leaf which rectangle was intersected
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.FirstHitNode(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            brings the first leaf which rectangle was hit and the delegate is happy with the object
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.AllHitItems(Microsoft.Msagl.Core.Geometry.Rectangle,System.Func{`0,System.Boolean})">
            <summary>
            returns all leaf nodes for which the rectangle was hit and the delegate is happy with the object
            </summary>
            <param name="rectanglePar"></param>
            <param name="hitTestAccept"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.AllHitItems(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns all items for which the rectangle contains the point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.VisitTree(System.Func{`0,Microsoft.Msagl.Core.Geometry.HitTestBehavior},Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Returns all leaves whose rectangles intersect hitRectangle (or all leaves before hitTest returns false).
            </summary>
            <param name="hitTest"></param>
            <param name="hitRectangle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.GetNodeItemsIntersectingRectangle(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            yields all leaves which rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
            </summary>
            <param name="rectanglePar"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.GetLeafRectangleNodesIntersectingRectangle(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            yields all leaves whose rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
            </summary>
            <param name="rectanglePar"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.GetAllLeaves">
            <summary>
            Walk the tree and return the data from all leaves
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.CreateRectangleNodeOnEnumeration(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.RectangleNode{`0}})">
            <summary>
            calculates a tree based on the given nodes
            </summary>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.CreateRectangleNodeOnData(System.Collections.Generic.IEnumerable{`0},System.Func{`0,Microsoft.Msagl.Core.Geometry.Rectangle})">
            <summary>
            calculates a tree based on the given nodes
            </summary>
            <param name="dataEnumeration"></param>
            <param name="rectangleDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.CreateRectangleNodeOnListOfNodes(System.Collections.Generic.IList{Microsoft.Msagl.Core.Geometry.RectangleNode{`0}})">
            <summary>
            
            </summary>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.RectangleNode`1.TraverseHierarchy(Microsoft.Msagl.Core.Geometry.RectangleNode{`0},System.Action{Microsoft.Msagl.Core.Geometry.RectangleNode{`0}})">
            <summary>
            Walk the tree from node down and apply visitor to all nodes
            </summary>
            <param name="node"></param>
            <param name="visitor"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Directions">
            <summary>
            enumerates the compass directions
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Directions.None">
            <summary>
            no direction defined
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Directions.North">
            <summary>
            North
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Directions.East">
            <summary>
            East
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Directions.South">
            <summary>
            South
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Geometry.Directions.West">
            <summary>
            West
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.op_Equality(Microsoft.Msagl.Core.Geometry.CompassVector,Microsoft.Msagl.Core.Geometry.CompassVector)">
            <summary>
            Override op==
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.GetHashCode">
            <summary>
            Return the hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.op_Inequality(Microsoft.Msagl.Core.Geometry.CompassVector,Microsoft.Msagl.Core.Geometry.CompassVector)">
            <summary>
            Override op!=
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.Equals(Microsoft.Msagl.Core.Geometry.CompassVector)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.ToString">
            <summary>
            Returns a string representing the direction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.ToPoint">
            <summary>
            Translates the CompassVector's direction into a new Point.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.ToPoint(Microsoft.Msagl.Core.Geometry.Directions)">
            <summary>
            Translates a direction into a Point.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.op_UnaryNegation(Microsoft.Msagl.Core.Geometry.CompassVector)">
            <summary>
             the negation operator
            </summary>
            <param name="directionVector"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.CompassVector.Negate">
            <summary>
            the negation operator
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Geometry.Rectangle">
            <summary>
            Just a rectangle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.ToString">
            <summary>
            shows min and max coordinates of corners
            </summary>
            <returns>string leftbottom, righttop</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Intersects(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            returns true if r intersect this rectangle
            </summary>
            <param name="rectangle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Intersection(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            intersection (possibly empty) of rectangles
            </summary>
            <param name="rectangle"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Center">
            <summary>
            the center of the bounding box
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Equals(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            
            </summary>
            <param name="rec"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.CreateAnEmptyBox">
            <summary>
            creates an empty rectangle
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Left">
            <summary>
            the left of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Right">
            <summary>
            the right of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Top">
            <summary>
            the top of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Bottom">
            <summary>
            the bottom of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.LeftBottom">
            <summary>
            the left bottom corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.RightTop">
            <summary>
            the right top corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.LeftTop">
            <summary>
            the left top corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.RightBottom">
            <summary>
            the right bottom corner
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            create a box of two points
            </summary>
            <param name="point0"></param>
            <param name="point1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            create rectangle from a point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="left">left</param>
            <param name="bottom">bottom</param>
            <param name="sizeF">size</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            create a box on points (x0,y0), (x1,y1)
            </summary>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            Create rectangle that is the bounding box of the given points
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Rectangle})">
            <summary>
            Create rectangle that is the bounding box of the given Rectangles
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Width">
            <summary>
            the width of the rectangle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.IsEmpty">
            <summary>
            returns true if the rectangle has negative width
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.SetToEmpty">
            <summary>
            makes the rectangle empty
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Height">
            <summary>
            Height of the rectangle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            rectangle containing both a and side1
            </summary>
            <param name="rectangle0"></param>
            <param name="rectangle1"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Contains(Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
            contains with padding
            </summary>
            <param name="point"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Area">
            <summary>
            Rectangle area
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Add(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            adding a point to the rectangle
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.AddWithCheck(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            extend the box to keep the point.
            Assume here that the box is initialized correctly
            </summary>
            <param name="point"></param>
            <returns>true if the box has been extended</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Add(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            adding rectangle
            </summary>
            <param name="rectangle"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.op_Equality(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            override ==
            </summary>
            <param name="rectangle0"></param>
            <param name="rectangle1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.op_Inequality(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            overrides !=
            </summary>
            <param name="rectangle0"></param>
            <param name="rectangle1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Translate(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Return copy of specified rectangle translated by the specified delta
            </summary>
            <param name="rectangle">source to copy and translate</param>
            <param name="delta">translation vector</param>
            <returns>copy of specified rectangle translated by the specified delta</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Contains(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns true if the rectangle contains the point
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Contains(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            returns true if this rectangle completely contains the specified rectangle
            </summary>
            <param name="rect"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Diagonal">
            <summary>
            return the length of the diagonal 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.PadWidth(System.Double)">
            <summary>
            pad the rectangle horizontally by the given padding
            </summary>
            <param name="padding"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.PadHeight(System.Double)">
            <summary>
            pad the rectangle vertically by the given padding
            </summary>
            <param name="padding"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Pad(System.Double)">
            <summary>
            pad the rectangle by the given padding
            </summary>
            <param name="padding"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Pad(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Pad the rectangle by the given amount on each side
            </summary>
            <param name="left"></param>
            <param name="bottom"></param>
            <param name="right"></param>
            <param name="top"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Intersect(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Returns the intersection of two rectangles.
            </summary>
            <param name="rect1"></param>
            <param name="rect2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Perimeter">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.ScaleAroundCenter(System.Double)">
            <summary>
            </summary>
            <param name="scale"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Geometry.Rectangle.Size">
            <summary>
            gets or sets the Size
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.#ctor(Microsoft.Msagl.Core.DataStructures.Size,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            constructor with Size and center
            </summary>
            <param name="size"></param>
            <param name="center"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Geometry.Rectangle.Add(Microsoft.Msagl.Core.DataStructures.Size,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            adding a point with a Size
            </summary>
            <param name="size"></param>
            <param name="point"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.GraphAlgorithms.MinimumSpanningTreeByPrim">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.MinimumSpanningTreeByPrim.Test">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.MinimumSpanningTreeByPrim.#ctor(Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Core.GraphAlgorithms.IEdge},System.Func{Microsoft.Msagl.Core.GraphAlgorithms.IEdge,System.Double},System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="graph"></param>
            <param name="weight"></param>
            <param name="root">the node we start building the tree</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.MinimumSpanningTreeByPrim.GetTreeEdges">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval`1">
            <summary>
            Calculates a set of edges to reverse, so called "feedback set", for obtaining a DAG
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval`1.GetFeedbackSetWithConstraints(Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{`0},Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Core.GraphAlgorithms.IntPair})">
            <summary>
            Returning a list of edges reversing which makes the graph into a DAG
            </summary>
            <param name="graph"></param>
            <param name="constraints"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.CycleRemoval`1.GetFeedbackSet(Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{`0})">
            <summary>
            We build a spanning tree by following the DFS, the tree induces an order on vertices 
            measured by the distance from the tree root. The feedback set will consist of edges 
            directed against this order.
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.CycleRemovalWithConstraints`1.GetFeedbackEdgeSet(Microsoft.Msagl.Core.GraphAlgorithms.GraphForCycleRemoval)">
            <summary>
            following H.A.D Nascimento and P. Eades "User Hints for Directed Graph Drawing"
            </summary>
            <param name="graphForCycleRemoval">graphForCycleRemoval is connected</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.Core.GraphAlgorithms.GraphForCycleRemoval.deltaDegreeBucketsForSourcesInConstrainedSubgraph">
            <summary>
            this dictionary contains only buckets with nodes which are sources in the graph of constrained edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.NodeInfo.DeltaDegree">
            <summary>
            it is the out degree without the in degree
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.NodeInfo.AllNeighbors">
            <summary>
            including constrained neighbors
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.GraphAlgorithms.IEdge">
            <summary>
            an edge interface
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.IEdge.Source">
            <summary>
            source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.IEdge.Target">
            <summary>
            target
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.GraphAlgorithms.TopologicalSort">
            <summary>
            Implements the topological sort
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.TopologicalSort.GetOrder(System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32}})">
            <summary>
            Do a topological sort of a list of int edge tuples
            </summary>
            <param name="numberOfVertices">number of vertices</param>
            <param name="edges">edge pairs</param>
            <returns>ordered node indexes</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.TopologicalSort.GetOrder``1(Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{``0})">
            <summary>
            The function returns an array arr such that
            arr is a permutation of the graph vertices,
            and for any edge e in graph if e.Source=arr[i]
            e.Target=arr[j], then i is less than j
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.TopologicalSort.GetOrderOnEdges``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            The function returns an array arr such that
            arr is a permutation of edge  vertices,
            and for any edge e from the list, if e.Source=arr[i]
            e.Target=arr[j], then i is less than j
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`2.#ctor">
            <summary>
            a default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="edges"></param>
            <param name="numberOfVerts"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`2.Nodes">
            <summary>
            array of nodes
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1">
            <summary>
            The base class for graphs: layering and ordering work on an instance of this class.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.#ctor">
            <summary>
            a default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="edges"></param>
            <param name="numberOfVerts"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.NodeCount">
            <summary>
            returning number of vertices of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.Edges">
            <summary>
            returning all edges of the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.RemoveEdge(`0)">
            <summary>
            the method is not efficient, takes linear time
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.VertexCount(System.Collections.IEnumerable)">
            <summary>
            actually finds maximum of sources and targets+1
            </summary>
            <param name="edges"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.OutEdges(System.Int32)">
            <summary>
            Edges exiting a vertex
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.InEdges(System.Int32)">
            <summary>
            Edges entering a vertex
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.SetEdges(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            sets edges of the graph
            </summary>
            <param name="valEdges"></param>
            <param name="nov">number of vertices</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.AddEdge(`0)">
            <summary>
            this function is extremely non-efficient and is called only when adding virtual edges
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.AddEdgeToOutEdges(`0,System.Int32)">
            <summary>
            this function is extremely non-efficient and is called only when adding virtual edges
            </summary>
            <param name="e"></param>
            <param name="source"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.AddEdgeToInEdges(`0,System.Int32)">
            <summary>
            this function is extremely non-efficient and is called only when adding virtual edges
            </summary>
            <param name="e"></param>
            <param name="target"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph`1.NodesOfConnectedGraph">
            <summary>
            We assume that the graph is connected here
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.GraphAlgorithms.IntPair">
            <summary>
            Represents a couple of integers.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.First">
            <summary>
            the first element of the pair
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.Second">
            <summary>
            the second element of the pair
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.op_LessThan(Microsoft.Msagl.Core.GraphAlgorithms.IntPair,Microsoft.Msagl.Core.GraphAlgorithms.IntPair)">
            <summary>
             the less operator
            </summary>
            <param name="pair0"></param>
            <param name="pair1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.op_GreaterThan(Microsoft.Msagl.Core.GraphAlgorithms.IntPair,Microsoft.Msagl.Core.GraphAlgorithms.IntPair)">
            <summary>
            the greater operator
            </summary>
            <param name="pair0"></param>
            <param name="pair1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.Compare(Microsoft.Msagl.Core.GraphAlgorithms.IntPair,Microsoft.Msagl.Core.GraphAlgorithms.IntPair)">
            <summary>
            Compares two pairs
            </summary>
            <param name="pair0"></param>
            <param name="pair1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.Equals(System.Object)">
            <summary>
            override the equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.#ctor(System.Int32,System.Int32)">
            <summary>
            the constructor
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.GraphAlgorithms.IntPair.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Arrowhead">
            <summary>
            keeps the arrowhead info
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Arrowhead.DefaultArrowheadLength">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Arrowhead.Length">
            <summary>
             The overall length of the arrow head
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Arrowhead.Width">
            <summary>
             The width of the arrow head at the base
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Arrowhead.TipPosition">
            <summary>
             Where the tip of the arrow head is
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Arrowhead.Offset">
            <summary>
             A relative offset that moves the tip position 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Arrowhead.Clone">
            <summary>
            Clone the arrowhead information
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Arrowheads">
            <summary>
            Arrowhead calculations
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Arrowheads.CalculateArrowheads(Microsoft.Msagl.Core.Layout.EdgeGeometry)">
            <summary>
            calculates new curve ends that are the arrowhead starts
            </summary>
            <param name="edgeGeometry">The edgeGeometry.Curve is trimmed already by the node boundaries</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Arrowheads.FindTrimEndForArrowheadAtTarget(Microsoft.Msagl.Core.Layout.EdgeGeometry,System.Double@)">
            <summary>
            we need to pass arrowhead length here since the original length mibh
            </summary>
            <param name="edgeGeometry"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads(Microsoft.Msagl.Core.Layout.Edge,Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Boolean,System.Boolean)">
            <summary>
            trim the edge curve with the node boundaries
            </summary>
            <param name="edge"></param>
            <param name="spline"></param>
            <param name="narrowestInterval"></param>
            <param name="keepOriginalSpline">to keep the original spline</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Arrowheads.TrimSplineAndCalculateArrowheads(Microsoft.Msagl.Core.Layout.EdgeGeometry,Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Boolean,System.Boolean)">
            <summary>
            trim the edge curve with the node boundaries
            </summary>
            <param name="edgeGeometry"></param>
            <param name="targetBoundary"></param>
            <param name="spline"></param>
            <param name="narrowestInterval"></param>
            <param name="sourceBoundary"></param>
            <param name="keepOriginalSpline"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Arrowheads.CreateBigEnoughSpline(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            Creates a spline between two nodes big enough to draw arrowheads
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Arrowheads.CreateEdgeCurveWithNoTrimming(Microsoft.Msagl.Core.Layout.Edge,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            this code should never work!
            </summary>
            <param name="edge"></param>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.CurvePort">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.CurvePort.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double)">
            <summary>
            constructor
            </summary>
            <param name="curve"></param>
            <param name="parameter"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.CurvePort.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.CurvePort.Parameter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.CurvePort.Curve">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.CurvePort.Location">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.EdgeCollection">
            <summary>
            A collection of edges.  Adding or removing edges from the collection automatically updates the related nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.EdgeCollection.graph">
            <summary>
            the graph of the collection
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Creates a collection for edges.
            </summary>
            <param name="graph">The graph that each edge will be parented under.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.Add(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            Adds the edge to the collection
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.Clear">
            <summary>
            Clears all of the edges.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.Contains(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            Returns true if the edge is found in the collection.
            </summary>
            <returns>True if the edge is found in the collection.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.CopyTo(Microsoft.Msagl.Core.Layout.Edge[],System.Int32)">
            <summary>
            Copies the contents of the collection to the given array, starting at the given index.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeCollection.Count">
            <summary>
            The number of edges in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeCollection.IsReadOnly">
            <summary>
            Returns false. Edge collections are never readonly.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.Remove(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            Removes the edge from the collection.
            </summary>
            <returns>True if the edge was removed. False if the edge was not removed or the edge was not found.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.GetEnumerator">
            <summary>
            Gets an enumerator for the collection.
            </summary>
            <returns>The enumerator for the colleciton.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for the collection.
            </summary>
            <returns>The enumerator for the collection.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.labels">
            <summary>
                The list of labels to be placed
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.MinGranularity">
            <summary>
                The default and minimum granularity for breaking up a curve into many points.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.MaxGranularity">
            <summary>
                The maximum granulairty for breaking up a curve into many points.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.LowerEdgeBound">
            <summary>
                The number of edges at which to start increasing the granularity.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.UpperEdgeBound">
            <summary>
                The number of edges at which to stop increasing the granularity.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.CollisionGranularity">
            <summary>
                The granularity with which to break up a curve into sub points.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ScaleCollisionGranularity">
            <summary>
                True if the edge collision granularity should be degraded as the number of edges increases.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ParallelProcessingEnabled">
            <summary>
                True if label placement should be done using multiple threads.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
                Constructs an edge label placer that places all labels in the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Collections.Generic.ICollection{Microsoft.Msagl.Core.Layout.Label})">
            <summary>
                Constructs an edge label placer that places the given labels in the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge})">
            <summary>
                Constructs a edge label placer that will only avoid overlaps with the given nodes and edges.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.AddLabelObstacle(Microsoft.Msagl.Core.Layout.IObstacle)">
            <summary>
                Adds the label to the label obstacle map.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.RunInternal">
            <summary>
                Places the given labels.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PlaceLabel(Microsoft.Msagl.Core.Layout.Label)">
            <summary>
                Places the given label in an available location.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PlaceLabelAtFirstPosition(Microsoft.Msagl.Core.Layout.Label)">
            <summary>
                Places the label at the first position requested.  Ignores all overlaps.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PlaceEdgeLabelHorizontally(Microsoft.Msagl.Core.Layout.Label)">
            <summary>
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetLabelBounds(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
                Gets the label placement bounds for the given location, side, and label size.
            </summary>
            <param name="point">The point along a curve that the label should be placed near.</param>
            <param name="derivative">The derivative of the curve at the point position.</param>
            <param name="widthHeight">The width and height of the label.</param>
            <param name="side">The side (1 or -1) of the line to place the label on.</param>
            <returns>The label's desired position.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.SetLabelBounds(Microsoft.Msagl.Core.Layout.Label,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
                Sets the label's position to be the given bounds.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.GetPossibleSides(Microsoft.Msagl.Core.Layout.Label.PlacementSide,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
                Gets the possible sides for the given label and the given derivative point.
            </summary>
            <returns>An enumeration of the possible sides (-1 or 1).</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ExpandingSearch(System.Int32,System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="start"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.PlaceEdgeLabelOnCurve(Microsoft.Msagl.Core.Layout.Label)">
            <summary>
                places a label
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.Conflict(Microsoft.Msagl.Core.Geometry.Point,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
                Determines if the query point intersects with any of the obstacles.
            </summary>
            <returns>True if the query point itnersects with any of the obstacles.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ConflictIndex(Microsoft.Msagl.Core.Geometry.Point,System.Double,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
                Determines the index of the first obstacle map that the point intersects.
            </summary>
            <returns>The index of the first obstacle map that the point intersects. int.MaxValue if there is no intersection.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeLabelPlacement.ConflictIndex(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Layout.Label)">
            <summary>
                Determines the index of the first obstacle map that the rectangle intersects.
                Clusters that are parents/grandparents of the label's source/target nodes are not considered intersection.
            </summary>
            <returns>The index of the first obstacle map that the rectangle intersects. int.MaxValue if there is no intersection.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort">
            <summary>
            This port is for an edge connecting a node inside of the curve going out of the curve and creating a hook to 
            connect to the curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Double)">
            <summary>
            </summary>
            <param name="boundaryCurve"></param>
            <param name="hookSize"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve})">
            <summary>
            </summary>
            <param name="boundaryCurve"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.Location">
            <summary>
            returns a point on the boundary curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.Curve">
            <summary>
            Gets the boundary curve of the port.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.AdjustmentAngle">
             <summary>
             We are trying to correct the last segment of the polyline by make it perpendicular to the Port.Curve.
            For this purpose we trim the curve by the cone of the angle 2*adjustment angle and project the point before the last of the polyline to this curve.
             </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.HookUpAnywhereFromInsidePort.HookSize">
            <summary>
            the size of the self-loop
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings">
            <summary>
            Settings controlling how ideal edge lengths will be calculated for layouts that consider it.
            </summary>
            <remarks>
            This is a struct so we can do a shallow copy without having to do a MemberwiseClone.
            </remarks>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.DefaultLength">
            <summary>
            Basic desired length for edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ProportionalToSymmetricDifference">
            <summary>
            Gets or sets whether to set the ideal edge length based on the degree and number of shared
            neighbors of end nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ProportionalEdgeLengthAdjustment">
            <summary>
            Gets or sets the fraction that ideal edge length grows based on the degree of its endpoints.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ProportionalEdgeLengthOffset">
            <summary>
            Gets or sets the fraction that the ideal edge length is initially modified prior to the proportional adjustments.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.EdgeDirectionConstraints">
            <summary>
            If true then direction separation constraints will be applied to all edges on InitializeLayout
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings.ConstrainedEdgeSeparation">
            <summary>
            Controls the separation used in Edge Constraints
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.IsOpenChangeEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.IsOpenChangeEventArgs.PreviousValue">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.IsOpenChangeEventArgs.#ctor(System.Boolean)">
            <summary>
            constructor
            </summary>
            <param name="previousValue"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.LabelPlacementResult">
            <summary>
            The possible possible results of a label placement.
            OverlapsOtherLabels is the worst result, while OverlapsNothing is the best result.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsOtherLabels">
            <summary>
            Placement result meaning that another label was overlapped
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsNodes">
            <summary>
            Placement result meaning that the label overlaps a node, but not a label
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsEdges">
            <summary>
            Placement result meaning that the label overlaps an edge, but not a node or label.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LabelPlacementResult.OverlapsNothing">
            <summary>
            Placement result meaning that the label overlaps nothing.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.LgInfoBase">
            <summary>
            the base class for LgNodeInfo and LgEdgeInfo
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LgInfoBase.SlidingZoomLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LgInfoBase.ZoomLevel">
            <summary>
            if the zoom is at least ZoomLevel the node should be rendered
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LgInfoBase.Rank">
            <summary>
            the rank of the element
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.LgNodeInfo">
            <summary>
            facilitates large graph browsing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LgNodeInfo.GeometryNode">
            <summary>
            underlying geometry node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LgNodeInfo.Center">
            <summary>
            the center of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LgNodeInfo.BoundingBox">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LgNodeInfo.ToString">
            <summary>
            override the string method
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LgNodeInfo.BoundaryOnLayer">
            <summary>
            on each layer the node boundary is a different polyline, smaller on the layers with large zool levels
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers">
            <summary>
            static helper methods for layout algorithms
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.LinearInterpolation(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
            </summary>
            <param name="value">The input value.</param>
            <param name="lowerThreshold">If the input value is lower than the lowerThreshold, minResult is returned.</param>
            <param name="upperThreshold">If the input value is higher than the upperThreshold, maxResult is returned.</param>
            <param name="minResult">The minimum result.</param>
            <param name="maxResult">The maximum result.</param>
            <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.NegativeLinearInterpolation(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Negatively linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
            </summary>
            <param name="value">The input value.</param>
            <param name="lowerThreshold">If the input value is lower than the lowerThreshold, maxResult is returned.</param>
            <param name="upperThreshold">If the input value is higher than the upperThreshold, minResult is returned.</param>
            <param name="minResult">The minimum result.</param>
            <param name="maxResult">The maximum result.</param>
            <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.LinearInterpolation(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
            </summary>
            <param name="value">The input value.</param>
            <param name="lowerThreshold">If the input value is lower than the lowerThreshold, minResult is returned.</param>
            <param name="upperThreshold">If the input value is higher than the upperThreshold, maxResult is returned.</param>
            <param name="minResult">The minimum result.</param>
            <param name="maxResult">The maximum result.</param>
            <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.NegativeLinearInterpolation(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Negatively linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
            </summary>
            <param name="value">The input value.</param>
            <param name="lowerThreshold">If the input value is lower than the lowerThreshold, maxResult is returned.</param>
            <param name="upperThreshold">If the input value is higher than the upperThreshold, minResult is returned.</param>
            <param name="minResult">The minimum result.</param>
            <param name="maxResult">The maximum result.</param>
            <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.ComputeDesiredEdgeLengths(Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings,Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Compute ideal edge lengths for the given graph component based on the given settings
            </summary>
            <param name="settings">settings for calculating ideal edge length</param>
            <param name="component">a graph component</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LayoutAlgorithmHelpers.SetEdgeLengthsProportionalToSymmetricDifference(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double)">
            <summary>
            Set ideal edge lengths to be proportional to the symmetric difference between neighbour
            sets of the pair of nodes associated with the edge.
            </summary>
            <param name="graph"></param>
            <param name="lengthAdjustment">The fraction of the edge length to add for each symmetric difference unit. (Example: 0.05)</param>
            <param name="lengthInitialOffset">The initial fraction of the edge length to use before adding the symmetric difference adjustment. (Example: 0.8)</param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.LayoutChangeEventArgs">
            <summary>
            At the moment it is an empty class
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LayoutChangeEventArgs.DataBeforeChange">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LayoutChangeEventArgs.DataAfterChange">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.LgNodeInfoKind">
            <summary>
            three type of nodes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LgNodeInfoKind.OutOfView">
            <summary>
            out of view
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LgNodeInfoKind.FullyVisible">
            <summary>
            fully visible
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.LgNodeInfoKind.Satellite">
            <summary>
            becomes fully visible soon
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.NodeCollection">
            <summary>
            A collection of nodes.  Adding or removing nodes from the collection automatically updates the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Creates a collection for nodes.
            </summary>
            <param name="graph">The graph that each node will be parented under.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.Add(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Adds the node to the collection, but does not add the node edges to the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.Clear">
            <summary>
            Clears all of the nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.Contains(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Returns true if the node is found in the collection.
            </summary>
            <returns>True if the node is found in the collection.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.CopyTo(Microsoft.Msagl.Core.Layout.Node[],System.Int32)">
            <summary>
            Copies the contents of the collection to the given array, starting at the given index.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.NodeCollection.Count">
            <summary>
            The number of nodes in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.NodeCollection.IsReadOnly">
            <summary>
            Returns false. Node collections are never readonly.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.Remove(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Removes the node from the collection.
            </summary>
            <returns>True if the node was removed. False if the node was not removed or the node was not found.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.GetEnumerator">
            <summary>
            Gets an enumerator for the collection.
            </summary>
            <returns>The enumerator for the colleciton.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for the collection.
            </summary>
            <returns>The enumerator for the collection.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.IndexOf(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.Insert(System.Int32,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param><param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.NodeCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.NodeCollection.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <returns>
            The element at the specified index.
            </returns>
            <param name="index">The zero-based index of the element to get or set.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.PackingMethod">
            <summary>
            the packing method to be used by InitialLayoutByCluster
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.PackingMethod.Compact">
            <summary>
            biggest to smallest with nested wrapping
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.PackingMethod.Columns">
            <summary>
            Pack to desired ratio in columns
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.PortObstacle.Rectangle">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix">
            <summary>
            Matrix in compressed sparse row format (CSR) 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.values">
            <summary>
            Non-Zero matrix values from left-to-right, top-to-bottom
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.col_ind">
            <summary>
            Column index of the x-th value in matrix (left-to-right, top-to-bottom)
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.row_ptr">
            <summary>
            Row pointers, marking the start and end positions in values of the elements of a given row.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.Values">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.ColInd">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.RowPtr">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.NumRow">
            <summary>
            Number of rows of the matrix.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.NumCol">
            <summary>
            Number of columns of the matrix.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.#ctor(System.Double[],System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="valuesFlat">non zero values of the matrix, left-to-right and top-to-bottom</param>
            <param name="columnIndices">column indices of the the values</param>
            <param name="rowPointers">pointer to starting (and end) index of a row in values</param>
            <param name="numberColumns">number of columns of the matrix</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates and initializes data structures for the given size.
            </summary>
            <param name="numValues"></param>
            <param name="numRow"></param>
            <param name="numCol"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Multiplies the given vector with the sparse matrix (only if the vector length corresponds to the number of columns in the matrix).
            </summary>
            <param name="m">matrix</param>
            <param name="vec">vector</param>
            <returns>vector with same amount of entries as the matrix has rows</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.op_Multiply(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,System.Double[])">
            <summary>
             Multiplies the given vector with the sparse matrix (only if the vector length corresponds to the number of columns in the matrix).
            </summary>
            <param name="m"></param>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.DiagonalPreconditioner">
            <summary>
            Returns the inverted diagonal of this matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.GetFullMatrix">
            <summary>
            Returns the full blown up matrix. Attention: needs O(n^2) memory and time. Should only be used for debugging purposes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix.PrintMatrix">
            <summary>
            Prints the full matrix.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver">
            <summary>
            Solver for a linear system of equations of the form Ax=b.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolveConjugateGradient(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,System.Int32,System.Double)">
            <summary>
                Conjugate Gradient method for solving Sparse linear system of the form Ax=b with an iterative procedure. Matrix A should be positive semi-definite, otherwise several solutions could exist and convergence is not guaranteed.
                see article for algorithm description: An Introduction to the Conjugate Gradient Method
                Without the Agonizing Pain by Jonathan Richard Shewchuk
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <param name="x">initial guess for x</param>
            <param name="iMax"></param>
            <param name="epsilon"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolvePrecondConjugateGradient(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,System.Int32,System.Double)">
            <summary>
            Preconditioned Conjugate Gradient Method <see cref="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolveConjugateGradient(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,System.Int32,System.Double)"/>
            Preconditioner: Jacobi Preconditioner.
            This method should generally be preferred, due to its faster convergence.
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <param name="x"></param>
            <param name="iMax"></param>
            <param name="epsilon"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolveConjugateGradient(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,System.Double[],System.Double[],System.Int32,System.Double)">
            <summary>
            Conjugate Gradient Method which is guaranteed to converge in n steps, <see cref="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolveConjugateGradient(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,System.Int32,System.Double)"/>
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <param name="x"></param>
            <param name="iMax"></param>
            <param name="epsilon"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolvePrecondConjugateGradient(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,System.Double[],System.Double[],System.Int32,System.Double)">
            <summary>
                Preconditioned Conjugate Gradient method, where the preconditioner M is the diagonal of A (Jacobi Preconditioner), <seealso cref="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.SolvePrecondConjugateGradient(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.SparseMatrix,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,System.Int32,System.Double)"/>
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <param name="x"></param>
            <param name="iMax"></param>
            <param name="epsilon"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.TestConjugateGradientMethod">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.LinearSystemSolver.TestConjugateGradientMethod2">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector">
            <summary>
            Simple Vector class which allows to easily use operators.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.array">
            <summary>
            Value array
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.#ctor(System.Double[])">
            <summary>
            constructor
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.Sub(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Substracts vector b directly from the current vector (without creating a new vector).
            </summary>
            <param name="b">vector to be substracted</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Subtraction(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Substracts vector b and returns the result in a new vector.
            </summary>
            <param name="a">vector</param>
            <param name="b">vector to be substracted</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.Add(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Adds vector b without creating a new vector.
            </summary>
            <param name="b">vector</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Addition(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Adds vector b to vector a and returns the result in a new vector.
            </summary>
            <param name="a"></param>
            <param name="b">vector</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.Clone">
            <summary>
            Creates a copy of the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Multiplies two vectors of same length.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>vector product</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.CompProduct(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Multiplies two vectors component wise and return the result in a new vector.
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector.op_Multiply(System.Double,Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ConjugateGradient.Vector)">
            <summary>
            Multiplies the vector by a scalar and return the result in a new vector.
            </summary>
            <param name="scalar"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling">
            <summary>
            Methods with which the graph is initially scaled.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.None">
            <summary>
            no scaling 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.Inch72Pixel">
            <summary>
            Scaling such that the average edge length is 1 inch (72 pixels, due to historic reasons)
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling.AvgNodeSize">
            <summary>
            Scaling such that the average edge length is 4 times the average node size, where node size is the average of the width and height of the bounding box.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.IOverlapRemoval">
            <summary>
            Overlap Removal Interface. All Overlap Removal classes should implement this to unify usage of different methods.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.IOverlapRemoval.Settings(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings)">
            <summary>
            Settings to be used for the overlap removal. Not all settings have to be used.
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.IOverlapRemoval.RemoveOverlaps">
            <summary>
            Main function which removes the overlap for a given graph and finally sets the new node positions.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.IOverlapRemoval.GetLastRunIterations">
            <summary>
            Method giving the number of needed iterations for the last run. (Runtime statistic)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.MstOnDelaunayTriangulation">
            <summary>
            Computes the minimum spanning tree on a triangulation or on a set of edges given by a list of tuple.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.MstOnDelaunayTriangulation.GetMstOnTuple(System.Collections.Generic.List{System.Tuple{System.Int32,System.Int32,System.Double,System.Double,System.Double}},System.Int32)">
            <summary>
            Computes the minimum spanning tree on a set of edges
            </summary>
            <param name="proximityEdges">list of tuples, each representing an edge with: nodeId1, nodeId2, t(overlapFactor), ideal distance, edge weight.</param>
            <param name="sizeId"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.MstOnDelaunayTriangulation.GetMstOnCdt(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt,System.Func{Microsoft.Msagl.Routing.CdtEdge,System.Double})">
            <summary>
            Computes the minimum spanning tree on a DT with given weights.
            </summary>
            <param name="cdt"></param>
            <param name="weights"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.MstOnDelaunayTriangulation.Test">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval">
            <summary>
            Overlap Removal using Minimum Spanning Tree on the delaunay triangulation. The edge weight corresponds to the amount of overlap between two nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.#ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings,Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
            Settings to be used for the overlap removal, not all of them are used.
            </summary>
            <param name="settings"></param>
            <param name="nodes">the array of nodes to remover overlaps on</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.RemoveOverlaps(Microsoft.Msagl.Core.Layout.Node[],System.Double)">
            <summary>
            Removes the overlap by using the default settings.
            </summary>
            <param name="nodes"></param>
            <param name="nodeSeparation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.RemoveOverlaps">
            <summary>
            Removes the overlaps for the given graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.OneIteration(Microsoft.Msagl.Core.Geometry.Point[],Microsoft.Msagl.Core.DataStructures.Size[],System.Boolean)">
            <summary>
            Does one iterations in which a miniminum spanning tree is 
            determined on the delaunay triangulation and finally the tree is exanded to resolve the overlaps.
            </summary>
            <param name="nodePositions"></param>
            <param name="nodeSizes"></param>
            <param name="scanlinePhase"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.GetIdealEdgeLength(System.Int32,System.Int32,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.DataStructures.Size[],System.Boolean)">
            <summary>
            Returns a tuple representing an edge with: nodeId1, nodeId2, t(overlapFactor), ideal distance, edge weight.
            </summary>
            <param name="nodeId1"></param>
            <param name="nodeId2"></param>
            <param name="point1"></param>
            <param name="point2"></param>
            <param name="nodeSizes"></param>
            <param name="forLayers"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.GetIdealEdgeLength(System.Int32,System.Int32,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.DataStructures.Size[],System.Double@)">
            <summary>
            Returns the ideal edge length, such that the overlap is removed.
            </summary>
            <param name="nodeId1"></param>
            <param name="nodeId2"></param>
            <param name="point1"></param>
            <param name="point2"></param>
            <param name="nodeBoxes"></param>
            <param name="tRes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.GetDistanceRects(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Returns the distance between two given rectangles or zero if they intersect.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.MoveNodePositions(System.Collections.Generic.List{System.Tuple{System.Int32,System.Int32,System.Double,System.Double,System.Double}},Microsoft.Msagl.Core.Geometry.Point[],System.Int32)">
            <summary>
            Lets the tree grow according to the ideal distances.
            </summary>
            <param name="treeEdges"></param>
            <param name="nodePositions"></param>
            <param name="rootNodeId"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.DoInitialScaling(Microsoft.Msagl.Core.Layout.Node[],Microsoft.Msagl.Core.Geometry.Point[],Microsoft.Msagl.Core.DataStructures.Size[],Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.InitialScaling)">
            <summary>
            Does the initial scaling of the layout, could also be avoided.
            </summary>
            <param name="nodes"></param>
            <param name="nodePositions"></param>
            <param name="nodeSizes"></param>
            <param name="scalingMethod"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.GTreeOverlapRemoval.GetLastRunIterations">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.OverlapRemovalMethod">
            <summary>
            Enum containing the different overlap removal methods.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.OverlapRemovalMethod.Prism">
            <summary>
            Proximity Stress Model
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree.OverlapRemovalMethod.MinimalSpanningTree">
            <summary>
            Proximity Minimum Spanning Tree
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings">
            <summary>
            Settings for Overlap Removal process. Usage of the properties depends on the algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.StressSettings">
            <summary>
            Settings for the StressMajorization process.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.StopOnMaxIterat">
            <summary>
            If true, the overlap iteration process stops after maxIterat iterations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.Epsilon">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.IterationsMax">
            <summary>
            Number of maxIterat to be made. In each iteration overlap is partly removed.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.NodeSeparation">
            <summary>
            Minimal distance between nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.RandomizationSeed">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.RandomizeAllPointsOnStart">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.InitialScaling">
            <summary>
            Initial Scaling method is used if there is at least one edge.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.WorkInInches">
            <summary>
            Divide the coordinates by 72(Pixels) to work in inches. At the end this transformation is reverted again.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.Method">
            <summary>
            Method to be used for overlap removal.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings.Clone">
            <summary>
            Clones the settings together with the stressmajorization settings
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval">
            <summary>
             Proximity Stress Model as suggested by Gansner et. al, Fast Node Overlap Removal.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.Settings">
            <summary>
                Overlap Removal Parameters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.LastRunIterations">
            <summary>
            Stores the needed number of iterations for the last run.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.nodeSizes">
            <summary>
            Bounding boxes of nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.nodePositions">
            <summary>
            Node positions.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.NodeSizes">
            <summary>
            Current Node Boxes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.StressSolver">
            <summary>
                Solver for Stress Majorization
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.Graph">
            <summary>
                Graph for Overlap Removal.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.#ctor(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.OverlapRemovalSettings,Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.#ctor">
            <summary>
                Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
                Constructor
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.InitStressWithGraph(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization,Microsoft.Msagl.Core.Layout.Node[],Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
                Inits the datastructures, later forces can be defined on the nodes.
            </summary>
            <param name="majorizer"></param>
            <param name="nodes"></param>
            <param name="nodePositions"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.InitWithGraph">
            <summary>
                Inits some structures.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.RandomizePoints(Microsoft.Msagl.Core.Geometry.Point[],System.Random,System.Double,System.Boolean)">
            <summary>
                Coincidence of points is resolved by randomly moving the second of two points, until the coincidence is resolved.
                Points are also slightly randomized if randomizeAll is true, to avoid degenerate cases which will break the algorithm.
            </summary>
            <param name="points"></param>
            <param name="random"></param>
            <param name="epsilon"></param>
            <param name="randomizeAll"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetProximityEdgesWithDistance(Microsoft.Msagl.Core.Layout.Node[],Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt,Microsoft.Msagl.Core.DataStructures.Size[],System.Collections.Generic.List{System.Tuple{System.Int32,System.Int32,System.Double,System.Double}}@)">
            <summary>
            Determines the edges of the triangulation together with their desired length (distance between nodes).
            </summary>
            <param name="originalGraph"></param>
            <param name="cdt"></param>
            <param name="targetSizes"></param>
            <param name="desiredEdgeDistances"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetOverlapFactorBetweenNodes(System.Int32,System.Int32,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.DataStructures.Size[],System.Double@)">
            <summary>
            temporary due to merge problems.
            </summary>
            <param name="nodeId1"></param>
            <param name="nodeId2"></param>
            <param name="point1"></param>
            <param name="point2"></param>
            <param name="nodeBoxes"></param>
            <param name="tRes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetIdealDistanceBetweenNodes(System.Int32,System.Int32,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.DataStructures.Size[],System.Double@)">
            <summary>
            
            </summary>
            <param name="nodeId1"></param>
            <param name="nodeId2"></param>
            <param name="point1"></param>
            <param name="point2"></param>
            <param name="nodeBoxes"></param>
            <param name="tRes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.RemoveOverlaps">
            <summary>
                Removes the overlap according to the defined settings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.ShowCurrentMovementVectors(System.Int32,Microsoft.Msagl.Core.DataStructures.Size[],Microsoft.Msagl.Core.Geometry.Point[],System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Point},System.Collections.Generic.List{System.Tuple{System.Int32,System.Int32,System.Double,System.Double}},Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            For debugging only
            </summary>
            <param name="currentIteration"></param>
            <param name="nodeSizes"></param>
            <param name="nodePositions"></param>
            <param name="newPositions"></param>
            <param name="proximityEdgesWithDistance"></param>
            <param name="finalGridVectors"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.DoInitialScaling">
            <summary>
            Scale the graph, such that the average edge length corresponds to a predefined size.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.RemoveOverlaps(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double)">
            <summary>
            This method can directly be called to resolve overlaps on a graph with a given node separationl.
            </summary>
            <param name="geometryGraph"></param>
            <param name="nodeSeparation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.RemoveOverlaps(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetLastRunIterations">
            <summary>
            Number of iterations of the last run.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.ProximityOverlapRemoval.GetLastRunCpuTime">
            <summary>
            CpuTime of the last run.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.ExampleStressMajorization">
            <summary>
            Example on how to use Stress Majorization with a small graph and Localized method.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.ExampleStressMajorization.RunStressMajorizationExample">
            <summary>
            Example on how to use Stress Majorization with a small graph and Localized method.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod">
            <summary>
            Determines whether the given fixed number of iterations is used, or whether this number should be computed from the problem size.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod.FixedMax">
            <summary>
            Maximal number of iterations is fixed independent of problem size.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod.SqrtProblemSize">
            <summary>
            Maximal number of iterations is determined as Ceil(sqrt(problemSize))
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.MaxIterationMethod.LinearProblemSize">
            <summary>
            ProblemSize is taken as maximal number of iterations
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting">
            <summary>
            Collection of voting blocks for the node with index VotedNodeIndex.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.VotedNodeIndex">
            <summary>
            Index of the voted node.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.VotingBlocks">
            <summary>
            List of Blocks. Each Block has a set of votes for this node.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.#ctor(System.Int32)">
            <summary>
            Constructor which initializes a single empty block with BlockWeight 1.
            </summary>
            <param name="votedNodeIndex"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting.#ctor(System.Int32,System.Collections.Generic.List{Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock})">
            <summary>
            Constructor.
            </summary>
            <param name="votedNodeIndex"></param>
            <param name="votingBlocks"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings">
            <summary>
            Stress Majorization Settings.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.UpdateMethod">
            <summary>
            Update Scheme for node positions. Only has an effect if the SolvingMethod has <value>Localized</value>.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.SolvingMethod">
            <summary>
            Method with which the Stress should be minimized. 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.MaxStressIterations">
            <summary>
            Maximal number of iterations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.StressChangeTolerance">
            <summary>
            (stress(X(t))-stress(X(t+1)))/stress(X(t)), where X(t) (X(t+1)) are the node positions at iteration t (t+1). 
            When this value is small enough the layout process has converged (node positions will change only little in next iteration).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.CancelOnStressConvergence">
            <summary>
            if true: the StressMajorization process should be stopped when stress change is below the stressChangeTolerance
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.CancelOnStressMaxIteration">
            <summary>
            if true: the Stress Majorization process is canceled after the maximal number of iterations; 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.ResidualTolerance">
            <summary>
            Convergence Tolerance for the SolvingMethods. Has only effect on Conjugate Gradient methods.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.CancelAfterFirstConjugate">
            <summary>
            Cancels the process after one iteration, when Conjugate Cradient as SolvingMethod is used.
            This is only suggested for OverlapRemoval and not for general graph layouting.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.SolverMaxIteratMethod">
            <summary>
            Method with which the maximal number of iterations is determined for the stress solver. Only relevant for conjugate gradient methods.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.MaxSolverIterations">
            <summary>
            Maximal number of iterations for the solver used to minimize the stress. Only relevant for conjugate gradient methods.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.Parallelize">
            <summary>
            If true: Parallelization is used where possible.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorizationSettings.ParallelDegree">
            <summary>
            Degree of parallelization: Number of Threads allowed to run in parallel.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod">
            <summary>
            Determines how the minimum of the quadratic majorant is determined.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.Localized">
            <summary>
            Localized Optimization where each node is placed on the average of the votes he gets from the other nodes.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.PrecondConjugateGradient">
            <summary>
            Preconditioned Conjugated Gradient.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.SolvingMethod.ConjugateGradient">
            <summary>
            Conjugate Gradient without preconditioning.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization">
            <summary>
                Main class, which iteratively computes a layout according to the given votings and positions:
                (paper: Graph Drawing by Stress Majorization by Emden R. Gansner, Yehuda Koren, Stephen North)
                This class allows to deal with the sparse Stress also.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.NodeVotings">
            <summary>
                An entry in the list corresponds to a voting from another node to that node.
                For each node a set of votings from other nodes or reference points(virtual nodes).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.Positions">
            <summary>
                Positions to which the votings refer to. Positions may belong to nodes or just reference points (virtual nodes).
                used to influence the layout.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.IterateSingleLocalizedMethod">
            <summary>
                Iterates only once.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.IterateAll">
            <summary>
                Applies the Stress Majorization layout process with the defined StressSettings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.initMaxIterationsSolver">
            <summary>
            Sets the maximal number of iterations for the solver. Only relevant if conjugate gradient method is used.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.IterateSingleConjugateGradient">
            <summary>
             To get the next node coordinates the following system has to be solved:
             Lw*x=Lx*z(i), where x is the (unknown) node position vector, Lw and Lx are two known matrices (see Graph Drawing by Stress Majorization by Gansner et. al.) 
             and z(i) is the vector of current node positions in dimension i. 
             Each dimension has to be solved seperately.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.LocalizedOptimization(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting)">
            <summary>
                Local optimization for a given node, as described in Graph Drawing by Stress Majorization by Gansner et. al. (Sect. 2.3).
            </summary>
            <param name="nodeVoting"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.ClearVoting(Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.NodeVoting)">
            <summary>
                Clears the votings for a given node representative, but leaves the index references.
            </summary>
            <param name="nodeVoting"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.ClearVotings">
            <summary>
                Clears the Votings of the nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.StressMajorization.StressValue(System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            The value of the stress function with the current positions.
            </summary>
            <param name="nodePositions"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod.Serial">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.UpdateMethod.Parallel">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote">
            <summary>
            A vote for a certain distance from the node with voterIndex.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.VoterIndex">
            <summary>
            Index of the node from which this vote is coming.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.Distance">
            <summary>
            Desired distance.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.Weight">
            <summary>
            Weight for this vote: usually 1/(distance*distance)" 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Constructor.
            </summary>
            <param name="voterIndex"></param>
            <param name="distance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote.#ctor(System.Int32,System.Double)">
            <summary>
            Constructor which sets the default weight for the distance.
            </summary>
            <param name="voterIndex"></param>
            <param name="distance"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock">
            <summary>
            Votes are separated into block, so that their weight (BlockWeight) can easily be adjusted
            for different force types. 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.Votings">
            <summary>
            Set of votes from different nodes for the node to which this block belongs.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.BlockWeight">
            <summary>
            Defines how strong this block will be considered in the optimization process.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.VoteBlock.#ctor(System.Collections.Generic.List{Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.StressEnergy.Vote},System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="votings"></param>
            <param name="blockWeight"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Cluster">
            <summary>
                A cluster has a list of nodes and a list of nested clusters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.IsCollapsed">
            <summary>
                this flag should be respected by layout algorithms
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.BoundaryCurve">
            <summary>
            
            </summary>
        </member>
        <member name="E:Microsoft.Msagl.Core.Layout.Cluster.LayoutDoneEvent">
            <summary>
                event signalling that the layout is done
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.CollapsedBoundary">
            <summary>
                the boundary curve when the cluster is collapsed
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
                Bottom-most ctor.
            </summary>
            <param name="origin"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node})">
            <summary>
                Construct a cluster with the specified nodes as members
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Cluster})">
            <summary>
                Construct a cluster with the specified nodes and clusters as child members
            </summary>
            <param name="nodes"></param>
            <param name="clusters"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.RectangularBoundary">
            <summary>
                Clusters can (optionally) have a rectangular border which is respected by overlap avoidance.
                Currently, this is controlled by FastIncrementalLayoutSettings.RectangularClusters.
                If FastIncrementalLayoutSettings.RectangularClusters is true, then the
                FastIncrementalLayout constructor will create a RectangularBoundary in each cluster.
                Otherwise it will be null.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.Nodes">
            <summary>
                List of member nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.Clusters">
            <summary>
                List of child clusters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.Weight">
            <summary>
                number of nodes in cluster
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.BoundingBox">
            <summary>
                BoundingBox_get uses the RectangularBoundary.rectangle if available, otherwise uses the cluster's content bounds
                BoundingBox_set scales the old bounds to fit the desired bounds
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.AddChild(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
                Add a child node or cluster.  It is added to the correct list (nodes or clusters) based on type
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.ClearClusters">
            <summary>
                Cleares the child clusters.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.ComputeWeight">
            <summary>
                Compute the total weight of all nodes and clusters in this cluster.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.SetBarycenter">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.AllClustersDepthFirst">
            <summary>
                TODO: Check all the places we use this and make sure we don't have O(n^2) complexity
            </summary>
            <returns>This cluster and all clusters beneath this one, in depth first order</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.AllSuccessorsWidthFirst">
            <summary>
            </summary>
            <returns>This cluster and all clusters beneath this one, in width first order</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.AllClustersDepthFirstExcludingSelf">
            <summary>
            </summary>
            <returns>This cluster and all clusters beneath this one, in depth first order</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.ForEachNode(System.Action{Microsoft.Msagl.Core.Layout.Node})">
            <summary>
                TODO: Check all the places we use this and make sure we don't have O(n^2) complexity
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.RemoveCluster(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
                Remove the specified cluster from the list of children of this cluster
            </summary>
            <param name="cluster"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.DeepContentsTranslation(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
                Translates the cluster's contents into the rectangle.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.DeepContentsTranslation(Microsoft.Msagl.Core.Geometry.Point,System.Boolean)">
            <summary>
                Translates the cluster's contents by the delta.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.ChildEdges">
            <summary>
                Get edges both of whose end-points are immediate children of this cluster
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.EdgesIncomingToNodeWithDescendantSource(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
                get the edges incoming to the specified node where the source of the edge is a descendant of this cluster.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.EdgesIncomingToNodeWithChildSource(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
                get the edges incoming to the specified node where the source of the edge is an immediate child of this cluster.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.DeepTranslation(Microsoft.Msagl.Core.Geometry.Point,System.Boolean)">
            <summary>
                Translates the cluster and all of it's contents by the delta.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.CalculateBoundsFromChildren(System.Double)">
            <summary>
            </summary>
            <param name="padding"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Cluster.IsInInitialLayoutState">
            <summary>
                Has the cluster contents been moved or changed since an initial layout was applied?
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.SetInitialLayoutState(System.Double)">
            <summary>
                Calculate cluster's RectangularBoundary to preserve the offsets calculated in initial layout, for example,
                to allow for extra space required for non-shortest path edge routes or for labels.
            </summary>
            <param name="padding">amount of padding between child node bounding box and expected inner bounds</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.UnsetInitialLayoutState">
            <summary>
                sets IsInitialLayoutState to false and restores the default margins if we have a RectangularBoundary
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.UnsetInitialLayoutStateIncludingAncestors">
            <summary>
                Unset the initial layout state of this cluster and also all of its ancestors
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.AllClustersWideFirstExcludingSelf">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.AllClustersWidthFirstExcludingSelfAvoidingChildrenOfCollapsed">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.AddNode(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
                adding a node without checking that it is a cluster
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Cluster.ToString">
            <summary>
                to string!
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.GraphConnectedComponents">
            <summary>
            static class for GeometryGraph extension method
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GraphConnectedComponents.CreateComponents(System.Collections.Generic.IList{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge})">
            <summary>
            For a set of nodes and edges that have not already been added to a graph will return an enumerable of new
            graphs each of which contains a connected component.
            </summary>
            <remarks>
            Debug.Asserts that Parent of nodes and edges has not yet been assigned to ensure that this is not being
            applied to nodes and edges that have already been added to a graph.  Applying this to such edges would
            result in the Node InEdges and OutEdges lists containing duplicates.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GraphConnectedComponents.GetClusteredConnectedComponents(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Extension method to break a GeometryGraph into connected components taking into consideration clusters.
            Leaves the original graph intact, the resultant components contain copies of the original elements, with
            the original elements referenced in their UserData properties.
            </summary>
            <returns>
            the set of components, each as its own GeometryGraph.
            </returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GraphConnectedComponents.CopyCluster(Microsoft.Msagl.Core.Layout.Cluster,System.Int32@)">
            <summary>
            Create deep copy of Cluster hierarchy, where the nodes are already assumed to have been copied and loaded into the original nodes' AlgorithmData
            </summary>
            <param name="top">the source whose copy will become the new top of the cluster hierarchy</param>
            <param name="index">node counter index to use and increment as we add new Cluster nodes</param>
            <returns>Deep copy of cluster hierarchy</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.PortEntryOnCurve">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.PortEntryOnCurve.AllowedRectangles">
            <summary>
            returns an enumeration of the rectangles that are allowed for routing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.PortEntryOnCurve.Spans">
            <summary>
            paremeter spans
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.PortEntryOnCurve.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Collections.Generic.IEnumerable{System.Tuple{System.Double,System.Double}})">
            <summary>
            </summary>
            <param name="entryCurve"></param>
            <param name="parameterSpans"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.PortEntryOnCurve.GetEntryPoints">
            <summary>
            returns the points uniformly distributed over the entries
            </summary>
            <returns></returns>      
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.EdgeGeometry">
            <summary>
                Keeps the curve of the edge and arrowhead positions
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeGeometry.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.SourceArrowhead">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.TargetArrowhead">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.SourcePort">
            <summary>
                Defines the way the edge connects to the source.
                The member is used at the moment only when adding an edge to the graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.TargetPort">
            <summary>
                defines the way the edge connects to the target
                The member is used at the moment only when adding an edge to the graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.Waypoints">
            <summary>
                A sequence of points that the edge has to pass through
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.HasWaypoints">
            <summary>
                Indicates if this EdgeGeometry has waypoints.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeGeometry.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.LineWidth">
            <summary>
                edge thickness
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.Curve">
            <summary>
                A curve representing the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.SmoothedPolyline">
            <summary>
                the polyline of the untrimmed spline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.EdgeGeometry.BoundingBox">
            <summary>
                getting the bounding box of the curve and optional arrow heads
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeGeometry.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
                Translate all the geometries with absolute positions by the specified delta
            </summary>
            <param name="delta">vector by which to translate</param>
        </member>
        <member name="E:Microsoft.Msagl.Core.Layout.EdgeGeometry.LayoutChangeEvent">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.EdgeGeometry.RaiseLayoutChangeEvent(System.Object)">
            <summary>
            </summary>
            <param name="newValue"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.FloatingPort">
            <summary>
            floating port: specifies that the edge is routed to the Location 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.FloatingPort.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            constructor
            </summary>
            <param name="location"></param>
            <param name="curve">the port curve, can be null</param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.FloatingPort.Location">
            <summary>
            the location of the port
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.FloatingPort.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            translate the port location by delta
            </summary>
            <param name="delta"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.FloatingPort.Curve">
            <summary>
            the port's curve
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.FloatingPort.ToString">
            <summary>
            Return a string representation of the Port location
            </summary>
            <returns>a string representation of the Port location</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.GeometryGraph">
            <summary>
            This class keeps the graph nodes, edges, and clusters, together with their geometries
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.#ctor">
            <summary>
            Creates a new GeometryGraph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.RootCluster">
            <summary>
            The root cluster for this graph. Will never be null.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.BoundingBox">
            <summary>
            Bounding box of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Margins">
            <summary>
            margins width are equal from the left and from the right; they are given in percents
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Width">
            <summary>
            Width of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Height">
            <summary>
            Height of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Left">
            <summary>
            Left bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Right">
            <summary>
            Right bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.LeftBottom">
            <summary>
            Left bottom corner of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.RightTop">
            <summary>
            Right top corner of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Bottom">
            <summary>
            Bottom bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Top">
            <summary>
            Top bound of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Nodes">
            <summary>
            The nodes in the graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.Edges">
            <summary>
            Edges of the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.CollectAllLabels">
            <summary>
            Returns a collection of all the labels in the graph.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            transforms the graph by the given matrix
            </summary>
            <param name="matrix">the matrix</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.PumpTheBoxToTheGraphWithMargins">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.MinimalWidth">
            <summary>
            the minimal width of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.MinimalHeight">
            <summary>
            the minimal height of the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.PumpTheBoxToTheGraph(Microsoft.Msagl.Core.Geometry.Rectangle@)">
            <summary>
            enlarge the rectangle to contain the graph
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Translates the graph by delta.
            Assumes bounding box is already up to date.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.UpdateBoundingBox">
            <summary>
            Updates the bounding box to fit the contents.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.GetFlattenedNodesAndClusters">
            <summary>
            Flatten the list of nodes and clusters
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryGraph.FindNodeByUserData(System.Object)">
            <summary>
            Finds the first node with the corresponding user data.
            </summary>
            <returns>The first node with the given user data. Null if no such node exists.</returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryGraph.LgData">
            <summary>
            info of layers for large graph browsing
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.GeometryObject">
            <summary>
            The base class of the Graph,Node and Edge classes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryObject.GeometryParent">
            <summary>
            the parent of the object
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.GeometryObject.AlgorithmData">
            <summary>
            Storage for any data algorithms may want to store temporarily.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryObject.UserData">
            <summary>
            keeps the back pointer to the user data
            </summary>
        </member>
        <member name="E:Microsoft.Msagl.Core.Layout.GeometryObject.BeforeLayoutChangeEvent">
            <summary>
            event signalling that the layout is about to change
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.GeometryObject.BoundingBox">
            <summary>
            gets or sets the boundary box of a GeometryObject
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.GeometryObject.RaiseLayoutChangeEvent(System.Object)">
            <summary>
            
            </summary>
            <param name="newValue"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.ILabeledObject">
            <summary>
            interface for geometry objects with labels
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.ILabeledObject.Label">
            <summary>
            the label of the object 
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Label">
            <summary>
            A class keeping the data about an edge label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.Center">
            <summary>
            The center of the label bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.Width">
            <summary>
            Width of the label: set by the user.
            Label width could be different from the original width if the layer direction 
            of the layout is horizontal. This change is used only during the calcualations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.Height">
            <summary>
            Height of the label: set by the user
            Label height could be different from the original height if the layer direction 
            of the layout is horizontal. This change is used only during the calcualations 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Label.#ctor(System.Double,System.Double,Microsoft.Msagl.Core.Layout.GeometryObject)">
             <summary>
             Constructor
             </summary>
            <param name="labelWidth">width</param>
            <param name="labelHeight">height</param>
            <param name="parentP">the corresponding edge</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Label.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.BoundingBox">
            <summary>
            gets or sets the boundary box of the label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.AttachmentSegmentStart">
            <summary>
            the start of the segment showing the connection between the label and the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.AttachmentSegmentEnd">
            <summary>
            the point on the edge closest to the label center
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.PlacementOffset">
            <summary>
            0 is the start of the edge, 0.5 middle, 1 the end
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Label.PlacementSide">
            <summary>
            Options for which side of the edge the label should be placed on.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementSide.Any">
            <summary>
            Places the label on any side
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementSide.Port">
            <summary>
            Places the label on the port side of the edge.
            Port is the left side of the edge if you were facing away from the source and towards the target.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementSide.Starboard">
            <summary>
            Places the label on the starboard side of the edge.
            Starboard is the right side of the edge if you were facing away from the source and towards the target.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementSide.Top">
            <summary>
            Places the label on the top side of the line.
            If the line is vertical, the label is placed on the left.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementSide.Bottom">
            <summary>
            Places the label on the bottom side of the line.
            If the line is vertical, the label is placed on the right.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementSide.Left">
            <summary>
            Places the label on the left side of the line.
            If the line is horizontal, the label is placed on the top.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementSide.Right">
            <summary>
            Places the label on the right side of the line.
            If the line is horizontal, the label is placed on the bottom.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.Side">
            <summary>
            which side of the edge to place the label
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Label.PlacementStrategy">
            <summary>
            The various strategies we have for placing labels along edges
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.AlongCurve">
            <summary>
            Try to place the label running along the curve path
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Label.PlacementStrategy.Horizontal">
            <summary>
            Standard horizontal label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.PlacementStrategyPriority">
            <summary>
             an array of placement strategies
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.InnerPoints">
            <summary>
            Inner points of the label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.OuterPoints">
            <summary>
            Outer points of the label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Label.PlacementResult">
            <summary>
            The label placement algorithm sets this true if a "good" placement was found
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Label.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Translate the labels position state by the given delta
            </summary>
            <param name="delta"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort">
            <summary>
            Same behavior as RelativeFloatingPort but layout engines can choose the best relative
            location for routing from the list of possible locations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.LocationOffsets">
            <summary>
            Enumerate the offsets this was created with
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.ActiveOffsetIndex">
            <summary>
            LocationOffset is PossibleOffsets[ActiveOffsetIndex]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.LocationOffset">
            <summary>
            LocationOffset is PossibleOffsets[ActiveOffsetIndex]
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Func{Microsoft.Msagl.Core.Geometry.Point},System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            Same behavior as RelativeFloatingPort but layout engines can choose the best offset for routing
            from the list of possible offsets.
            </summary>
            <param name="curveDelegate">The curve the locations are relative to</param>
            <param name="centerDelegate">The center the locations are relative to</param>
            <param name="possibleOffsets">The offsets from the center that form the locations</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.SetClosestLocation(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Set LocationOffset to the PossibleOffset + CenterDelegate() that is closest to point.
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.MultiLocationFloatingPort.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Port">
            <summary>
            Specifies the way an edge is connected to a curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Port.Location">
            <summary>
            Gets the point associated with the port.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Port.Curve">
            <summary>
            Gets the boundary curve of the port.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Port.PortEntry">
            <summary>
            Defines one or more restrictions on where an edge can be routed relative to the port.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Port.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.IPortEntry">
            <summary>
            restricts the access to a port
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.IPortEntry.GetEntryPoints">
            <summary>
            returns the points nearby the middle of the entries
            </summary>
            <returns></returns>      
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.RelativeFloatingPort">
            <summary>
            A FloatingPort that has an associated Node, which is where we take the Curve,
            and we calculate the Location based on an offset from the Center of the RelativeTo node.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.RelativeFloatingPort.CenterDelegate">
            <summary>
            the delegate returning center
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.RelativeFloatingPort.CurveDelegate">
            <summary>
            the delegate returning center
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.RelativeFloatingPort.LocationOffset">
            <summary>
            An offset relative to the Center of the Node that we use to calculate Location
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.RelativeFloatingPort.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Func{Microsoft.Msagl.Core.Geometry.Point},Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Create a port relative to a specific node with an offset for the port Location from the nodes center
            <param name="curveDelegate"></param>
            <param name="centerDelegate"></param>
            <param name="locationOffset"></param>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.RelativeFloatingPort.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Func{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            Create a port relative to the center of a specific node
            </summary>
            <param name="curveDelegate"></param>
            <param name="centerDelegate"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.RelativeFloatingPort.Location">
            <summary>
            Get the location = CenterDelegate() + LocationOffset
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.RelativeFloatingPort.Curve">
            <summary>
            Get the curve from the node's BoundaryCurve
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Edge">
            <summary>
            Edge of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.SourcePort">
            <summary>
            Defines the way the edge connects to the source.
            The member is used at the moment only when adding an edge to the graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.TargetPort">
            <summary>
            defines the way the edge connects to the target
            The member is used at the moment only when adding an edge to the graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Label">
            <summary>
            gets the default (first) label of the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Labels">
            <summary>
            Returns the full enumeration of labels associated with this edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Source">
            <summary>
            id of the source node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.SourceAnchorNumber">
            <summary>
            For future use: The index of the anchor at the source node. By default is zero.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Target">
            <summary>
            id of the target node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.TargetAnchorNumber">
            <summary>
            For future use:The index of the anchor at the target node. By default is zero.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.OriginalLabelWidth">
            <summary>
            Label width, need to backup it for transformation purposes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.OriginalLabelHeight">
            <summary>
            Original label height
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double,System.Double,System.Double)">
            <summary>
            Edge constructor
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="labelWidth"></param>
            <param name="labelHeight"></param>
            <param name="edgeThickness"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Constructs an edge without a label or arrowheads and with edge thickness 1.
            </summary>
            <param name="source">souce node</param>
            <param name="target">target node</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.LabelBBox">
            <summary>
            The label bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Length">
            <summary>
            applicable for MDS layouts
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Weight">
            <summary>
            The greater is the weight the more important is keeping the edge short. It is 1 by default.
            Other values are not tested yet.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Separation">
            <summary>
            The minimum number of levels dividing source from target: 1 means that the edge goes down at least one level.
            Separation is 1 by default. Other values are not tested yet.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.ToString">
            <summary>
            overrides ToString
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.LineWidth">
            <summary>
            edge thickness
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.BoundingBox">
            <summary>
            The bounding box of the edge curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.EdgeGeometry">
            <summary>
            Gets or sets the edge geometry: the curve, the arrowhead positions and the underlying polyline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.UnderlyingPolyline">
            <summary>
            the polyline of the untrimmed spline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.Curve">
            <summary>
            A curve representing the edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            Transform the curve, arrowheads and label according to the given matrix
            </summary>
            <param name="matrix">affine transform matrix</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.Translate(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Translate the edge curve arrowheads and label by the specified delta
            </summary>
            <param name="delta">amount to shift geometry</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.TransformRelativeTo(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            transforms relative to given rectangles
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.ArrowheadAtSource">
            <summary>
            Checks if an arrowhead is needed at the source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Edge.ArrowheadAtTarget">
            <summary>
            Checks if an arrowhead is needed at the target
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.RouteSelfEdge(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double,Microsoft.Msagl.Core.Geometry.SmoothedPolyline@)">
            <summary>
            Routes a self edge inside the given "howMuchToStickOut" parameter
            </summary>
            <param name="boundaryCurve"></param>
            <param name="howMuchToStickOut"></param>
            <param name="smoothedPolyline"> the underlying polyline used later for editing</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.RouteSelfEdgeAtSide(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double)">
            <summary>
            Routes a self edge inside the given "howMuchToStickOut" parameter
            </summary>
            <param name="boundaryCurve"></param>
            <param name="howMuchToStickOut"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Edge.RaiseLayoutChangeEvent(System.Object)">
            <summary>
            
            </summary>
            <param name="newValue"></param>
        </member>
        <member name="E:Microsoft.Msagl.Core.Layout.Edge.BeforeLayoutChangeEvent">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings">
            <summary>
             controls many properties of the layout algorithm
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.EdgeRoutingSettings">
            <summary>
             defines edge routing behaviour
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.Reporting">
            <summary>
            Controls the reporting facility.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.PackingAspectRatio">
            <summary>
            Controls the ideal aspect ratio for packing disconnected components
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.PackingMethod">
            <summary>
            the packing method
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.NodeSeparation">
            <summary>
            When AvoidOverlaps is set, we optionally enforce a little extra space around nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.ClusterMargin">
            <summary>
            When AvoidOverlaps is set, we optionally enforce a little extra space between nodes and cluster boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.Layout.Node">
            <summary>
            Node of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.Padding">
            <summary>
            Padding around the node: splines should not get closer than padding to the node boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.BoundaryCurve">
            <summary>
            The engine assumes that the node boundaryCurve is defined relatively to the point (0,0)
            This must be a closed curve.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            Creates a Node instance
            </summary>
            <param name="curve">node boundaryCurve</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Object)">
            <summary>
            Create a node instance with the given curve and user data.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.ToString">
            <summary>
            Gets the UserData string if present.
            </summary>
            <returns>The UserData string.</returns>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Node.inEdges_">
            <summary>
            the list of in edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.InEdges">
            <summary>
            enumeration of the node incoming edges
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Node.outEdges_">
            <summary>
            the list of out edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.OutEdges">
            <summary>
            enumeration of the node outcoming edges
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Layout.Node.selfEdges_">
            <summary>
            the list of self edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.SelfEdges">
             <summary>
            enumeration of the node self edges
             </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.ClusterParents">
            <summary>
            Parents (if any) of which this node is a member
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.AllClusterAncestors">
            <summary>
            Walk up the ancestor chain for this node
            </summary>
            <value>an IEnumerable of ancestor clusters</value>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.AddClusterParent(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Add the parent cluster to this node's list of parents
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.RemoveSelfEdge(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            removes a self edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.AddOutEdge(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            adds and outgoing edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.AddInEdge(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            add an incoming edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.AddSelfEdge(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            adds a self edge
            </summary>
            <param name="edge"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.Edges">
            <summary>
            enumerates over all edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.Center">
            <summary>
            return the center of the curve bounding box
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.FitBoundaryCurveToTarget(Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            sets the bounding curve scaled to fit the targetBounds
            </summary>
            <param name="targetBounds"></param>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.BoundingBox">
            <summary>
            the bounding box of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.Width">
            <summary>
            Width of the node does not include the padding
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.Height">
            <summary>
            Height of the node does not including the padding
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Layout.Node.Degree">
            <summary>
            returns the node degree
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.RemoveInEdge(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            removes an outgoing edge
            </summary>
            <param name="edge"></param>
            <returns>True if the node is adjacent to the edge , and false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.RemoveOutEdge(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            removes an incoming edge
            </summary>
            <param name="edge"></param>
            <returns>True if the node is adjacent to the edge , and false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.ClearEdges">
            <summary>
            remove all edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.Transform(Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation)">
            <summary>
            </summary>
            <param name="transformation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.Layout.Node.IsDescendantOf(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Determines if this node is a descendant of the given cluster.
            </summary>
            <returns>True if the node is a descendant of the cluster.  False otherwise.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm">
            <summary>
            The algorithm used by the ProjectionSolver.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm.ProjectOnly">
            <summary>
            Iterative Project/Split only.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm.QpscWithScaling">
            <summary>
            Diagonally-scaled gradient projection/Qpsc (Quadratic Programming for Separation Constraints).
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.ProjectionSolver.SolverAlgorithm.QpscWithoutScaling">
            <summary>
            Gradient projection/Qpsc (Quadratic Programming for Separation Constraints) without diagonal scaling.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell">
            <summary>
            An interface that abstracts the underlying solver implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.AddGoalTwoVariablesAreClose(System.Int32,System.Int32)">
            <summary>
            Add a goal that the distance between two variables is minimized.
            </summary>
            <param name="id1">app id for the first variable</param>
            <param name="id2">app id for the second variable</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.AddGoalTwoVariablesAreClose(System.Int32,System.Int32,System.Double)">
            <summary>
            Add a goal that the distance between two variables is minimized, with a weight for the relationship.
            </summary>
            <param name="id1">app id for the first variable</param>
            <param name="id2">app id for the second variable</param>
            <param name="weight">the weight of the corresponding term in the goal function</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.AddLeftRightSeparationConstraint(System.Int32,System.Int32,System.Double)">
            <summary>
            Add a constraint that a+gap is less than or equal to b.
            </summary>
            <param name="idLeft">app id for left variable</param>
            <param name="idRight">app id for right variable</param>
            <param name="gap">required separation</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.AddLeftRightSeparationConstraint(System.Int32,System.Int32,System.Double,System.Boolean)">
            <summary>
            Add a constraint that a+gap is equal, or less than or equal, to b.
            </summary>
            <param name="idLeft">app id for left variable</param>
            <param name="idRight">app id for right variable</param>
            <param name="gap">Required separation</param>
            <param name="isEquality">Whether gap is exact rather than minimum</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.AddVariableWithIdealPosition(System.Int32,System.Double,System.Double)">
            <summary>
            Add a variable with a desired position and weight.
            </summary>
            <param name="id">app id for the variable</param>
            <param name="position">desired position</param> 
            <param name="weight">the weight of the corresponding term in the goal function</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.AddVariableWithIdealPosition(System.Int32,System.Double)">
            <summary>
            Add a variable with a desired position.
            </summary>
            <param name="id">app id for the variable</param>
            <param name="position">desired position</param> 
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.GetVariableResolvedPosition(System.Int32)">
            <summary>
            Get the solved position of a variable.
            </summary>
            <param name="id">app id of the variable</param>
            <returns>solved position</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.InitSolver">
            <summary>
            Initialize (or reinitialize) the solver.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.Solve">
            <summary>
            Execute the solver, filling in the Solution object and the values to be returned by GetvariableResolvedPosition.
            </summary>
            <returns>Pass or fail</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.Solve(System.Object)">
            <summary>
            Execute the solver, filling in the Solution object and the values to be returned by GetvariableResolvedPosition.
            </summary>
            <param name="parameters">Parameter object class specific to the underlying solver</param>
            <returns>Pass or fail</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.Solve(System.Object,System.Boolean@)">
            <summary>
            Execute the solver, filling in the Solution object and the values to be returned by GetvariableResolvedPosition.
            </summary>
            <param name="parameters">Parameter object class specific to the underlying solver</param>
            <param name="executionLimitExceeded">if true, one or more limits such as iteration count 
                    or timeout were exceeded</param>
            <returns>Pass or fail</returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.Solution">
            <summary>
            Returns the solution object class specific to the underlying solver, or null if there has
            been no call to Solve() or it threw an exception.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.AddFixedVariable(System.Int32,System.Double)">
            <summary>
            Add a variable at a fixed position.
            </summary>
            <param name="id">app id for variable</param>
            <param name="position">desired position</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.ContainsVariable(System.Int32)">
            <summary>
            Returns whether the given app id was added via AddVariableWithIdealPosition or AddFixedVariable.
            </summary>
            <param name="v"></param>
            <returns>Whether or not the app id was found</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ISolverShell.GetVariableIdealPosition(System.Int32)">
            <summary>
            gets the variable ideal position that has been set at the beginning
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.SolverShell">
            <summary>
            just a convenient interface to the real solver
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AddVariableWithIdealPosition(System.Int32,System.Double,System.Double)">
            <summary>
            Add a node that we would like as close to position i as possible, with the requested weight.
            </summary>
            <param name="id">Caller's unique identifier for this node</param>
            <param name="position">Desired position</param> 
            <param name="weight">The weight of the corresponding term in the goal function</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AddVariableWithIdealPosition(System.Int32,System.Double)">
            <summary>
            Add a node that we would like as close to position i as possible, with the requested weight.
            </summary>
            <param name="id"></param>
            <param name="position"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AddLeftRightSeparationConstraint(System.Int32,System.Int32,System.Double,System.Boolean)">
            <summary>
            Add a constraint that leftNode+gap eq|leq RightNode.
            </summary>
            <param name="idLeft">Caller's unique identifier for the left node</param>
            <param name="idRight">Caller's unique identifier for the right node</param>
            <param name="gap">Required gap</param>
            <param name="isEquality">Gap is exact rather than minimum</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AddLeftRightSeparationConstraint(System.Int32,System.Int32,System.Double)">
            <summary>
            Add a constraint that leftNode+gap leq RightNode.
            </summary>
            <param name="idLeft">Caller's unique identifier for the left node</param>
            <param name="idRight">Caller's unique identifier for the right node</param>
            <param name="gap">Required minimal gap</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AddGoalTwoVariablesAreClose(System.Int32,System.Int32,System.Double)">
            <summary>
            Add a goal that minimizes the distance between two nodes, i.e. weight*((id1-id2)^2).
            </summary>
            <param name="id1">Caller's unique identifier for the first node.</param>
            <param name="id2">Caller's unique identifier for the second node.</param>
            <param name="weight">The weight of the corresponding term in the goal function</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AddGoalTwoVariablesAreClose(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="id1"></param>
            <param name="id2"></param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.Solve">
            <summary>
            Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.Solve(System.Object)">
            <summary>
            Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
            </summary>
            <param name="parameters">Parameter object class specific to the underlying solver</param>
            <returns>Pass or fail</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.Solve(System.Object,System.Boolean@)">
            <summary>
            Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
            </summary>
            <param name="parameters">Parameter object class specific to the underlying solver</param>
            <param name="executionLimitExceeded">if true, one or more limits such as iteration count 
                    or timeout were exceeded</param>
            <returns>Pass or fail</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AdjustConstraintsOfNeighborsOfFixedVariable(System.Int32,System.Boolean@)">
            <summary>
            returns the block of the fixed variable
            </summary>
            <param name="fixedVar"></param>
            <param name="successInAdjusing"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.FailToAdjustEpsilon">
            <summary>
            if all active constraint gaps are less than this epsilon we should stop trying adjusting
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.GetVariableResolvedPosition(System.Int32)">
            <summary>
            Obtain the solved position for a node.
            </summary>
            <param name="id">Caller's unique identifier for the node.</param>
            <returns>The node's solved position.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.InitSolver">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.AddFixedVariable(System.Int32,System.Double)">
            <summary>
            Add a variable with a known and unchanging position.
            </summary>
            <param name="id">Caller's unique identifier for the node</param>
            <param name="position">Desired position.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.ContainsVariable(System.Int32)">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.GetVariableIdealPosition(System.Int32)">
            <summary>
            returns the ideal position of the node that had been set at the variable construction
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.SolverShell.Solution">
            <summary>
            Returns the solution object class specific to the underlying solver, or null if there has
            been no call to Solve() or it threw an exception.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Block.ToString">
            <summary>
            Generate a string representation of the Block.
            </summary>
            <returns>A string representation of the Block.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.BlockVector">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.BlockVector.ToString">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.Constraint">
            <summary>
            A Constraint defines the required minimal separation between two Variables
            (thus is essentially a wrapper around the require minimal separation between
            two nodes).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Constraint.Left">
            <summary>
            The Left (if horizontal; Top, if vertical) variable of the constraint.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Constraint.Right">
            <summary>
            The Right (if horizontal; Bottom, if vertical) variable of the constraint.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Constraint.Gap">
            <summary>
            The required separation of the points of the two Variables along the current axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Constraint.IsEquality">
            <summary>
            Indicates if the distance between the two variables must be equal to the gap
            (rather than greater or equal to).
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Constraint.ToString">
            <summary>
            Generates a string representation of the Constraint.
            </summary>
            <returns>A string representation of the Constraint.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Constraint.CompareTo(Microsoft.Msagl.Core.ProjectionSolver.Constraint)">
            <summary>
            Compare this Constraint to rhs by their Variables in ascending order (this == lhs, other == rhs).
            </summary>
            <param name="other">The object being compared to.</param>
            <returns>-1 if this.Left/Right are "less"; +1 if this.Left/Right are "greater"; 0 if this.Left/Right
                    and rhs.Left/Right are equal.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.ConstraintVector">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.ConstraintVector.ToString">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.DfDvNode">
            <summary>
            variableDoneEval is NULL if we are starting an evaluation; if recursive, it's the variable
            on that side from the parent call, which was already processed.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.DfDvNode.ToString">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.GlobalConfiguration">
            <summary>
            Global configuration constants for the ProjectionSolver namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.Parameters">
            <summary>
            Per-instance parameters for ProjectionSolver.Solver.Solve().
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Parameters.GapTolerance">
            <summary>
            GapTolerance is the amount of violation of constraint gaps we will accept as a
            perf/accuracy tradeoff. Anything greater than this is a violation; equal or below is not.
            PerfAcc: setting it to a larger value yields less violations/accuracy.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Parameters.QpscConvergenceEpsilon">
            <summary>
            When the absolute difference in Qpsc function value from the previous iteration to the current
            iteration is below this absolute-difference threshold, or when the QpscConvergenceQuotient
            condition is met, the function is considered converged.  
            PerfAcc: setting it to a larger value yields less iterations and thus potentially lower accuracy.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Parameters.QpscConvergenceQuotient">
            <summary>
            When the absolute difference in Qpsc function value from the previous iteration to the current
            iteration is divided by the previous iteration's function value, if the quotient is below
            this value, or the QpscConvergenceEpsilon condition is met, the function is considered converged.  
            PerfAcc: setting it to a larger value yields less iterations and thus potentially lower accuracy;
            a lower value yields more iterations and potentially greater accuracy.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Parameters.OuterProjectIterationsLimit">
            <summary>
            The maximum number of times the outer Project/Split loop should be run.  If this is less than 0
            (the default) it becomes a function based upon the number of variables; if it is 0, there is no limit.
            Termination due to this limit will result in a feasible solution.
            PerfAcc:  Primarily intended to mitigate nonconvergence scenarios; modify GapTolerance instead.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Parameters.InnerProjectIterationsLimit">
            <summary>
            Within any Project/Split loop iteration (see OuterProjectIterationsLimit), this is the maximum number
            of times Project should iterate internally.  If this is less than 0 (the default) it becomes a function
            based upon the number of constraints; if it is 0, there is no limit.
            Termination due to this limit may result in a nonfeasible solution.
            PerfAcc:  Primarily intended to mitigate nonconvergence scenarios; modify GapTolerance instead.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Parameters.TimeLimit">
            <summary>
            The maximum time (in milliseconds) allowed for ProjectionSolver.Solver.Solve(). If less than or equal
            to 0 (the default) there is no limit.  The cutoff is approximate since it is only examined on the outer
            Project iteration, for performance and to ensure a feasible result in the event of early termination.
            Termination due to this limit will result in a feasible solution.
            PerfAcc:  Primarily intended to mitigate nonconvergence scenarios; modify GapTolerance instead.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Parameters.Advanced">
            <summary>
            Parameters for advanced options.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Parameters.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Parameters.Clone">
            <summary>
            Deep-copy the AdvancedParameters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters">
            <summary>
            Parameter specification for advanced options.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.ForceQpsc">
            <summary>
            Whether Solve() should use the full Qpsc (Quadratic Programming for Separation Constraints; see paper)
            algorithm even if there are no neighbour pairs specified (neighbour pairs will always use Qpsc).
            Currently this is primarily for debugging and result verification.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.ScaleInQpsc">
            <summary>
            Whether the full Qpsc (Quadratic Programming for Separation Constraints; see paper) algorithm
            should use Diagonal Scaling (see the other paper).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.MinSplitLagrangianThreshold">
            <summary>
            Any Lagrangian Multiple less than (more negative than) this causes a block split.
            PerfAcc: setting it to a larger negative value yields less splits/accuracy.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.UseViolationCache">
            <summary>
            Whether to use the violation cache. PerfOnly: if false, other ViolationCache settings are ignored.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.ViolationCacheMinBlocksDivisor">
            <summary>
            Violation cache divisor for block count; the minimum of (number of initial blocks / ViolationCacheMinBlocksDivisor)
            and ViolationCacheMinBlocksCount is used as the minimum number of blocks that enables the violation cache.
            PerfOnly:  Modifies the number of cached violated constraints.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.ViolationCacheMinBlocksCount">
            <summary>
            Violation cache minimum; the minimum of (number of initial blocks / ViolationCacheMinBlocksDivisor)
            and ViolationCacheMinBlocksCount is used as the minimum number of blocks that enables the violation cache.
            PerfOnly:  Modifies the number of cached violated constraints.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.AdvancedParameters.Clone">
            <summary>
            Shallow-copy the object (there is nothing requiring deep-copy).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.Solution">
            <summary>
            Per-instance results from ProjectionSolver.Solver.Solve().
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.NumberOfUnsatisfiableConstraints">
            <summary>
            The only failure condition is if there are one or more unsatisfiable constraints, such as cycles
            or mutually exclusive equality constraints.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.OuterProjectIterations">
            <summary>
            The number of times the outer Project/Split loop was run.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.InnerProjectIterationsTotal">
            <summary>
            The number of times Project iterated internally; divide by OuterProjectIterations to get the average
            inner iterations per outer iteration; see also MinInnerProjectIterations and MaxInnerProjectIterations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.MinInnerProjectIterations">
            <summary>
            The minimum number of times Project iterated internally for any outer Project iterations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.MaxInnerProjectIterations">
            <summary>
            The maximum number of times Project iterated internally for any outer Project iterations.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.MaxConstraintTreeDepth">
            <summary>
            The maximum depth of a constraint tree.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.GoalFunctionValue">
            <summary>
            The final value of the goal function.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.AlgorithmUsed">
            <summary>
            Whether Solve() used the full Qpsc (Quadratic Programming for Separation Constraints) algorithm,
            either by default or because UsedParameters.ForceQpsc was set.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.TimeLimitExceeded">
            <summary>
            If true, the function ended due to TimeLimit being exceeded.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.OuterProjectIterationsLimitExceeded">
            <summary>
            If true, the function ended due to OuterProjectIterationsLimit being exceeded.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.InnerProjectIterationsLimitExceeded">
            <summary>
            If true, a call to Project ended early due to InnerProjectIterationsLimit being exceeded.
            The result may be nonfeasible.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solution.ExecutionLimitExceeded">
            <summary>
            Indicates whether one or more execution limits were exceeded.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solution.Clone">
            <summary>
            Shallow-copy everything, including the contained list.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.Solver">
            <summary>
            A Solver is the driving class that collects Variables and Constraints and then generates a
            solution that minimally satisfies the constraints.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.AddVariable(System.Object,System.Double)">
            <summary>
            Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
            </summary>
            <param name="userData">a tag or other user data - can be null</param>
            <param name="desiredPos">The position of the variable, such as the coordinate of a node along one axis.</param>
            <returns>The created variable</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.AddVariable(System.Object,System.Double,System.Double)">
            <summary>
            Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
            </summary>
            <param name="userData">a tag or other user data - can be null</param>
            <param name="desiredPos">The position of the variable, such as the coordinate of a node along one axis.</param>
            <param name="weight">The weight of the variable (makes it less likely to move if the weight is high).</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.AddVariable(System.Object,System.Double,System.Double,System.Double)">
            <summary>
            Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
            </summary>
            <param name="userData">a tag or other user data - can be null</param>
            <param name="desiredPos">The position of the variable, such as the coordinate of a node along one axis.</param>
            <param name="weight">The weight of the variable (makes it less likely to move if the weight is high).</param>
            <param name="scale">The scale of the variable, for improving convergence.</param>
            <returns>The created variable</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.UpdateVariables">
            <summary>
            Must be called before Solve() if the caller has updated variable Initial positions; this
            reconciles internals such as Block.ReferencePos.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solver.Variables">
            <summary>
            This enumerates all Variables created by AddVariable.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solver.VariableCount">
            <summary>
            The number of variables added to the Solver.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solver.Constraints">
            <summary>
            This enumerates all Constraints created by AddConstraint (which in turn may have
            been called from OverlapRemoval.ConstraintGenerator.Generate()).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Solver.ConstraintCount">
            <summary>
            The number of constraints added to the Solver.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.AddEqualityConstraint(Microsoft.Msagl.Core.ProjectionSolver.Variable,Microsoft.Msagl.Core.ProjectionSolver.Variable,System.Double)">
            <summary>
            Add a constraint 'left + gap' is equal to right
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="gap"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.AddConstraint(Microsoft.Msagl.Core.ProjectionSolver.Variable,Microsoft.Msagl.Core.ProjectionSolver.Variable,System.Double,System.Boolean)">
            <summary>
            Add a constraint 'left + gap' is less than or equal to 'right'
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="gap">The gap required between the variables.</param>
            <param name="isEquality"></param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.AddConstraint(Microsoft.Msagl.Core.ProjectionSolver.Variable,Microsoft.Msagl.Core.ProjectionSolver.Variable,System.Double)">
            <summary>
            Add a constraint 'left + gap' is less than or equal to 'right'
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="gap">The gap required between the variables.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.SetConstraintUpdate(Microsoft.Msagl.Core.ProjectionSolver.Constraint,System.Double)">
            <summary>
            Register an update to a constraint's gap; this defers the actual update until Solve() is called.
            </summary>
            <param name="constraint">The constraint to update</param>
            <param name="gap">The new gap</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.AddNeighborPair(Microsoft.Msagl.Core.ProjectionSolver.Variable,Microsoft.Msagl.Core.ProjectionSolver.Variable,System.Double)">
            <summary>
            Add a pair of connected variables for goal functions of the form (x1-x2)^2.  These are
            minimally satisfied, along with the default (x-i)^2 goal function, while also satisfying
            all constraints.
            </summary>
            <param name="variable1">The first variable</param>
            <param name="variable2">The second variable</param>
            <param name="relationshipWeight">The weight of the relationship</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.Solve">
            <summary>
            Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
            along this axis.  This overload uses default solution parameter values.
            </summary>
            <returns>A Solution object.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Solver.Solve(Microsoft.Msagl.Core.ProjectionSolver.Parameters)">
            <summary>
            Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
            along this axis.  This overload takes a parameter specification.
            </summary>
            <param name="solverParameters">Solution-generation options.</param>
            <returns>The only failure condition is if there are one or more unsatisfiable constraints, such as cycles
                    or mutually exclusive equality constraints; if these are encountered, a list of lists of these 
                    constraints is returned, where each list contains a single cycle, which may be of length one for
                    unsatisfiable equality constraints.  Otherwise, the return value is null.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProjectionSolver.Variable">
            <summary>
            A Variable is essentially a wrapper around a node, containing the node's initial and 
            current (Actual) positions along the current axis and a collection of Constraints.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Variable.UserData">
            <summary>
            Passed through as a convenience to the caller; it is not used by ProjectionSolver directly
            (except in VERIFY/VERBOSE where it uses ToString()), but if the variable list returned by
            Solver.Variables is sorted, then UserData must implement IComparable.  When Solve() is
            complete, the caller should copy the Variable's ActualPos property into whatever property
            the class specialization for this has.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Variable.DesiredPos">
            <summary>
            This holds the desired position of the node (the position we'd like it to have, initially 
            calculated before any constraint application).  This may change during the process of
            solution; currently that only happens if there are neighbors.  Each iteration of the
            solution keeps block reference-position calculation as close as possible to this position.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Variable.Weight">
            <summary>
            The weight of the node; a variable with a higher weight than others in its block will
            move less than it would if all weights were equal.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Variable.Scale">
            <summary>
            The scale of the variable.  May be set by the application.  For Qpsc this is computed 
            from the Hessian diagonal and replaces any application-set value during Solve().
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Variable.ActualPos">
            <summary>
            The current position of the variable; s[i]y[i] in the scaling paper.  It is updated on each 
            iteration inside Solve(), then unscaled to contain the final position when Solve() completes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Variable.DfDv">
            <summary>
            The derivative value - essentially the weighted difference in position.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Variable.ToString">
            <summary>
            Gets a string representation of the Variable; calls UserData.ToString as part of this.
            </summary>
            <returns>A string representation of the variable.</returns>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProjectionSolver.Variable.Name">
            <summary>
            Gets the string representation of UserData.
            </summary>
            <returns>A string representation of Node.Object.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.Variable.CompareTo(Microsoft.Msagl.Core.ProjectionSolver.Variable)">
            <summary>
            Compare the Variables by their ordinals, in ascending order (this == lhs, other == rhs).
            </summary>
            <param name="other">The object being compared to.</param>
            <returns>-1 if this.Ordinal is "less"; +1 if this.Ordinal is "greater"; 0 if this.Ordinal
                    and rhs are equal.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProjectionSolver.UniformOneDimensionalSolver.#ctor(System.Double)">
            <summary>
            desired variable separation
            </summary>
            <param name="variableSeparation"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.ParallelUtilities">
            <summary>
            Helper methods for running tasks in parallel.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ParallelUtilities.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{System.Int32})">
            <summary>
            Runs the given action on the source items in parallel.  Calls the progress action on the caller thread as items get processed.
            </summary>
            <typeparam name="T">The type of items in the source enumerable.</typeparam>
            <param name="source">The items that action will be applied to.</param>
            <param name="action">The action being applied to the items.</param>
            <param name="progressAction">The action being called to report progress on the items.  The integer parameter is the number of items processed since the last progress report.</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ParallelUtilities.HandleParallelException(System.Exception)">
            <summary>
            Handles exceptions from a parallel loop.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Routing.BundlingSettings">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier">
            <summary>
            the default value of CapacityOverflowCoefficient
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.CapacityOverflowCoefficient">
            <summary>
            this number is muliplied by the overflow penalty cost and by the sum of the LengthImportanceCoefficient 
            and InkImportanceCoefficient, and added to the routing price
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.BundlingSettings.MaxHubRadius">
            <summary>
            the upper bound of the virtual node radius
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.BundlingSettings.MinHubRadius">
            <summary>
            the lower bound of the virtual node radius
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.CreateUnderlyingPolyline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultPathLengthImportance">
            <summary>
            the default path lenght importance coefficient
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.PathLengthImportance">
            <summary>
            the importance of path lengths coefficient
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultInkImportance">
            <summary>
            the default ink importance
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.InkImportance">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.BundlingSettings.DefaultEdgeSeparation">
            <summary>
            default edge separation
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.EdgeSeparation">
            <summary>
            Separation between to neighboring edges within a bundle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.UseCubicBezierSegmentsInsideOfHubs">
            <summary>
            if is set to true will be using Cubic Bezie Segments inside of hubs, otherwise will be using Biarcs
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.UseGreedyMetrolineOrdering">
            <summary>
            if is set to true will be using greedy ordering algorithm, otherwise will be using linear
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.AngleThreshold">
            <summary>
            min angle for gluing edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.HubRepulsionImportance">
            <summary>
            the importance of hub repulsion coefficient
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.BundleRepulsionImportance">
            <summary>
            the importance of bundle repulsion coefficient
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.MinimalRatioOfGoodCdtEdges">
            <summary>
            minimal ration of cdt edges with satisfied capacity needed to perform bundling
            (otherwise bundling will not be executed)
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.HighestQuality">
            <summary>
            speed vs quality of the drawing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.KeepOriginalSpline">
            <summary>
            if is set to true the original spline before the trimming should be kept under the corresponding EdgeGeometry
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.KeepOverlaps">
            <summary>
            if set to true then the edges will be routed one on top of each other with no gap inside of a bundle
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.BundlingSettings.StopAfterShortestPaths">
            <summary>
            calculates the routes that just follow the visibility graph
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings">
            <summary>
             defines egde routing behaviour
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.EdgeRoutingMode">
            <summary>
             defines the way edges are routed
             
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.ConeAngle">
            <summary>
             the angle in degrees of the cones in the routing fith the spanner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.Padding">
            <summary>
            Amount of space to leave around nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.PolylinePadding">
            <summary>
            Additional amount of padding to leave around nodes when routing with polylines
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.CornerRadius">
            <summary>
            For rectilinear, the degree to round the corners
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.BendPenalty">
            <summary>
            For rectilinear, the penalty for a bend, as a percentage of the Manhattan distance between the source and target ports.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.BundlingSettings">
            <summary>
            the settings for general edge bundling
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.UseObstacleRectangles">
            <summary>
            For rectilinear, whether to use obstacle bounding boxes in the visibility graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.RoutingToParentConeAngle">
            <summary>
            this is a cone angle to find a relatively close point on the parent boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.SimpleSelfLoopsForParentEdgesThreshold">
            <summary>
            if the number of the nodes participating in the routing of the parent edges is less than the threshold 
            then the parent edges are routed avoiding the nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.IncrementalRoutingThreshold">
            <summary>
            defines the size of the changed graph that could be routed fast with the standard spline routing when dragging
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.KeepOriginalSpline">
            <summary>
            if set to true the original spline is kept under the corresponding EdgeGeometry
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.Routing.EdgeRoutingSettings.RouteMultiEdgesAsBundles">
            <summary>
            if set to true routes multi edges as ordered bundles, when routing in a spline mode
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Microsoft.Msagl.Core.Routing.EdgeRoutingMode">
            <summary>
            defines the way edges are routed
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Spline">
            <summary>
            routing splines over tangent visibility graph edge as a sequence of Bezier segments 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SplineBundling">
            <summary>
            drawing ordered bundles
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.EdgeRoutingMode.StraightLine">
            <summary>
            draw edges as straight lines 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.EdgeRoutingMode.SugiyamaSplines">
            <summary>
            inside of Sugiyama algorithm use the standard spline routing
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.EdgeRoutingMode.Rectilinear">
            <summary>
            rectilinear edge routing
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.EdgeRoutingMode.RectilinearToCenter">
            <summary>
            rectilinear but not checking for the optimal port and routing just to the node centers
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Core.Routing.EdgeRoutingMode.None">
            <summary>
            means no routing should be done
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.ProgressChangedEventArgs">
            <summary>
            Progress changed event argument class for MSAGL progress changes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProgressChangedEventArgs.#ctor(System.Double)">
            <summary>
            Constructurs a ProgressChangedEventArgs with the given ratio complete.
            </summary>
            <param name="ratioComplete">between 0 (not started) and 1 (finished)</param>
        </member>
        <member name="M:Microsoft.Msagl.Core.ProgressChangedEventArgs.#ctor(System.Double,System.String)">
            <summary>
            Constructurs a ProgressChangedEventArgs with the given ratio complete and description.
            </summary>
            <param name="ratioComplete">between 0 (not started) and 1 (finished)</param>
            <param name="algorithmDescription">a useful description</param>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProgressChangedEventArgs.AlgorithmDescription">
            <summary>
            A useful algorithm description: e.g. the stage of layout in progress.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.ProgressChangedEventArgs.RatioComplete">
            <summary>
            The ratio complete of the current stage: should always be between 0 and 1.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.CancelToken">
            <summary>
            a place holder for the cancelled flag
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.CancelToken.Canceled">
            <summary>
            Set this flag to true when you want to cancel the layout.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.CancelToken.ThrowIfCanceled">
            <summary>
            throws is the layout has been cancelled
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Core.CancelToken.CancellationToken">
            <summary>
            Pass this cancelation token for use in cancellable parallel for-each operations
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Core.ValidateArg">
            <summary>
            Helper class for validating parameter arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Core.ValidateArg.IsNotNull(System.Object,System.String)">
            <summary>
            Throws ArgumentNullException if the argument is null.
            </summary>
            <param name="arg">The argument to check.</param>
            <param name="parameterName">The parameter name of the argument.</param>
            <remarks>
            The ValidatedNotNullAttribute lets FxCop know that this method null-checks the argument.
            </remarks>
        </member>
        <member name="M:Microsoft.Msagl.Core.ValidateArg.IsPositive(System.Double,System.String)">
            <summary>
            Throws ArgumentOutOfRangeException if the argument is less than 0.
            </summary>
            <param name="value">The argument to check.</param>
            <param name="parameterName">The parameter name of the argument.</param>
            <remarks>
            The ValidatedNotNullAttribute lets FxCop know that this method null-checks the argument.
            </remarks>
        </member>
        <member name="M:Microsoft.Msagl.Core.ValidateArg.IsNotEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            throws ArgumentException if the enumerable is empty
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="parameterName"></param>
        </member>
        <member name="T:Microsoft.Msagl.Core.ValidateArg.ValidatedNotNullAttribute">
            <summary>
            Marks the parameter as being validated by the method.
            </summary>
            <remarks>
            StyleCop uses this to determine whether the calling method has validated a parameter.
            </remarks>
        </member>
        <member name="T:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader">
            <summary>
            reads the GeometryGraph from a file
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.EdgeList">
            <summary>
            the list of edges, needed to match it with GraphReader edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.Settings">
            <summary>
            The deserialized settings.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.#ctor(System.IO.Stream)">
            <summary>
            constructor witha given stream
            </summary>
            <param name="streamP"></param>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.FindClusterById(System.String)">
            <summary>
            
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.FindNodeById(System.String)">
            <summary>
            
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.CreateFromFile(System.String)">
            <summary>
            creates the graph from a given file
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.CreateFromFile(System.String,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings@)">
            <summary>
            creates the graph and settings from a given file
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.Read">
            <summary>
            Reads the graph from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadLayoutAlgorithmSettings(System.Xml.XmlReader)">
            <summary>
            reads the layout algorithm settings
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadBooleanElement(Microsoft.Msagl.DebugHelpers.GeometryToken)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadElementContentAsBoolean">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.XmlReader">
             <summary>
             the xml reader
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.SetXmlReader(System.Xml.XmlReader)">
             <summary>
             the xml reader
            <parameter>the reader</parameter>
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.CheckToken(Microsoft.Msagl.DebugHelpers.GeometryToken)">
            <summary>
            used only in Debug configuration
            <param name="token">the token that should be here</param>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadEndElement">
            <summary>
            reads the end element
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadElementContentAsDouble">
            <summary>
             reads a double
            </summary>        
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.XmlRead">
            <summary>
            reads the line?
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.ReadElementContentAsInt">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphReader.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter">
            <summary>
            writes a GeometryGraph to a stream
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.graph">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.#ctor(System.IO.Stream,Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings)">
            <summary>
            Constructor
            </summary>
            <param name="streamPar">the stream to write the graph into</param>
            <param name="graphP">the graph</param>
            <param name="settings">The settings to be written.</param>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.#ctor">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.NeedToCloseXmlWriter">
            <summary>
            if set to true then the XmlWriter will be closed after the graph writing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Stream">
            <summary>
            the stream to write the graph into
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.XmlWriter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Graph">
            <summary>
            the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Settings">
            <summary>
            The settings
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Write(Microsoft.Msagl.Core.Layout.GeometryGraph,System.String)">
            <summary>
            saves the graph to a file
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Write(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings,System.String)">
            <summary>
            saves the graph and settings to a file
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Write">
            <summary>
            Writes the graph to a file
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.WriteIpe">
            <summary>
            roman: Writes the graph to an Ipe file
            todo
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.Precision">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.NodeToIds">
            <summary>
             a mapping from nodes to their ids
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.EdgeEnumeration">
            <summary>
            this enumeration is used in a combination with GraphWriter, to dictate the order of edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.WriteStartElement(Microsoft.Msagl.DebugHelpers.GeometryToken)">
            <summary>
            writes the starte element with the token
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.WriteStringElement(Microsoft.Msagl.DebugHelpers.GeometryToken,System.Double)">
            <summary>
            WriteStringElement with double
            </summary>
            <param name="tokens"></param>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.WriteEndElement">
            <summary>
            writes the end element
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Persistence.GeometryGraphWriter.WriteLayoutSettings">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.DebugHelpers.ClusterWithChildLists">
            <summary>
            this class is needed for temporarily holding the list of integers representing cluster childs,
            and the list of node Id's representing cluster child nodes
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.DebugHelpers.GeometryToken">
            <summary>
            tokens for the graph parser
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Clusters">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Force">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Barycenter">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Cluster">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Width">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Label">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.MsaglGeometryGraph">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Header">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.AspectRatio">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Transform">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.TransformElement">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.NodeSeparation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LayerSeparation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Margins">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.MinNodeWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Nodes">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Edges">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Node">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Edge">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Id">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Padding">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ICurve">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Ellipse">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Curve">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LineSegment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.CubicBezierSegment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.AxisA">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.AxisB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Center">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Point">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.XCoordinate">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.YCoordinate">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.SourceNodeId">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.TargetNodeId">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LabelWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LabelHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LabelCenter">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LineWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ArrowheadAtSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ArrowheadPosition">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ArrowheadAtTarget">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Weight">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Separation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Start">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.End">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.B0">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.B1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.B2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.B3">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.UnderlyingPolyline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.UnderlyingPolylineIsNull">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.PolylineSite">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.SiteK">
            <summary>
            
            </summary>    
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.SiteV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ParStart">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ParEnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Reporting">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.RandomSeedForOrdering">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.NoGainStepsBound">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.MaxNumberOfPassesInOrdering">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Demotion">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.GroupSplit">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LabelCornersPreserveCoefficient">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.SplineCalculationDuration">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.BrandesThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmSettings">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.SugiyamaLayoutSettings">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.MdsLayoutSettings">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.RankingLayoutSetting">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.LayoutAlgorithmType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.RepetitionCoefficientForOrdering">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Exponent">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.IterationsWithMajorization">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.PivotNumber">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.RotationAngle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ScaleX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ScaleY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.OmegaX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.OmegaY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.EdgeRoutingMode">
            <summary>
            defines the edge routing mode
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.UseSparseVisibilityGraph">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.UseKdHull">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ClusterIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ChildClusters">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ChildNodes">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.RectangularBoundary">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Polyline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Closed">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.PolylinePoints">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.CurveData">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Cx">
            <summary>
            center x
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Cy">
            <summary>
            center y
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Ry">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Rx">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ArrowheadPositionAtSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.ArrowheadPositionAtTarget">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Polygon">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.MsaglGeometryFile">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Error">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Rect">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Points">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.T">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.S">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.As">
            <summary>
            arrowhead at source
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.At">
            <summary>
            arrowhead at target
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Graph">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Asl">
            <summary>
             ArrowheadSourceLength
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.Atl">
            <summary>
            ArrowheadTargetLength
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.DebugHelpers.GeometryToken.RectangularClusterBoundary">
            <summary>
            RectangleClusterBoundary
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.DebugHelpers.Timer">
            <summary>
            support for native method calls
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Timer.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Timer.Start">
            <summary>
            Start the timer
            </summary>
            <returns>long - tick count</returns>
        </member>
        <member name="M:Microsoft.Msagl.DebugHelpers.Timer.Stop">
            <summary>
            Stop timer 
            </summary>
            <returns>long - tick count</returns>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Timer.Duration">
            <summary>
            Return the duration of the timer in seconds.
            </summary>
            <returns>double - duration</returns>
        </member>
        <member name="P:Microsoft.Msagl.DebugHelpers.Timer.Frequency">
             <summary>
             Frequency of timer (no counts in one second on this machine)
             </summary>
            <returns>long - Frequency</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Initial.Relayout">
            <summary>
            todo: 
            find a way to compact disconnected components - incremental packing?
            animate transitions
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.Relayout.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Recursively lay out the given clusters using the specified settings for each cluster, or if none is given for a particular
            cluster then inherit from the cluster's ancestor - or from the specifed defaultSettings.
            Clusters (other than the root) will be translated (together with their descendants) such that their 
            bottom-left point of their new boundaries are the same as the bottom-left of their old boundaries 
            (i.e. clusters are laid-out in place).
            </summary>
            <param name="graph">The graph being operated on.</param>
            <param name="modifiedNodes">The nodes whose bounds are modified.</param>
            <param name="addedNodes">Nodes added to the graph - a new initial position will be found for these nodes close to their neighbors</param>
            <param name="clusterSettings">Settings to use for each cluster.</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.Relayout.RunInternal">
            <summary>
            The actual layout process
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.Relayout.LayoutCluster(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Apply the appropriate layout to the specified cluster
            </summary>
            <param name="cluster">the root of the cluster hierarchy to lay out</param>
            <returns>list of edges external to the cluster</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.Relayout.GenerateOrthogonalOrderingConstraints(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings)">
            <summary>
            Generate orthogonal ordering constraints to preserve the left/right, above/below relative positions of nodes
            </summary>
            <param name="nodes"></param>
            <param name="settings"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.Relayout.GetShallowCopyGraphUnderCluster(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Creates a shallow copy of the cluster into a GeometryGraph
            </summary>
            <param name="cluster">cluster to copy</param>
            <returns>cluster children and edges between children in a GeometryGraph</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster">
            <summary>
            Methods for obtaining an initial layout of a graph by arranging clusters bottom up using various means.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings)">
            <summary>
            Recursively lay out the clusters of the given graph using the given settings.
            </summary>
            <param name="graph">The graph being operated on.</param>
            <param name="defaultSettings">Settings to use if none is provided for a particular cluster or its ancestors.</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Recursively lay out the clusters of the given graph using the specified settings for each cluster, or if none is given for a particular
            cluster then inherit from the cluster's ancestor - or from the specifed defaultSettings.
            </summary>
            <param name="graph">The graph being operated on.</param>
            <param name="clusterSettings">Settings to use for each cluster and its descendents (if none provided for that descendent.</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Cluster},System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Recursively lay out the given clusters using the specified settings for each cluster, or if none is given for a particular
            cluster then inherit from the cluster's ancestor - or from the specifed defaultSettings.
            Clusters (other than the root) will be translated (together with their descendants) such that their 
            bottom-left point of their new boundaries are the same as the bottom-left of their old boundaries 
            (i.e. clusters are laid-out in place).
            </summary>
            <param name="graph">The graph being operated on.</param>
            <param name="clusters">The clusters to layout.</param>
            <param name="clusterSettings">Settings to use for each cluster and its descendents (if none provided for that descendent.</param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.RunInParallel">
            <summary>
            if set to true than parallel execution will b
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.RunInternal">
            <summary>
            The actual layout process
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.LayoutCluster(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Apply the appropriate layout to the specified cluster and its children (bottom up)
            </summary>
            <param name="cluster">the root of the cluster hierarchy to lay out</param>
            <returns>list of edges external to the cluster</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.IsDescendant(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Check if root is an ancestor of node
            </summary>
            <param name="node"></param>
            <param name="root"></param>
            <returns>true if the node is a descendant of root</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.GetComponents(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Creates a shallow copy of the root cluster and divides into GeometryGraphs each of which is a connected component with
            respect to edges internal to root.
            </summary>
            <param name="cluster">cluster to break into components</param>
            <returns>GeometryGraphs that are each a connected component</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.CopyEdge(System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node},Microsoft.Msagl.Core.Layout.Edge,Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Create a copy of the edge using the specified original source and target, store the original in user data
            </summary>
            <param name="originalToCopyNodeMap">mapping from original nodes to their copies</param>
            <param name="originalEdge">edge to copy</param>
            <param name="originalSource">take this as the source node for the edge (e.g. an ancestor of the actual source)</param>
            <param name="originalTarget">take this as the target node for the edge (e.g. an ancestor of the actual target)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.CopyEdge(System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node},Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            Copy the specified edge, use the given dictionary to find the copies of the edges source and target nodes
            </summary>
            <param name="originalToCopyNodeMap">mapping from original nodes to their copies</param>
            <param name="originalEdge"></param>
            <returns>Copy of edge</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.ShallowNodeCopyDictionary(Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            Copy the cluster's child Nodes and Clusters as nodes and return a mapping of original to copy.
            The reverse mapping (copy to original) is available via the copy's UserData
            </summary>
            <param name="cluster">Cluster whose contents will be copied</param>
            <returns>the mapping from original to copy</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayoutByCluster.Ancestor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Cluster)">
            <summary>
            find ancestor of node that is immediate child of root, or node itself if node is a direct child of root
            null if none
            </summary>
            <param name="node"></param>
            <param name="root"></param>
            <returns>returns highest ancestor of node (or node itself) that is a direct child of root, null if not 
            a descendent of root</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Initial.InitialLayout">
            <summary>
            Methods for obtaining an initial layout of a graph using various means.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Initial.InitialLayout.SingleComponent">
            <summary>
            Set to true if the graph specified is a single connected component with no clusters
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayout.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings)">
            <summary>
            Static layout of graph by gradually adding constraints.
            Uses PivotMds to find initial layout.
            Breaks the graph into connected components (nodes in the same cluster are considered
            connected whether or not there is an edge between them), then lays out each component
            individually.  Finally, a simple packing is applied.
            ratio as close as possible to the PackingAspectRatio property (not currently used).
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayout.RunInternal">
            <summary>
            The actual layout process
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Initial.InitialLayout.GetConstraintLevels(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Get the distinct ConstraintLevels that need to be applied to layout.
            Used by InitialLayout.
            Will only include ConstraintLevel == 1 if there are structural constraints
            Will only include ConstraintLevel == 2 if AvoidOverlaps is on and there are fewer than 2000 nodes
            </summary>
            <returns>0, 1 or 2</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes">
            <summary>
            sets zoom levels for LgNodeInfos
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.DeviceIndependendZoomCalculatorForNodes.Run">
            <summary>
            We expect that the node Ranks are set before the method call.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.IZoomLevelCalculator.Run">
            <summary>
            returns the top node
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.IZoomLevelCalculator.Graph">
            <summary>
            the graph under layout
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.IZoomLevelCalculator.Settings">
            <summary>
            layout settings
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.LgData">
            <summary>
            data for large graph browsing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgData.Levels">
            <summary>
            the list of levels
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgData.SortedLgNodeInfos">
            <summary>
            LgNodeInfos sorted by their importance
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgData.LevelNodeCounts">
            <summary>
            the last indices of nodes on levels, the indices point to SortedLgNodeInfos
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgData.GetRailsOfEdgesOnLevel(System.Int32,System.Collections.Generic.List{Microsoft.Msagl.Core.Layout.Edge})">
            <summary>
            gets all rails corresponding to edges on given level.
            </summary>
            <param name="i"></param>
            <param name="edges"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.#ctor(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            
            </summary>
            <param name="edge"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgEdgeInfo.Edge">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor">
            <summary>
                enables to interactively explore a large graph
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor._runInParallel">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings,Microsoft.Msagl.Core.CancelToken)">
            <summary>
                constructor
            </summary>
            <param name="geometryGraph"></param>
            <param name="lgLayoutSettings"></param>
            <param name="cancelToken"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.RailGraph">
            <summary>
                this graph is currently visible set of nodes and pieces of edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.GeometryEdgesToLgEdgeInfos">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.Run">
            <summary>
                does the initialization
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.GetApproximateLayerCounts(Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
                trying to approximately evaluate what the number of nodes will be in each layer
            </summary>
            <param name="componentNodes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.RunOnViewChange">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.GetMaximalZoomLevel">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.GetEdgesPassingThroughRail(Microsoft.Msagl.Layout.LargeGraphLayout.Rail)">
            <summary>
                gets all edges passing through rail from the rail's level.
            </summary>
            <param name="rail"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.UpdatePrevLayerTrajectories(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.LgNodeInfo},Microsoft.Msagl.Layout.LargeGraphLayout.LgSkeletonLevel,Microsoft.Msagl.Layout.LargeGraphLayout.LgSkeletonLevel)">
            <summary>
            find a better name
            </summary>
            <param name="i"></param>
            <param name="nodes"></param>
            <param name="prevSkeletonLevel"></param>
            <param name="skeletonLevel"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgInteractor.LayoutAndRouteByLayers(System.Int32,System.Int32,System.Double)">
            <summary>
            calculates all info for LG Browsing
            </summary>
            <param name="maxNodesPerTile"></param>
            <param name="maxSegmentsPerTile"></param>
            <param name="increaseNodeQuota"></param>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings">
            <summary>
            layout settings to handle a large graph
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.NodeDotWidthInInches">
            <summary>
            size of drawn node
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.MaximalArrowheadLength">
            <summary>
            Func giving the maximal arrowhead length for the current viewport
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.LgLayoutEvent">
            <summary>
            delegate to be called by LgInteractor on a graph change
            </summary>
        </member>
        <member name="E:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.ViewerChangeTransformAndInvalidateGraph">
            <summary>
            event handler to be raised when the graph and its transform change
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.OnViewerChangeTransformAndInvalidateGraph">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.RailGraph">
            <summary>
            this graph is shown in the viewer
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.Clone">
            <summary>
            clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.Interactor">
            <summary>
            the algorithm object
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.ClientViewportFunc">
            <summary>
            a delegate returning the current viewport of the viewer
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Rectangle},System.Func{Microsoft.Msagl.Core.Geometry.Curves.PlaneTransformation},System.Double,System.Double,System.Func{System.Double})">
            <summary>
            constructor
            </summary>
            <param name="clientViewportFunc"></param>
            <param name="transformFromGraphToScreen"> </param>
            <param name="dpiX"> </param>
            <param name="dpiY"> </param>
            <param name="maximalArrowheadLength">the dynamic length of the arrowhead</param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.GeometryNodesToLgNodeInfos">
            <summary>
            the mapping from Geometry nodes to LgNodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.GeometryEdgesToLgEdgeInfos">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings._scaleInterval">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.ExitAfterInit">
            <summary>
            used for debugging mostly
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.ScaleInterval">
            <summary>
            the range of scale 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.NeedToLayout">
            <summary>
            set this property to true if the graph comes with a given layout
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.MaxNumberOfNodesPerTile">
            <summary>
            the node quota per tile
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgLayoutSettings.GetMaximalZoomLevel">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel">
            <summary>
            class keeping a level info
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.#ctor(System.Int32,Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="zoomLevel"></param>
            <param name="geomGraph">needed only for statistics</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.GetAllRailsEndpoints">
            <summary>
            get endpoint tuples of all rails
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgLevel.AddRailToDictionary(Microsoft.Msagl.Layout.LargeGraphLayout.Rail)">
            <summary>
            try adding single rail to dictionary
            </summary>
            <param name="rail"></param>
            <returns>true iff the rail does not belong to _railDictionary</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.Rail">
            <summary>
            keeps a part of EdgeGeometry which is visible
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.Rail._isHighlighted">
            <summary>
            the number of higlighted edges passing through the rail
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.Rail.Geometry">
            <summary>
            can be ICurve or Arrowhead
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.Rail.CurveAttachmentPoint">
            <summary>
            the point where the edge curve touches the arrowhead
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.Rail.TopRankedEdgeInfoOfTheRail">
            <summary>
            the corresponding LgEdgeInfo
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.Rail.IsHighlighted">
            <summary>
            the number of higlighted edges passing through the rail
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph">
            <summary>
            class containing the visible part of the drawing
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph.Nodes">
            <summary>
            the set of visible nodes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph.Rails">
            <summary>
            the set of visible rails
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.LargeGraphLayout.RailGraph.Edges">
            <summary>
            the set of visible edges
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.LargeGraphLayout.Interval">
            <summary>
            represents a range of doubles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.#ctor(System.Double,System.Double)">
            <summary>
            constructor
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.#ctor(Microsoft.Msagl.Layout.LargeGraphLayout.Interval,Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.Add(System.Double)">
            <summary>
            expanding the range to hold v
            </summary>
            <param name="v"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.Start">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.End">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.Length">
            <summary>
            the length
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.Contains(System.Double)">
            <summary>
            return true if the value is inside the range
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.GetInRange(System.Double)">
            <summary>
            bringe v into the range
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.Interval.Intersects(Microsoft.Msagl.Layout.LargeGraphLayout.Interval)">
            <summary>
            returns true if and only if two intervals are intersecting
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.LargeGraphLayout.LgPathRouter.UsedEdges">
            <summary>
             debug
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine">
            <summary>
            This is the top level class driving the calculation
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.SugiyamaLayoutLogger">
            <summary>
            the Log property
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.Brandes">
            <summary>
            If set on always forces using fast but not optimal Brandes algorithm for x-coordinate assignment.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.sugiyamaSettings">
            <summary>
            the sugiyama layout settings responsible for the algorithm parameters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.Database">
            <summary>
            Keeps assorted data associated with the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.#ctor(Microsoft.Msagl.Layout.Layered.LayerArrays,Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Layered.ProperLayeredGraph,Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings,Microsoft.Msagl.Layout.Layered.Database,Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Layout.Layered.IntEdge},System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Layout.Node,System.Int32},Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Layout.Layered.IntEdge},System.Boolean,Microsoft.Msagl.Layout.Layered.ConstrainedOrdering,System.Boolean,Microsoft.Msagl.Layout.Layered.XLayoutGraph)">
            <summary>
            it is a special recovery constructor to recreate the engine from the recovery engine
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.VirtualNodeWidth">
            <summary>
            the width of dummy nodes
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.VirtualNodeHeight(Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings)">
            <summary>
            the height of dummy nodes
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Layout.Layered.IntEdge},System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Layout.Node,System.Int32},Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings)">
            <summary>
            Simpler constructor which initializes the internal graph representation automatically
            </summary>
            <param name="originalGraph"></param>
            <param name="settings"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CreateGluedDagSkeletonForLayering">
            <summary>
            Creating a DAG which glues same layer vertices into one original, 
            replacing original multiple edges with a single edge.
            upDown constraints will be added as edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.RunInternal">
            <summary>
            The main calculation is done here
            </summary>       
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.UpdateNodePositionData">
            <summary>
            pushes positions from the anchors to node Centers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.StretchWidth">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.OptimizeEdgeLabelsLocations">
            <summary>
            put some labels to the left of the splines if it makes sense
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CycleRemoval">
            <summary>
            Create a DAG from the given graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.Report(System.String)">
            <summary>
            Prints the function to the console and to the log if the log file name is given
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalculateXLayersByGansnerNorth(Microsoft.Msagl.Layout.Layered.LayerArrays)">
            <summary>
            The function calculates y-layers and x-layers, 
            thus, in fact, defining node, including dummy nodes, locations.
            </summary>
            <param name="layerArrays"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CreaeteProperLayeredGraph(System.Int32[],Microsoft.Msagl.Layout.Layered.LayerArrays@)">
            <summary>
            Creating a proper layered graph, a graph where each 
            edge goes only one layer down from the i+1-th layer to the i-th layer.
            </summary>
            <param name="layering"></param>
            <param name="layerArrays"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalcInitialYAnchorLocations(Microsoft.Msagl.Layout.Layered.LayerArrays,System.Double,Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Layered.Database,Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Layout.Layered.IntEdge},Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings,System.Boolean)">
            <summary>
            
            </summary>
            <returns>the height of the graph+spaceBeforeMargins</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayoutEngine.CalculateApproximateDimensions">
            <summary>
            try to estimate the dimensions of the ensuing layout, useful for determining if we are going
            to go through with it, or try a different layout method (e.g. if the aspect ratio is too wacky)
            </summary>
            <returns>the width and height in X and Y respectively</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine">
            <summary>
            This is almost a copy, considering the data, of LayeredLayoutEngine.
            The class restores itself from a given GeometryGraph
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.sugiyamaSettings">
            <summary>
            the sugiyama layout settings responsible for the algorithm parameters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.VirtualNodeWidth">
            <summary>
            the width of dummy nodes
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.VirtualNodeHeight(Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings)">
            <summary>
            the height of dummy nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.Database">
            <summary>
            Keeps assorted data associated with the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CreateGluedDagSkeletonForLayering">
            <summary>
            Creating a DAG which glues same layer vertices into one original, 
            replacing original multiple edges with a single edge.
            upDown constraints will be added as edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.Run">
            <summary>
            The main calculation is done here
            </summary>       
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.UpdateNodePositionData">
            <summary>
            pushes positions from the anchors to node Centers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.StretchWidth">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.OptimizeEdgeLabelsLocations">
            <summary>
            put some labels to the left of the splines if it makes sense
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CycleRemoval">
            <summary>
            Create a DAG from the given graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CalculateXLayersByGansnerNorth(Microsoft.Msagl.Layout.Layered.LayerArrays)">
            <summary>
            The function calculates y-layers and x-layers, 
            thus, in fact, defining node, including dummy nodes, locations.
            </summary>
            <param name="layerArrays"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CreateProperLayeredGraph(System.Int32[],Microsoft.Msagl.Layout.Layered.LayerArrays@)">
            <summary>
            Creating a proper layered graph, a graph where each 
            edge goes only one layer down from the i+1-th layer to the i-th layer.
            </summary>
            <param name="layering"></param>
            <param name="layerArrays"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CalcInitialYAnchorLocations(Microsoft.Msagl.Layout.Layered.LayerArrays,System.Double,Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Layered.Database,Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Layout.Layered.IntEdge},Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings,System.Boolean)">
            <summary>
            
            </summary>
            <returns>the height of the graph+spaceBeforeMargins</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RecoveryLayeredLayoutEngine.CalculateApproximateDimensions">
            <summary>
            try to estimate the dimensions of the ensuing layout, useful for determining if we are going
            to go through with it, or try a different layout method (e.g. if the aspect ratio is too wacky)
            </summary>
            <returns>the width and height in X and Y respectively</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.LayeredLayout">
            <summary>
            A facade for LayeredLayout that implements AlgorithmBase
            todo: handle progress properly
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayout.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings)">
            <summary>
            Layered layout arranged the given graph on layers inferred from the directed edge structure
            </summary>
            <param name="geometryGraph">graph to be laid out</param>
            <param name="settings">The settings for the algorithm.</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayout.EstimateAspectRatio">
            <summary>
            estimate the aspect ratio without actually doing layout
            </summary>
            <returns>width / height</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayout.RunInternal">
            <summary>
            Apply layout
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayout.RecoverAlgorithmData(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Tries to find the layers if they were there
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayeredLayout.IncrementalLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            adaptes to the node boundary curve change
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama.nodeToBlockRoot">
            <summary>
            node is mapped to the block root
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama.BlockRootToBlock">
            <summary>
            The right most node to the left of the  block is called a block root. The root does not belong to its block.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.HorizontalConstraintsForSugiyama.LeftRightIntNeibs">
            <summary>
            the set of integer pairs (i,j) such that i is a left neighbor of j
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.NetworkEdge">
            <summary>
            Differs from IntEdge in containing a flag indicating belonging to the tree
            and containing the cut value
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.NetworkSimplexForGeneralGraph.Cancel">
            <summary>
            a place holder for the cancel flag
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama">
            <summary>
            vertical constraints for Suquiyama scheme
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.MaxLayerOfGeomGraph">
            <summary>
            nodes that are pinned to the max layer
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.MinLayerOfGeomGraph">
            <summary>
            nodes that are pinned to the min layer
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.SameLayerConstraints">
            <summary>
            set of couple of nodes belonging to the same layer
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.UpDownConstraints">
            <summary>
            set of node couples such that the first node of the couple is above the second one
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.PinNodeToMaxLayer(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            pins a node to max layer
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.UnpinNodeFromMaxLayer(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            unpins a node from max layer
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.PinNodeToMinLayer(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            pins a node to min layer
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.UnpinNodeFromMinLayer(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            unpins a node from min layer
            </summary>
            <param name="node"></param>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.gluedIntGraph">
            <summary>
            this graph is obtained from intGraph by glueing together same layer vertices
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.sameLayerDictionaryOfRepresentatives">
            <summary>
            Maps each node participating in same layer relation its representative on the layer.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.GlueSameLayerNodesOfALayer(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            maps all nodes of the component to one random representative
            </summary>
            <param name="sameLayerNodes"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.VerticalConstraintsForSugiyama.SameLayerInts">
            <summary>
            contains also pinned max and min pairs
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.P">
            <summary>
            for each vertex v let P[v] be the array of predeccessors of v
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.POrder">
            <summary>
            The array contains a dictionary per vertex
            The value POrder[v][u] gives the offset of u in the array P[v]
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.S">
            <summary>
            for each vertex v let S[v] be the array of successors of v
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.SOrder">
            <summary>
            The array contains a dictionary per vertex
            The value SOrder[v][u] gives the offset of u in the array S[v]
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.MaxNumberOfAdjacentExchanges">
            <summary>
            Gets or sets the number of of passes over all layers to run
            adjacent exchanges, where every pass goes
            all way up to the top layer and down to the lowest layer
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.CalcPair(System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            calculates the number of intersections between edges adjacent to u and v
            </summary>
            <param name="u">a vertex</param>
            <param name="v">a vertex</param>
            <param name="cuv">the result when u is to the left of v</param>
            <param name="cvu">the result when v is to the left of u</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.CountOnArrays(System.Int32[],System.Int32[],System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            every inversion between unbs and vnbs gives an intersecton
            </summary>
            <param name="unbs">neighbors of u but only from one layer</param>
            <param name="vnbs">neighbors of v from the same layers</param>
            <returns>number of intersections when u is to the left of v</returns>
            <param name="uCrossingCounts"></param>
            <param name="vCrossingCount"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.InitArrays">
            <summary>
            Is called just after median layer swap is done
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.AdjacentSwapToTheRight(System.Int32[],System.Int32)">
            <summary>
            swaps i-th element with i+1
            </summary>
            <param name="layer">the layer to work on</param>
            <param name="i">the position to start</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.AdjacentSwapsWithConstraints.InitPSArraysForLayer(System.Int32[])">
            <summary>
            Sweep layer from left to right and fill S,P arrays as we go.
            The arrays P and S will be sorted according to X. Note that we will not keep them sorted
            as we doing adjacent swaps. Initial sorting only needed to calculate initial clr,crl values.
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.CreateVerticalComponents">
            <summary>
            These blocks are connected components in the vertical constraints. They don't necesserely span consequent layers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetFixedBlockNode(System.Int32,Microsoft.Msagl.Layout.Layered.LayerInfo,Microsoft.Msagl.Layout.Layered.SweepMode)">
            <summary>
            
            </summary>
            <param name="blockRoot"></param>
            <param name="layerInfo"></param>
            <param name="sweepMode"></param>
            <returns>-1 if no node is constrained</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.ConstrainedOrdering.GetOrCreateLayerInfo(System.Int32)">
            <summary>
            when we call this function we know that a LayerInfo is needed
            </summary>
            <param name="layerNumber"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.MetroMapOrdering">
            <summary>
            Following "Improving Layered Graph Layouts with Edge Bundling" and
            "Two polynomial time algorithms for the bundle-Line crossing minimization problem"
            Postprocessing minimizing crossings step that works on the layered graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.MetroMapOrdering.UpdateLayerArrays(Microsoft.Msagl.Layout.Layered.ProperLayeredGraph,Microsoft.Msagl.Layout.Layered.LayerArrays,System.Collections.Generic.Dictionary{System.Int32,Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            Reorder only points having identical nodePositions
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.MetroMapOrdering.UpdateLayerArrays(Microsoft.Msagl.Layout.Layered.ProperLayeredGraph,Microsoft.Msagl.Layout.Layered.LayerArrays)">
            <summary>
            Reorder virtual nodes between the same pair of real nodes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.LayerInfo.leftRight">
            <summary>
            constrained on the level of neighBlocks
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.LayerInfo.blockRootToVertConstrainedNodeOfBlock">
            <summary>
            if the block contains a fixed node v,  it can be only one because of the monotone paths feature,
            then blockToFixedNodeOfBlock[block]=v
            /// </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph">
            <summary>
            a class representing a graph where every edge goes down only one layer
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.BaseGraph">
            <summary>
            the underlying basic graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.Edges">
            <summary>
            enumerates over the graph edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.InEdges(System.Int32)">
            <summary>
            enumerates over edges of a node
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.OutEdges(System.Int32)">
            <summary>
            enumerates over the node outcoming edges
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.InEdgesCount(System.Int32)">
            <summary>
            returns the number of incoming edges for an edge
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.OutEdgesCount(System.Int32)">
            <summary>
            returns the number of outcoming edges for an edge
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.ProperLayeredGraph.NodeCount">
            <summary>
            returns the node count
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.LayerCalculator">
            <summary>
            the basis class for layering algorithms
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerCalculator.GetLayers">
            <summary>
            the main method
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.LongestPathLayering">
            <summary>
            Layering the DAG by longest path
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.NetworkSimplex">
            <summary>
            The algorithm follows "A technique for Drawing Directed Graphs", Gansner, Koutsofios, North, Vo.
            Consider re-implement this algorithm following Chvatal. The algorithm works for a connected graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.FeasibleTree">
            <summary>
            The function FeasibleTree constructs an initial feasible spanning tree.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.VertexSourceTargetVal(System.Int32,Microsoft.Msagl.Layout.Layered.NetworkEdge)">
            <summary>
            treeEdge, belonging to the tree, divides the vertices to source and target components
            If v belongs to the source component we return 1 oterwise we return 0
            </summary>
            <param name="v">a v</param>
            <param name="treeEdge">a vertex</param>
            <returns>an edge from the tree</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.IncidentEdges(System.Int32)">
            <summary>
            a convenient wrapper of IncEdges
            </summary>
            <param name="v"></param>
            <returns>edges incident to v</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.EdgeSourceTargetVal(Microsoft.Msagl.Layout.Layered.NetworkEdge,Microsoft.Msagl.Layout.Layered.NetworkEdge)">
            <summary>
            treeEdge, belonging to the tree, divides the vertices to source and target components
            e does not belong to the tree . If e goes from the source component to target component 
            then the return value is 1,
            if e goes from the target component ot the source then the return value is -1
            otherwise it is zero
            </summary>
            <param name="e">a non-tree edge</param>
            <param name="treeEdge">a tree edge</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.InitCutValues">
            <summary>
            The init_cutvalues function computes the cut values of the tree edges.
            For each tree edge, this is computed by marking the nodes as belonging to the source or 
            target component, and then performing the sum of the signed weights of all 
            edges whose source and target are in different components, the sign being negative for those edges 
            going from the source to the target component.
            To reduce this cost, we note that the cut values can be computed using information local to an edge 
            if the search is ordered from the leaves of the feasible tree inward. It is trivial to compute the 
            cut value of a tree edge with one of its endpoints a leaf in the tree, 
            since either the source or the target component consists of a single node. 
            Now, assuming the cut values are known for all the edges incident on a given 
            node except one, the cut value of the remaining edge is the sum of the known cut 
            values plus a term dependent only on the edges incident to the given node.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.EdgeContribution(Microsoft.Msagl.Layout.Layered.NetworkEdge,System.Int32)">
            <summary>
            e is a tree edge for which the cut has been calculted already.
            EdgeContribution gives an amount that edge e brings to the cut of parent[w].
            The contribution is the cut value minus the weight of e. Let S be the component of e source. 
            We should also substruct W(ie) for every ie going from S to w and add W(ie) going from w to S.
            These numbers appear in e.Cut but with opposite signs.
            </summary>
            <param name="e">tree edge</param>
            <param name="w">parent[w] is in the process of the cut calculation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.InitLimLowAndParent">
            <summary> 
            A quote:
            Another valuable optimization, similar to a technique described in [Ch],
            is to perform a postorder traversal of the tree, starting from some fixed 
            root node vroot, and labeling each node v with its postorder 
            traversal number lim(v), the least number low(v) of any descendant in the search, 
            and the edge parent(v) by which the node was reached (see figure 2-5).
            This provides an inexpensive way to test whether a node lies in the 
            source or target component of a tree edge, and thus whether a non-tree edge 
            crosses between the two components. For example, if e = (u,v) is a 
            tree edge and vroot is in the source component of the edge (i.e., lim(u) less lim(v)), 
            then a node w is in the target component of e if and only if low(u) is less or equal than lim(w) 
            is less or equal than lim(u). These numbers can also be used to update the tree efficiently 
            during the network simplex iterations. If f = (w,x) is the entering edge, the 
            only edges whose cut values must be adjusted are those in the path 
            connecting w and x in the tree. This path is determined by following 
            the parent edges back from w and x until the least common ancestor is reached, 
            i.e., the first node l such that low(l) is less or equal lim(w) than ,
            lim(x) is less or equal than lim(l). 
            Of course, these postorder parameters must also be adjusted when 
            exchanging tree edges, but only for nodes below l.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.InitLowLimParentAndLeavesOnSubtree(System.Int32@,System.Int32@)">
            <summary>
            initializes lim and low in the subtree 
            </summary>
            <param name="curLim">the root of the subtree</param>
            <param name="v">the low[v]</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.UpdateLimLowLeavesAndParentsUnderNode(System.Int32)">
            <summary>
            here we update values lim and low for the subtree with the root l
            </summary>
            <param name="l"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.GetNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack">
            <summary>
            one of the returned edge vertices does not belong to the tree but another does
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.TightTree">
            <summary>
            The function TightTree finds a maximal tree of tight edges containing 
            some fixed node and returns the number of nodes in the tree. 
            Note that such a maximal tree is just a spanning tree for the subgraph 
            induced by all nodes reachable from the fixed node in the underlying 
            undirected graph using only tight edges. In particular, all such trees have the same number of nodes.
            The function also builds the tree.
            </summary>
            <returns>number of verices in a tight tree</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.NetworkSimplex.Exchange(Microsoft.Msagl.Layout.Layered.NetworkEdge,Microsoft.Msagl.Layout.Layered.NetworkEdge)">
            <summary>
            If f = (w,x) is the entering edge, the 
            only edges whose cut values must be adjusted are those in the path 
            connecting w and x in the tree, excluding e. This path is determined by 
            following the parent edges back from w and x until the least common ancestor is 
            reached, i.e., the first node l such that low(l) less or equal lim(w) ,lim(x) less or equal lim(l). 
            Of course, these postorder parameters must also be adjusted when 
            exchanging tree edges, but only for nodes below l.
            </summary>
            <param name="e">exiting edge</param>
            <param name="f">entering edge</param>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.NetworkSimplex.IncEdges">
            <summary>
            to enumerate over all edges incident to v
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.Ordering">
            <summary>
            Following "A technique for Drawing Directed Graphs" of Gansner, Koutsofios, North and Vo
            Works on the layered graph. For explanations of the algorithm here see GraphLayout.pdf.
            </summary>
            <summary>
            Following "A technique for Drawing Directed Graphs" of Gansner, Koutsofios, North and Vo
            Works on the layered graph. Also see GraphLayout.pdf
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Ordering.predecessors">
            <summary>
            for each vertex v let P[v] be the array of predeccessors of v
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Ordering.pOrder">
            <summary>
            The array contains a dictionary per vertex
            The value POrder[v][u] gives the offset of u in the array P[v]
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Ordering.successors">
            <summary>
            for each vertex v let S[v] be the array of successors of v
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Ordering.sOrder">
            <summary>
            The array contains a dictionary per vertex
            The value SOrder[v][u] gives the offset of u in the array S[v]
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Ordering.MaxNumberOfAdjacentExchanges">
            <summary>
            Gets or sets the number of of passes over all layers to rung adjacent exchanges, where every pass goes '
            all way up to the top layer and down to the lowest layer
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.InitArrays">
            <summary>
            Is called just after median layer swap is done
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.CalcPair(System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            calculates the number of intersections between edges adjacent to u and v
            </summary>
            <param name="u">a vertex</param>
            <param name="v">a vertex</param>
            <param name="cuv">the result when u is to the left of v</param>
            <param name="cvu">the result when v is to the left of u</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.InitPsArraysForLayer(System.Int32[])">
            <summary>
            Sweep layer from left to right and fill S,P arrays as we go.
            The arrays P and S will be sorted according to X. Note that we will not keep them sorted
            as we doing adjacent swaps. Initial sorting only needed to calculate initial clr,crl values.
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.CountOnArrays(System.Int32[],System.Int32[],System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            every inversion between unbs and vnbs gives an intersecton
            </summary>
            <param name="unbs">neighbors of u but only from one layer</param>
            <param name="vnbs">neighbors of v from the same layers</param>
            <returns>number of intersections when u is to the left of v</returns>
            <param name="uCrossingCounts"></param>
            <param name="vCrossingCount"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.AdjacentSwapToTheRight(System.Int32[],System.Int32)">
            <summary>
            swaps i-th element with i+1
            </summary>
            <param name="layer">the layer to work on</param>
            <param name="i">the position to start</param>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Ordering.random">
            <summary>
            this field is needed to randomly choose between transposing
            and not transposing in the adjacent exchange
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Ordering.SeedOfRandom">
            <summary>
            gets the random seed for some random choices inside of layer ordering
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Ordering.MaxOfIterations">
            <summary>
            an upper limit on a number of passes in layer ordering
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.SweepLayer(System.Int32,System.Boolean)">
            <summary>
            the layer layer-1 is fixed if 
            upperLayer us true and layer+1 is fixed in 
            the opposite case
            the layer with index "layer" is updated    
            </summary>
            <param name="layer"></param>
            <param name="upperLayer">upperLayer means if "layer" is the upperLayer 
            of the strip</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.Sort(System.Int32,System.Single[])">
            <summary>
            sorts layerToSort according to medianValues
            if medianValues[i] is -1 then layer[i] does not move
            </summary>
            <param name="layerToSort"></param>
            <param name="medianValues"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Ordering.Init">
            <summary>
            Just depth search and assign the index saying when the node was visited
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.EdgePathsInserter">
            <summary>
            This class is used in the case when there are multiple edges, but there is no need to dublicate layers.
            We just insert dummy nodes for edge middles without distorting the order of vertices in the layers.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutLogger">
            <summary>
            Log class
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutLogger.Dispose">
            <summary>
            disposes the object
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutLogger.Write(System.String)">
            <summary>
            writes a message to the log file
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.LayerInserter">
            <summary>
            Preparing the graph for x-coordinate calculation by inserting dummy nodes into the layers
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.LayerInserter.layeredGraph">
            <summary>
            Old layered graph: 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.LayerInserter.nLayeredGraph">
            <summary>
            new layered graph 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.LayerInserter.la">
            <summary>
            old layer arrays
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.LayerInserter.nla">
            <summary>
            new layer arrays
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.#ctor(Microsoft.Msagl.Layout.Layered.ProperLayeredGraph,Microsoft.Msagl.Layout.Layered.LayerArrays,Microsoft.Msagl.Layout.Layered.Database,Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Layout.Layered.IntEdge})">
            <summary>
            constructor
            </summary>
            <param name="layeredGraph"></param>
            <param name="la"></param>
            <param name="database"></param>
            <param name="intGraphP"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayerInserter.NLayering">
            <summary>
            new Y-layering
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.InsertLayers">
            <summary>
            does the main work
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.EditOldLayering">
            <summary>
            virtual nodes inside of an edge should be of the form i,i+1, ....
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.WidenOriginalLayers">
            <summary>
            Original layers are represented by even layers in the new layering.
            Here we add new virtices in such layers and 
            set new x-offsets of original and dummy vertices in these layers.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.FillUnsortedNewOddLayers">
            <summary>
            filling new layers not corresponding to the original layers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.MapVirtualNodesToEdges">
            <summary>
            create the mapping from the vertices to edges to which they belong
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.CreateFullLayeredGraph">
            <summary>
            Creating buckets for multi edges and allocating the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.SortNewOddLayers">
            <summary>
            Sort new odd layers by the sum of x-coordinatates of predecessors and the successors of 
            dummy nodes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerInserter.InitNewLayering">
            <summary>
            Allocating new layering and filling its y-layers
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.Balancing">
            <summary>
            balances the layers by moving vertices with
            the same number of input-output edges to feasible layers with fewer nodes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Balancing.vertsCounts">
            <summary>
            numbers of vertices in layers 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Balancing.Balance(Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Layout.Layered.IntEdge},System.Int32[],System.Int32[],Microsoft.Msagl.Core.CancelToken)">
            <summary>
            balances the layers by moving vertices with
            the same number of input-output edges to feasible layers with fiewer nodes  /// </summary>
            <param name="dag">the layered graph</param>
            <param name="layering">the layering to change</param>
            <param name="nodeCount">shows how many nodes are represented be a node</param>
            <param name="cancelObj"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Balancing.UpdateRegionsForPossibleJumpersAndInsertJumpers(System.Int32,System.Int32)">
            <summary>
            some other jumpers may stop being ones if the jump 
            was just in to their destination layer, so before the actual 
            jump we have to recheck if the jump makes sense
            
            </summary>
            <param name="jumperLayer">old layer of jumper</param>
            <param name="jumper"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Balancing.CalcJumpInfo(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            layerToJumpTo is -1 if there is no jump
            </summary>
            <param name="upLayer"></param>
            <param name="lowLayer"></param>
            <param name="jumper"></param>
            <param name="jumperLayer"></param>
            <param name="layerToJumpTo"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Balancing.Up(System.Int32)">
            <summary>
            Up returns the first infeasible layer up from i that i cannot jump to
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Balancing.Down(System.Int32)">
            <summary>
            Returns the first infeasible layer down from i that i cannot jump to
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.Database">
            <summary>
            This class holds assorted data associated with the graph under layout: list of anchors, 
            edges sorted by their sources,targets etc
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Database.multipleMiddles">
            <summary>
            maps middles of multiple strings to their buckets
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.Database.multiedges">
            <summary>
            This table keeps multi edges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Database.Anchors">
            <summary>
            Anchors of the nodes
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.IntEdge">
            <summary>
            An edge with source and target represented as integers, they point to an array of Nodes of the graph
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.Source">
            <summary>
            the source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.Target">
            <summary>
            the edge target
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.Reversed">
            <summary>
            An edge can be reversed to keep the graph acyclic
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.IsVirtualEdge">
            <summary>
            A dummy edge that will not be drawn; serves just as a place holder.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.#ctor(System.Int32,System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.HasLabel">
            <summary>
            Returns true if the edge has label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.LabelWidth">
            <summary>
            Label width
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.LabelHeight">
            <summary>
            Label height
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.Revert">
            <summary>
            This function changes the edge by swapping 
            source and target. However Revert(Revert) does not change it.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.Edge">
            <summary>
            The original edge corresponding to the IntEdge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.#ctor(System.Int32,System.Int32,Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            constructor
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.Equals(System.Object)">
            <summary>
            compares only source and target
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.Separation">
            <summary>
            the distance between the source and the target in the number of layers
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.LayerSpan">
            <summary>
            the edge span in layers
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.IntEdge.LayerEdges">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.GetEnumerator">
            <summary>
            enumerates over virtual virtices corresponding to the original edge
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.IntEdge.GetOrder(Microsoft.Msagl.Core.GraphAlgorithms.BasicGraph{Microsoft.Msagl.Layout.Layered.IntEdge})">
            <summary>
            The function returns an array arr such that
            arr is a permutation of the graph vertices,
            and for any edge e in graph if e.Source=arr[i]
            e.Target=arr[j], then i is less than j
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.LayerArrays">
            <summary>
            Keeps all information about the hierarchy of layers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerArrays.DropEmptyLayers">
            <summary>
            Returns the same arrays but with no empty layers.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayerArrays.X">
            <summary>
            gives the order of the vertices in the y-layer
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerArrays.ReversedClone">
            <summary>
            returns the layer hierarchy where the order of the layers is reversed
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayerArrays.Layers">
            <summary>
            Layers[i] is the array of vertices of i-th layer
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings">
            <summary>
            controls many properties of the layout algorithm
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.LayerSeparation">
            <summary>
            Separation between to neighboring layers
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AddLeftRightConstraint(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            adds a constraint to keep one node to the left of another on the same layer
            </summary>
            <param name="leftNode"></param>
            <param name="rightNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.RemoveLeftRightConstraint(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            removes a left-right constraint from
            </summary>
            <param name="leftNode"></param>
            <param name="rightNode"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.VerticalConstraints">
            <summary>
            minLayer, maxLayer, same layer, up-down, up-down vertical and left-right constraints are supported by this class
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.PinNodesToMaxLayer(Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
            Pins the nodes of the list to the max layer and 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.PinNodesToMinLayer(Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
            Pins the nodes of the list to the min layer and 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.PinNodesToSameLayer(Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
            adds a same layer constraint
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AddSameLayerNeighbors(Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
            these nodes belong to the same layer and are adjacent positioned from left to right
            </summary>
            <param name="neighbors"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AddSameLayerNeighbors(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node})">
            <summary>
            these nodes belong to the same layer and are adjacent positioned from left to right
            </summary>
            <param name="neighbors"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AddSameLayerNeighbors(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            adds a pair of adjacent neighbors
            </summary>
            <param name="leftNode"></param>
            <param name="rightNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.RemoveAllConstraints">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AddUpDownConstraint(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            adds an up-down constraint to the couple of nodes
            </summary>
            <param name="upperNode"></param>
            <param name="lowerNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AddUpDownVerticalConstraint(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            adds a constraint where the top node center is positioned exactly above the lower node center
            </summary>
            <param name="upperNode"></param>
            <param name="lowerNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AddUpDownVerticalConstraints(Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
            adds vertical up down constraints udDownIds[0]->upDownIds[1]-> ... -> upDownsIds[upDownIds.Length-1]
            </summary>
            <param name="upDownNodes"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.LayeringOnly">
            <summary>
            if set to true the algorithm only calculates the layers and exits
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.RepetitionCoefficientForOrdering">
            <summary>
            This coefficient if set to the value greater than 1 will force the algorithm to search for layouts with fewer edge crossings 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.RandomSeedForOrdering">
            <summary>
            The seed for the random element inside of the ordering
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.NoGainAdjacentSwapStepsBound">
            <summary>
            Maximal number of sequential steps without gain in the adjacent swap process
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.MaxNumberOfPassesInOrdering">
            <summary>
            Maximal number of passes over layers applying the median algorithm in ordering
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.GroupSplit">
            <summary>
            The ratio of the group splitting algorithm used in the spatial hierarchy constructions for edge routing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.LabelCornersPreserveCoefficient">
            <summary>
            We create a hexagon for a label boundary: this coeffiecient defines the ratio of the top and the bottom side to the width of the label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.BrandesThreshold">
            <summary>
            When the number of vertices in the proper layered graph is the threshold or more we switch to
            the faster, but not so accurate, method for x-coordinates calculations.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.CalculateLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings,Microsoft.Msagl.Core.CancelToken)">
            <summary>
            The only function one needs to call to calculate the layout.
            </summary>
            <param name="msaglGraph">The layout info will be inserted in to the corresponding fields of the graph</param>
            <param name="settings">The settings for the algorithm.</param>
            <param name="cancelToken"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.MinimalWidth">
            <summary>
            The resulting layout should be not more narrow than this value. 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.MinimalHeight">
            <summary>
            The resulting layout should at least as high as this this value
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.MinNodeHeight">
            <summary>
            The minimal node height
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.MinNodeWidth">
            <summary>
            The minimal node width
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.Transformation">
            <summary>
            This transformation is to be applied to the standard top - bottom layout.
            However, node boundaries remain unchanged.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.AspectRatio">
            <summary>
            The ratio width/height of the final layout. 
            The value zero means that the aspect ratio has not been set.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.MaxAspectRatioEccentricity">
            <summary>
            InitialLayoutByCluster requires the layered layout aspect ratio
            to be in the range [1/MaxAspectRatioEccentricity, MaxAspectRatioEccentricity]
            before switching to FallbackLayoutSettings
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings.FallbackLayoutSettings">
            <summary>
            If the aspect ratio of Layered layout is too slow, use the following layout settings instead
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.Anchor">
             <summary>
             Defines the anchors for a node; anchors can be not symmetrical in general
             
                      |TopAnchor
            Left anchor|
             ======Origin==================RightAnchor
                      |
                      |
                      |BottomAnchor
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Anchor.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.LeftAnchor">
            <summary>
            distance for the center of the node to its left boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.RightAnchor">
            <summary>
            distance from the center of the node to its right boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.TopAnchor">
            <summary>
            distance from the center of the node to its top boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.BottomAnchor">
            <summary>
            distance from the center of the node to it bottom boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Left">
            <summary>
            Left boundary of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Right">
            <summary>
            right boundary of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Top">
            <summary>
            top boundary of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Bottom">
            <summary>
            bottom of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.LeftTop">
            <summary>
            Left top corner
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.LeftBottom">
            <summary>
            Left bottom of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.RightBottom">
            <summary>
            Right bottom of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.RightTop">
            <summary>
            Right top of the node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Anchor.#ctor(System.Double)">
            <summary>
            an empty constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Anchor.#ctor(System.Double,System.Double,System.Double,System.Double,Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.X">
            <summary>
            the x position
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Y">
            <summary>
            the y position
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Origin">
            <summary>
            Center of the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.AlreadySitsOnASpline">
            <summary>
            signals if the spline has been routed already through the node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Width">
            <summary>
            node widths
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Height">
            <summary>
            node height
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.RepresentsLabel">
            <summary>
            set to true if the anchor has been introduced for a label
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.LabelToTheLeftOfAnchorCenter">
            <summary>
            An anchor for an edge label with the label to the right of the spline has its height equal to the one of the label
            Its leftAnchor is a reserved space for the spline and the rightAnchor is equal to the label width.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.LabelToTheRightOfAnchorCenter">
            <summary>
            An anchor for an edge label with the label to the left of the spline has its height equal to the one of the label
            Its rightAnchor is a reserved space for the spline and the leftAnchor is equal to the label width.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.PolygonalBoundary">
            <summary>
            the polygon representing the boundary of a node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Anchor.GetPaddedCorner(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Point@,Microsoft.Msagl.Core.Geometry.Point@,System.Double)">
            <summary>
            
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <param name="third"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="padding"></param>
            <returns>number of new points</returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.Anchor.Padding">
            <summary>
            node padding
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.LayerEdge">
            <summary>
            This is an edge going down only one layer.
            It points to the original edge that can pass several layers
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayerEdge.Source">
            <summary>
            the source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayerEdge.Target">
            <summary>
            the target
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerEdge.Equals(System.Object)">
            <summary>
            overrides the equlity
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerEdge.GetHashCode">
            <summary>
            overrides GetHashCode
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Layered.LayerEdge.CrossingWeight">
            <summary>
            it is equalt to the number of edges this edge represents 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.LayerEdge.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.SuccEnumerator">
            <summary>
            Enumerator of the vertex successors
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.PredEnumerator">
            <summary>
            Enumeration of the vertex predecessors
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.XLayoutGraph">
            <summary>
            Follows the idea from Gansner etc 93, creating a special graph
            for x-coordinates calculation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XLayoutGraph.EdgeWeightMultiplier(Microsoft.Msagl.Layout.Layered.IntEdge)">
            <summary>
            following Gansner etc 93 returning weight multplier bigger if there are virtual nodes
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XLayoutGraph.SetEdgeWeights">
            <summary>
            caching edges weights
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.OrderingMeasure.optimalOriginalGroupSize">
            <summary>
            for the i-th layer the optimal size of an original group is optimalOriginalGroupSize[i]
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.OrderingMeasure.optimalVirtualGroupSize">
            <summary>
            for the i-th layer the optimal size of a virtual group is optimalOriginalGroupSize[i]
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.RefinerBetweenTwoLayers.CalculateNewBottomSite">
            <summary>
            circimvating from the side
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.Routing">
            <summary>
            The class responsible for the routing of splines
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Routing.RunInternal">
            <summary>
            Executes the actual algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.Routing.CreateSplines">
            <summary>
            The method does the main work.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.SmoothedPolylineCalculator.#ctor(Microsoft.Msagl.Layout.Layered.IntEdge,Microsoft.Msagl.Layout.Layered.Anchor[],Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings,Microsoft.Msagl.Layout.Layered.LayerArrays,Microsoft.Msagl.Layout.Layered.ProperLayeredGraph,Microsoft.Msagl.Layout.Layered.Database)">
            <summary>
            Creates a smoothed polyline
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.TwoLayerFlatEdgeRouter.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment">
            <summary>
            The implementation follows "Fast and Simple Horizontal Coordinate Assignment" of Ulrik Brandes and Boris K¨opf
            The paper has two serious bugs that this code resolves.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.LR">
            <summary>
            from left to right
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.BT">
            <summary>
            from bottom to top
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.IsVirtual(System.Int32)">
            <summary>
            Returns true if v is a virtual vertex
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.CalculateXCoordinates(Microsoft.Msagl.Layout.Layered.LayerArrays,Microsoft.Msagl.Layout.Layered.ProperLayeredGraph,System.Int32,Microsoft.Msagl.Layout.Layered.Anchor[],System.Double)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.ConflictElimination">
            <summary>
            The code is written as if we go left up, but in fact the settings define the directions.
            
            We need to create a subgraph for alignment:
            where no edge segments intersect, and every vertex has
            at most one incoming and at most one outcoming edge.
            This function marks edges to resolve conflicts with only one inner segment.  
            An inner segment is a segment between two dummy nodes.
            We mark edges that later will not participate in the alignment. 
            Inner segments are preferred to other ones. So, in a conflict with one inner and one
            non-inner edges we leave the inner edge to participate in the alignment. 
            At the moment we mark as not participating both of the two intersecting inner segments
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.MarkConflictingEdges">
            <summary>
            here we eliminate all constraints 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.NextUpper(System.Int32)">
            <summary>
            parameterized next upper 
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.NextLower(System.Int32)">
            <summary>
            parameterized next lower
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.UpperOf(System.Int32,System.Int32)">
            <summary>
            parameterize highest of two numbers
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.LowerOf(System.Int32,System.Int32)">
            <summary>
            parameterized lowest of a pair
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.IsBelow(System.Int32,System.Int32)">
            <summary>
            returns parameterized below
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.LeftMost(System.Int32,System.Int32)">
            <summary>
            returns the "parameterized" left of the two positions
            </summary>
            <param name="pos0"></param>
            <param name="pos1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.RightMost(System.Int32,System.Int32)">
            <summary>
            returns the "parameterized" right of the two positions
            </summary>
            <param name="pos0"></param>
            <param name="pos1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.RightMost(System.Double,System.Double)">
            <summary>
            returns the "parameterized" right of the two positions
            </summary>
            <param name="pos0"></param>
            <param name="pos1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.IsNotRightFrom(System.Int32,System.Int32)">
            <summary>
            Return true if i is to the left or equal to pos in a "parameterized" fasion
            </summary>
            <param name="i"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.IsLeftFrom(System.Int32,System.Int32)">
            <summary>
            Parameterized left relation
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.NextRight(System.Int32)">
            <summary>
            parameterized next right
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.NextLeft(System.Int32)">
            <summary>
            parameterized next left
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.Align">
             <summary>
            Calculate the alignment based on the marked edges and greedily resolving the remaining conflicts on the fly, without marking
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.TryToGetRightNeighbor(System.Int32,System.Int32@)">
            <summary>
            returns true is u has a right neighbor on its layer
            </summary>
            <param name="u"></param>
            <param name="neighbor"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.TryToGetLeftNeighbor(System.Int32,System.Int32@)">
            <summary>
            returns true is u has a right neighbor on its layer
            </summary>
            <param name="u"></param>
            <param name="neighbor"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.CreateBlocks">
            <summary>
            Organizes the vertices into blocks. A block is a maximal path in the alignment subgraph. 
            The alignment is defined by array align. Every vertex is connected to the top vertex of 
            the block by using root array. The alignment is cyclic. If we start from a root vertex v and 
            apply align then we return to v at some point.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.infinity">
            <summary>
            Assigning xcoords starting from roots
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Layered.XCoordsWithAlignment.DeltaBetweenVertices(System.Int32,System.Int32)">
            <summary>
            Calculates the minimum separation between two neighboring vertices: if u is to the left of v on the same layer return positive
            number, otherwise negative.
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.OverlapRemovalFixedSegments.OverlapRemovalFixedSegmentsMst.GetShiftUntilOverlap(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            vector to shift box2 along the line between the centers until overlap
            </summary>
            <param name="box1"></param>
            <param name="box2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.OverlapRemovalFixedSegments.OverlapRemovalFixedSegmentsMst.GetShiftUntilNoLongerOverlap(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            vector to shift box2 along the line between the centers until no longer overlap
            </summary>
            <param name="box1"></param>
            <param name="box2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.OverlapRemovalFixedSegments.RectSegIntersection.ClosestPointOnSegment(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            closest point on the segment
            </summary>
            <param name="p1">first endpoint</param>
            <param name="p2">second endpoint</param>
            <param name="x">reference point</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.MDS.AllPairsDistances">
            <summary>
            Algorithm for computing the distance between every pair of nodes in a graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.AllPairsDistances.Result">
            <summary>
            The resulting distances between every pair of nodes in the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.AllPairsDistances.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Boolean)">
            <summary>
            Computes distances between every pair of nodes in a graph.
            Distances are symmetric if the graph is undirected.
            </summary>
            <param name="graph">A graph.</param>
            <param name="directed">Whether shortest paths are directed.</param>
            <returns>A square matrix with shortest path distances.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.AllPairsDistances.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.AllPairsDistances.Stress(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Computes the "stress" of the current layout of the given graph:
            
              stress = sum_{(u,v) in V} D(u,v)^(-2) (d(u,v) - D(u,v))^2
            
            where:
              V is the set of nodes
              d(u,v) is the euclidean distance between the centers of nodes u and v
              D(u,v) is the graph-theoretic path length between u and v - scaled by average edge length.
              
            The idea of “stress” in graph layout is that nodes that are immediate neighbors should be closer 
            together than nodes that are a few hops apart (i.e. that have path length>1).  More generally 
            the distance between nodes in the drawing should be proportional to the path length between them.  
            The lower the “stress” score of a particular graph layout the better it conforms to this ideal.
            
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.MDS.PivotDistances">
            <summary>
            An algorithm for computing the distances between a selected set of nodes and all nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.PivotDistances.Result">
            <summary>
            A square matrix with shortest path distances.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.PivotDistances.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Boolean,System.Int32[])">
            <summary>
            Computes distances between a selected set of nodes and all nodes.
            Pivot nodes are selected with maxmin strategy (first at random, later
            ones to maximize distances to all previously selected ones).
            </summary>
            <param name="graph">A graph.</param>
            <param name="directed">Whether shortest paths are directed.</param>
            <param name="pivotArray">Number of pivots.</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.PivotDistances.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.MDS.PivotMDS">
            <summary>
            Initial layout using PivotMDS method for FastIncrementalLayout
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.PivotMDS.Scale">
            <summary>
            scales the final layout by the specified factor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.PivotMDS.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Layout graph by the PivotMds method.  Uses spectral techniques to obtain a layout in
            O(n^2) time.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.PivotMDS.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
            <summary>
            Executes the actual algorithm.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings">
            <summary>
            MDL layout settings
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.#ctor">
            <summary>
            the setting of Multi-Dimensional Scaling layout
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.RunInParallel">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.RemoveOverlaps">
            remove overlaps between node boundaries
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.PivotNumber">
            <summary>
            Number of pivots in Landmark Scaling (between 3 and number of objects).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.IterationsWithMajorization">
            <summary>
            Number of iterations in distance scaling
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ScaleX">
            <summary>
            X Scaling Factor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.ScaleY">
            <summary>
            Y Scaling Factor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.Exponent">
            <summary>
            Weight matrix exponent.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.RotationAngle">
            <summary>
            rotation angle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.IdealEdgeLength">
            <summary>
            Settings for calculation of ideal edge length
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.AdjustScale">
            <summary>
            Adjust the scale of the graph if there is not enough whitespace between nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.MdsLayoutSettings.OverlapRemovalMethod">
            <summary>
            The method which should be used to remove the overlaps.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.MDS.SingleSourceDistances">
            <summary>
            Provides functionality for computing distances in a graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.SingleSourceDistances.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.Node,System.Boolean)">
            <summary>
            Dijkstra algorithm. Computes graph-theoretic distances from a node to
            all other nodes in a graph with nonnegative edge lengths.
            The distance between a node and itself is 0; the distance between a pair of
            nodes for which no connecting path exists is Double.PositiveInfinity.
            </summary>
            <param name="graph">A graph.</param>
            <param name="source">The source node.</param>
            <param name="directed">Whether the graph is directed.</param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.MDS.SingleSourceDistances.Result">
            <summary>
            An array of distances from the source node to all nodes.
            Nodes are indexed in their natural order when iterating over them.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.SingleSourceDistances.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.SingleSourceDistances.ComponentGraphs(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Layout.Node,System.Int32})">
            <summary>
            Gives graphs representing the connected components of the graph
            </summary>
            <param name="graph">A graph.</param>
            <param name="nodeToNodeIndex">the dictionary: node -> node index in the NodeMap</param>
            <returns>An array of connected components.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.MDS.MdsGraphLayout">
            <summary>
            Class for graph layout with multidimensional scaling.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsGraphLayout.#ctor(Microsoft.Msagl.Layout.MDS.MdsLayoutSettings,Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Constructs the multidimensional scaling algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsGraphLayout.RunInternal">
            <summary>
            Executes the algorithm
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsGraphLayout.ScaleToAverageEdgeLength(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double[],System.Double[])">
            <summary>
            Scales a configuration such that the average edge length in the drawing
            equals the average of the given edge lengths.
            </summary>
            <param name="g">A graph.</param>
            <param name="x">Coordinates.</param>
            <param name="y">Coordinates.</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsGraphLayout.LayoutGraphWithMds(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.MDS.MdsLayoutSettings,System.Double[]@,System.Double[]@)">
            <summary>
            Layouts a connected graph with Multidimensional Scaling, using
            shortest-path distances as Euclidean target distances.
            </summary>
            <param name="geometryGraph">A graph.</param>
            <param name="settings">The settings for the algorithm.</param>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsGraphLayout.LayoutConnectedComponents">
            <summary>
            Computes layout for possibly disconnected graphs by putting
            the layouts for connected components together.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.MdsGraphLayout.PackGraphs(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.GeometryGraph},Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings)">
            <summary>
            Pack the given graph components to the specified aspect ratio
            </summary>
            <param name="components">set of graphs to pack</param>
            <param name="settings">settings for packing method and desired aspect ratio</param>
            <returns>Bounding box of the packed components</returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.MDS.Transform">
            <summary>
            Class for graoh layout with Multidimensional Scaling.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.MDS.Transform.Rotate(System.Double[],System.Double[],System.Double)">
            <summary>
            Rotates a 2D configuration clockwise by a given angle.
            </summary>
            <param name="x">Coordinate vector.</param>
            <param name="y">Coordinate vector.</param>
            <param name="angle">Angle between 0 and 360.</param>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.AxisSolver">
            <summary>
            Solver for structural separation constraints or non-overlap constraints in a single axis.
            Wrapper round all the ProjectionSolver stuff.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.AxisSolver.IsHorizontal">
            <summary>
            true means this AxisSolver works horizontally
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.AxisSolver.InitialCenterDelegateType">
            <summary>
             a delegate that tells us how to get the center of a node used in initialization and constraint generation
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.AxisSolver.NeedSolve">
            <summary>
            Do we even need to do a solve?
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.AxisSolver.#ctor(System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Layout.Incremental.FiNode},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Cluster},System.Boolean,System.Int32,System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Have to reinstantiate if any of these parameters change
            </summary>
            <param name="isHorizontal"></param>
            <param name="nodes"></param>
            <param name="clusterHierarchies"></param>
            <param name="avoidOverlaps"></param>
            <param name="constraintLevel"></param>
            <param name="clusterSettings"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.AxisSolver.AddStructuralConstraint(Microsoft.Msagl.Layout.Incremental.IConstraint)">
            <summary>
            Add the constraint to this axis
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.AxisSolver.Initialize(System.Double,System.Double,System.Double,System.Double,Microsoft.Msagl.Layout.Incremental.AxisSolver.InitialCenterDelegateType)">
            <summary>
            Create variables, generate non-overlap constraints.
            </summary>
            <param name="hPad">horizontal node padding</param>
            <param name="vPad">vertical node padding</param>
            <param name="cHPad">horizontal cluster padding</param>
            <param name="cVPad">vertical cluster padding</param>
            <param name="nodeCenter"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.AxisSolver.Solve">
            <summary>
            Do it!
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.AxisSolver.SetDesiredPositions">
            <summary>
            Must be called before Solve if the caller has updated Variable Initial Positions
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.Feasibility.Pad">
            <summary>
            Very small extra padding used for VPad to ensure feasibility
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.Feasibility.Enforce(Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Layout.Incremental.FiNode},System.Collections.Generic.List{Microsoft.Msagl.Layout.Incremental.IConstraint},System.Collections.Generic.List{Microsoft.Msagl.Layout.Incremental.IConstraint},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Cluster},System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Obtain a starting configuration that is feasible with respect to the structural 
            constraints.  This is necessary to avoid e.g. cycles in the constraint graph;
            for example, dragging the root of a downward-pointing tree downward below other
            nodes of the tree can result in auto-generation of constraints generating some
            constraints with the root on the right-hand side, and the structural constraints
            have it on the left-hand side.
            
            When AvoidOverlaps==true and we reach ConstraintLevel>=2 then we also need to remove
            overlaps... prior to this we need to force horizontal resolving of overlaps 
            between *all* nodes involved in vertical equality constraints (i.e. no skipping), 
            and then vertical overlap resolution of all nodes involved in horizontal equality
            constraints
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator">
            <summary>
            Create separation constraints between the source and target of edges not involved in cycles
            in order to better show flow
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator.GenerateEdgeConstraints(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge},Microsoft.Msagl.Core.Layout.IdealEdgeLengthSettings,Microsoft.Msagl.Layout.Incremental.AxisSolver,Microsoft.Msagl.Layout.Incremental.AxisSolver)">
            <summary>
            Creates a VerticalSeparationConstraint for each edge in the given set to structural constraints,
            to require these edges to be downward pointing.  Also checks for cycles, and edges involved
            in a cycle receive no VerticalSeparationConstraint, but can optionally receive a circle constraint.
            </summary>
            <param name="edges"></param>
            <param name="settings"></param>
            <param name="horizontalSolver"></param>
            <param name="verticalSolver"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator.GenerateSeparationConstraints">
            <summary>
            For each edge not involved in a cycle create a constraint
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.EdgeConstraintGenerator.CyclicComponents">
            <summary>
            Get an Enumeration of CyclicComponents
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout">
            <summary>
            Fast incremental layout is a force directed layout strategy with approximate computation of long-range node-node repulsive forces to achieve O(n log n) running time per iteration.
            It can be invoked on an existing layout (for example, as computed by MDS) to beautify it.  See docs for CalculateLayout method (below) to see how to use it incrementally.
            
            Note that in debug mode lots of numerical checking is applied, which slows things down considerably.  So, run in Release mode unless you're actually debugging!
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.energy">
            <summary>
            Returns the derivative of the cost function calculated in the most recent iteration.
            It's a volatile float so that we can potentially access it from other threads safely,
            for example during test.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.nodes">
            <summary>
            Construct a graph by adding nodes and edges to these lists
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings,System.Int32,System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Create the graph data structures.
            </summary>
            <param name="geometryGraph"></param>
            <param name="settings">The settings for the algorithm.</param>
            <param name="initialConstraintLevel">initialize at this constraint level</param>
            <param name="clusterSettings">settings by cluster</param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.CurrentConstraintLevel">
            <summary>
            Controls which constraints are applied in CalculateLayout.  Setter enforces feasibility at that level.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.AddConstraint(Microsoft.Msagl.Layout.Incremental.IConstraint)">
            <summary>
            Add constraint to constraints lists.  Warning, no check that dictionary alread holds a list for the level.
            Make sure you call AddConstraintLevel first (perf).
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.AddConstraintLevel(System.Int32)">
            <summary>
            Check for constraint level in dictionary, if it doesn't exist add the list at that level.
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.ComputeForces">
            <summary>
            Aggregate all the forces affecting each node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.NeedSolve">
            <summary>
            Checks if solvers need to be applied, i.e. if there are user constraints or 
            generated constraints (such as non-overlap) that need satisfying
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.VerletIntegration">
            <summary>
            Force directed layout is basically an iterative approach to solving a bunch of differential equations.
            Different integration schemes are possible for applying the forces iteratively.  Euler is the simplest:
             v_(i+1) = v_i + a dt
             x_(i+1) = x_i + v_(i+1) dt
            
            Verlet is much more stable (and not really much more complicated):
             x_(i+1) = x_i + (x_i - x_(i-1)) + a dt dt
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.UpdateStepSize(System.Single)">
            <summary>
            Adapt StepSize based on change in energy.  
            Five sequential improvements in energy mean we increase the stepsize.
            Any increase in energy means we reduce the stepsize.
            </summary>
            <param name="energy0"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.RunInternal">
            <summary>
            Apply a small number of iterations of the layout.  
            The idea of incremental layout is that settings.minorIterations should be a small number (e.g. 3) and 
            CalculateLayout should be invoked in a loop, e.g.:
            
            while(settings.RemainingIterations > 0) {
               fastIncrementalLayout.CalculateLayout();
               InvokeYourProcedureToRedrawTheGraphOrHandleInteractionEtc();
            }
            
            In the verletIntegration step above, the RemainingIterations is used to control damping.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayout.FinalizeClusterBoundaries">
            <summary>
            Simply does a depth first traversal of the cluster hierarchies fitting Rectangles to the contents of the cluster
            or updating the cluster BoundingBox to the already calculated RectangularBoundary
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.FiEdge">
            <summary>
            An edge is a pair of nodes and an ideal length required between them
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.FiNode">
            <summary>
            Wrapper for the MSAGL node to add force and velocity vectors
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FiNode.Center">
            <summary>
            local cache of node center (which in the MSAGL node has to be computed from the bounding box)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FiNode.ResetBounds">
            <summary>
            When mNode's bounds change we need to update our local
            previous and current center to MSAGL node center
            and update width and height
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.FiNode.Width">
            <summary>
            We also keep a local copy of Width and Height since it doesn't change and we don't want to keep going back to
            mNode.BoundingBox
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FiNode.UpdatePos(System.Boolean)">
            <summary>
            Update the current X or Y coordinate of the node center from the result of a solve
            </summary>
            <param name="horizontal"></param>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint">
            <summary>
            A horizontal separation constraint requires a minimum separation between x coordinates of two nodes,
            i.e. u.X + separation less or equal v.X
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.IsEquality">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.LeftNode">
            <summary>
            Constrained to be vertically above the BottomNode
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.RightNode">
            <summary>
            Constrained to be vertically below the TopNode
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.Separation">
            <summary>
            We allow the separation of existing constraints to be modified by the user.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <param name="separation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double,System.Boolean)">
            <summary>
            
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <param name="separation"></param>
            <param name="equality"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.Project">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.Level">
            <summary>
            HorizontalSeparationConstraint are usually structural and therefore default to level 0
            </summary>
            <returns>0</returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.HorizontalSeparationConstraint.Nodes">
            <summary>
            Get the list of nodes involved in the constraint
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.IConstraint">
            <summary>
            A constraint must provide a method to find a feasible starting configuration, 
            and a method to satisfy the constraint by moving the affected nodes as little as possible
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.IConstraint.Project">
            <summary>
            Satisfy the constraint by moving as little as possible.
            <returns>Amount of displacement</returns>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.IConstraint.Nodes">
            <summary>
            Get the list of nodes involved in the constraint
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.IConstraint.Level">
            <summary>
            Constraints are applied according to a schedule.
            Level 0 constraints will be applied at all stages,
            Level 1 after a certain number of Level 0 has completed
            Level 2 after level 1 and so on.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.LockPosition">
            <summary>
            Fix the position of a node.
            Create locks using FastIncrementalLayoutSettings.CreateLock method.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.LockPosition.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Makes a constraint preserve the nodes' bounding box with a very large weight
            </summary>
            <param name="node"></param>
            <param name="bounds"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.LockPosition.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Geometry.Rectangle,System.Double)">
            <summary>
            Makes a constraint to preserve the nodes' position with the specified weight
            </summary>
            <param name="node"></param>
            <param name="bounds"></param>
            <param name="weight"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.LockPosition.Weight">
            <summary>
            Set the weight for this lock constraint, i.e. if this constraint conflicts with some other constraint,
            projection of that constraint be biased by the weights of the nodes involved
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.LockPosition.Bounds">
            <summary>
            This assigns the new bounds and needs to be called after Solve() because
            multiple locked nodes may cause each other to move.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.LockPosition.Sticky">
            <summary>
            By default locks are not sticky and their ideal Position gets updated when they are pushed by another node.
            Making them Sticky causes the locked node to spring back to its ideal Position when whatever was pushing it
            slides past.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.LockPosition.Project">
            <summary>
            Move node (or cluster + children) to lock position
            I use stay weight in "project" of any constraints involving the locked node
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.LockPosition.Level">
            <summary>
            LockPosition is always applied (level 0)
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.LockPosition.SetLockNodeWeight">
            <summary>
            Sets the weight of the node (the FINode actually) to the weight required by this lock.
            If the node is a Cluster then:
             - its boundaries are locked
             - all of its descendant nodes have their lock weight set
             - all of its descendant clusters are set to generate fixed constraints (so they don't get squashed)
            Then, the node (or clusters) parents (all the way to the root) have their borders set to generate unfixed constraints 
            (so that this node can move freely inside its ancestors
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.LockPosition.RestoreNodeWeight">
            <summary>
            Reverses the changes made by SetLockNodeWeight
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.LockPosition.Nodes">
            <summary>
            Get the list of nodes involved in the constraint
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.MaxSeparationConstraint">
            <summary>
            Keeps nodes within a specified distance of each other
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MaxSeparationConstraint.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <param name="separation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MaxSeparationConstraint.Project">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.MinSeparationConstraint">
            <summary>
            A MinSeparationConstraint requires a minimum distance between two nodes, i.e. if nodes are closer than
            the minimum separation they will be projected apart, if they are further apart than the minimum
            separation then we don't need to do anything.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MinSeparationConstraint.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <param name="separation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MinSeparationConstraint.Project">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.KDTree">
            <summary>
            A KDTree recursively divides particles in a 2D space into a balanced tree structure by doing horizontal splits for wide bounding boxes and vertical splits for tall bounding boxes.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.KDTree.#ctor(Microsoft.Msagl.Layout.Incremental.KDTree.Particle[],System.Int32)">
            <summary>
            Create a KDTree over the specified particles, with the leaf partitions each containing bucketSize particles.
            </summary>
            <param name="particles"></param>
            <param name="bucketSize"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.KDTree.ComputeForces(System.Int32)">
            <summary>
            Compute forces between particles using multipole approximations.
            </summary>
            <param name="precision"></param>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.KDTree.Particle">
            <summary>
            Particles used in KDTree multipole force approximations
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.KDTree.Particle.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Create particle at point
            </summary>
            <param name="point"></param>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings">
            <summary>
            Fast incremental layout settings
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.maxIterations">
            <summary>
            Stop after maxIterations completed
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.MaxIterations">
            <summary>
            Stop after maxIterations completed
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.MinorIterations">
            <summary>
            Number of iterations in inner loop.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Iterations">
            <summary>
            Number of iterations completed
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ProjectionIterations">
            <summary>
            number of times to project over all constraints at each layout iteration
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ApproximateRepulsion">
            <summary>
            Rather than computing the exact repulsive force between all pairs of nodes (which would take O(n^2) time for n nodes)
            use a fast inexact technique (that takes O(n log n) time)
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.RungeKuttaIntegration">
            <summary>
            RungaKutta integration potentially gives smoother increments, but is more expensive
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.InitialStepSize">
            <summary>
            StepSize taken at each iteration (a coefficient of the force on each node) adapts depending on change in
            potential energy at each step.  With this scheme changing the InitialStepSize doesn't have much effect
            because if it is too large or too small it will be quickly updated by the algorithm anyway.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Decay">
            <summary>
            FrictionalDecay isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Friction">
            <summary>
            Friction isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.RepulsiveForceConstant">
            <summary>
            strength of repulsive force between each pair of nodes.  A setting of 1.0 should work OK.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.AttractiveForceConstant">
            <summary>
            strength of attractive force between pairs of nodes joined by an edge.  A setting of 1.0 should work OK.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.GravityConstant">
            <summary>
            gravity is a constant force applied to all nodes attracting them to the Origin
            and keeping disconnected components from flying apart.  A setting of 1.0 should work OK.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.InterComponentForces">
            <summary>
            If the following is false forces will not be considered between each component and each component will have its own gravity origin.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ApplyForces">
            <summary>
            If the following is false forces will not be applied, but constraints will still be satisfied.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.CreateLock(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            Add a LockPosition for each node whose position you want to keep fixed.  LockPosition allows you to,
            for example, do interactive mouse dragging.
            We return the LinkedListNode which you can store together with your local Node object so that a RemoveLock operation can be performed in
            constant time.
            </summary>
            <param name="node"></param>
            <param name="bounds"></param>
            <returns>LinkedListNode which you should hang on to if you want to call RemoveLock later on.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.CreateLock(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Geometry.Rectangle,System.Double)">
            <summary>
            Add a LockPosition for each node whose position you want to keep fixed.  LockPosition allows you to,
            for example, do interactive mouse dragging.
            We return the LinkedListNode which you can store together with your local Node object so that a RemoveLock operation can be performed in
            constant time.
            </summary>
            <param name="node"></param>
            <param name="bounds"></param>
            <param name="weight">stay weight of lock</param>
            <returns>LinkedListNode which you should hang on to if you want to call RemoveLock later on.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ClearLocks">
            <summary>
            Remove all locks on node positions
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.RemoveLock(Microsoft.Msagl.Layout.Incremental.LockPosition)">
            <summary>
            Remove a specific lock on node position.  Once you remove it, you'll have to call AddLock again to create a new one if you want to lock it again.
            </summary>
            <param name="lockPosition">the LinkedListNode returned by the AddLock method above</param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ResetLayout">
            <summary>
            restart layout, use e.g. after a mouse drag or non-structural change to the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Unconverge">
            <summary>
            reset iterations and convergence status
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.InitializeLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.InitializeLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Int32,System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Initialize the layout algorithm
            </summary>
            <param name="graph">The graph upon which layout is performed</param>
            <param name="initialConstraintLevel"></param>
            <param name="clusterSettings"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Uninitialize">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.IsInitialized">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.IncrementalRun(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.IncrementalRun(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            Run the FastIncrementalLayout instance incrementally
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.IncrementalRun(Microsoft.Msagl.Core.CancelToken,Microsoft.Msagl.Core.Layout.GeometryGraph,System.Func{Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings})">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.StructuralConstraints">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.AddStructuralConstraint(Microsoft.Msagl.Layout.Incremental.IConstraint)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ClearConstraints">
            <summary>
            Clear all constraints over the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ClearStructuralConstraints">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.AvoidOverlaps">
            <summary>
            Avoid overlaps between nodes boundaries, and if there are any
            clusters, then between each cluster boundary and nodes that are not
            part of that cluster.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.RespectEdgePorts">
            <summary>
            If edges have FloatingPorts then the layout will optimize edge lengths based on the port locations.
            If MultiLocationFloatingPorts are specified then the layout will choose the nearest pair of locations for each such edge.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.RouteEdges">
            <summary>
            Apply nice but expensive routing of edges once layout converges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ApproximateRouting">
            <summary>
            If RouteEdges is true then the following is checked to see whether to do optimal shortest path routing
            or use a sparse visibility graph spanner to do approximate---but much faster---shortest path routing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.LogScaleEdgeForces">
            <summary>
            If true then attractive forces across edges are computed as:
            AttractiveForceConstant * actualLength * Math.Log((actualLength + epsilon) / (idealLength + epsilon))
            where epsilon is a small positive constant to avoid divide by zero or taking the log of zero.
            Note that LogScaleEdges can lead to ghost forces in highly constrained scenarios.
            If false then a the edge force is based on (actualLength - idealLength)^2, which works better with
            lots of constraints.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.DisplacementThreshold">
            <summary>
            If the amount of total squared displacement after a particular iteration falls below DisplacementThreshold then Converged is set to true.
            Make DisplacementThreshold larger if you want layout to finish sooner - but not necessarily make as much progress towards a good layout.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Converged">
            <summary>
            Set to true if displacement from the last iteration was less than DisplacementThreshold.        
            The caller should invoke FastIncrementalLayout.CalculateLayout() in a loop, e.g.:
            
             while(!settings.Converged) 
             {
               layout.CalculateLayout();
               redrawGraphOrHandleInteractionOrWhatever();
             }
             
            RemainingIterations affects damping.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.PercentDone">
            <summary>
            Return iterations as a percentage of MaxIterations.  Useful for reporting progress, e.g. in a progress bar.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.IsDone">
            <summary>
            Not quite the same as Converged:
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.Energy">
            <summary>
            Returns an estimate of the cost function calculated in the most recent iteration.
            It's a float because FastIncrementalLayout.Energy is a volatile float so it
            can be safely read from other threads
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.EdgeRoutesUpToDate">
            <summary>
            When layout is in progress the following is false.  
            When layout has converged, routes are populated and this is set to true to tell the UI that the routes can be drawn.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.MaxConstraintLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.MinConstraintLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.CurrentConstraintLevel">
            <summary>
            Constraint level ranges from Min to MaxConstraintLevel.
            0 = no constraints
            1 = only structural constraints
            2 = all constraints including non-overlap constraints
            
            A typical run of FastIncrementalLayout will apply it at each constraint level, starting at 0 to
            obtain an untangled unconstrained layout, then 1 to introduce structural constraints and finally 2 to beautify.
            Running only at level 2 will most likely leave the graph stuck in a tangled local minimum.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.AttractiveInterClusterForceConstant">
            <summary>
            Attractive strength of edges connected to clusters
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.#ctor(Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings)">
            <summary>
            Shallow copy the settings
            </summary>
            <param name="previousSettings"></param>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.ClusterGravity">
            <summary>
            Controls how tightly members of clusters are pulled together
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.IdealEdgeLength">
            <summary>
            Settings for calculation of ideal edge length
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.UpdateClusterBoundariesFromChildren">
            <summary>
            Force groups to follow their constituent nodes, 
            true by default.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings.CreateFastIncrementalLayoutSettings">
            <summary>
                creates the settings that seems working
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.#ctor(System.Int32,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            
            </summary>
            <param name="precision"></param>
            <param name="center"></param>
            <param name="points"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.#ctor(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients,Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients)">
            <summary>
            
            </summary>
            <param name="center"></param>
            <param name="m1"></param>
            <param name="m2"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.compute(System.Int32,Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            Compute kth multipole coefficient of a set of points ps around a centre z0
            </summary>
            <param name="k">Coefficient index</param>
            <param name="ps">Set of points</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.ApproximateForce(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Compute approximate force at point v due to potential energy moments
            </summary>
            <param name="v"></param>
            <returns>Approximate force at v</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.MultipoleCoefficients.Force(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Force on point u due to point v.
            If v and u at the same position it returns a small vector to separate them
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node})">
            <summary>
            Create a circle constraint with variable radius
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            A procrustes constraint with arbitrary target shape
            </summary>
            <param name="nodes"></param>
            <param name="targetConfiguration"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProduct(Microsoft.Msagl.Core.Geometry.Point[],Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            matrix product: A'B
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns>2X2 matrix</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.matrixProductNoTranspose(Microsoft.Msagl.Core.Geometry.Point[],Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            matrix product of two 2x2 matrices with no transpose, i.e.: AB
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns>2X2 matrix</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.SingularValueDecomposition(Microsoft.Msagl.Core.Geometry.Point[],Microsoft.Msagl.Core.Geometry.Point[]@,Microsoft.Msagl.Core.Geometry.Point[]@)">
            <summary>
            Compute singular value decomposition of a 2X2 matrix X=PSQ'
            </summary>
            <param name="X">input 2x2 matrix</param>
            <param name="P">left singular vectors</param>
            <param name="Q">right singular vectors (eigenvectors of X'X)</param>
            <returns>Singular values (Sqrt of eigenvalues of X'X)</returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.Project">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.PrintMatrix(Microsoft.Msagl.Core.Geometry.Point[])">
            <summary>
            output an n*2 point matrix in Mathematica format
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.Test">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.Level">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.ProcrustesCircleConstraint.Nodes">
            <summary>
            Get the list of nodes involved in the constraint
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.StickConstraint">
            <summary>
            A stick constraint requires a fixed separation between two nodes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.StickConstraint.u">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.StickConstraint.v">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Layout.Incremental.StickConstraint.separation">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.StickConstraint.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <param name="separation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.StickConstraint.Project">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.StickConstraint.Level">
            <summary>
            StickConstraints are usually structural and therefore default to level 0
            </summary>
            <returns>0</returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.StickConstraint.Nodes">
            <summary>
            Get the list of nodes involved in the constraint
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint">
            <summary>
            A vertical separation constraint requires a minimum separation between y coordinates of two nodes,
            i.e. u.Y + separation less or equal v.Y
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.IsEquality">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.TopNode">
            <summary>
            Constrained to be vertically above the BottomNode
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.BottomNode">
            <summary>
            Constrained to be vertically below the TopNode
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.Separation">
            <summary>
            We allow the separation of existing constraints to be modified by the user.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <param name="separation"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node,System.Double,System.Boolean)">
            <summary>
            
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <param name="separation"></param>
            <param name="equality"></param>
        </member>
        <member name="M:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.Project">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.Level">
            <summary>
            VerticalSeparationConstraint are usually structural and therefore default to level 0
            </summary>
            <returns>0</returns>
        </member>
        <member name="P:Microsoft.Msagl.Layout.Incremental.VerticalSeparationConstraint.Nodes">
            <summary>
            Get the list of nodes involved in the constraint
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher">
            <summary>
            pushes the nodes it got bumped to: pushes horizontally or vertically
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Double,Microsoft.Msagl.Core.Layout.Node[])">
            <summary>
            
            </summary>
            <param name="pushedNodes">nodes that are being pushed</param>
            <param name="separation"></param>
            <param name="pushingNodes"></param>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.PushNodes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.UpdateRTreeByChangedNodeBox(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Geometry.Rectangle)">
            <summary>
            
            </summary>
            <param name="cluster"></param>
            <param name="previousBox"></param>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutEditing.BumperPusher.FirstPushingNode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger.ChangedGraph">
            <summary>
            it is smaller graph that needs to be refreshed by the viewer
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings)">
            <summary>
            
            </summary>
            <param name="pushingNodes">the nodes are already at the correct positions</param>
            <param name="graph"></param>
            <param name="layoutSettings"></param>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutEditing.IncrementalDragger.Drag(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="delta"></param>
        </member>
        <member name="T:Microsoft.Msagl.Miscellaneous.LayoutEditing.LabelFixture">
            <summary>
            this class charachterizes how a label is attached to its edge
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Miscellaneous.LayoutHelpers">
            <summary>
            A set of helper methods for executing a layout.
            These exist for compatibility with previous consumers of MSAGL,
            but the new APIs should be used for new code.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutHelpers.CalculateLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings,Microsoft.Msagl.Core.CancelToken)">
            <summary>
            Calculates the graph layout
            </summary>
            <exception cref="T:System.OperationCanceledException">Thrown when the layout is canceled.</exception>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutHelpers.LayoutLargeGraphWithLayers(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings,Microsoft.Msagl.Core.CancelToken)">
            <summary>
            calculates all data necessery for large graph browsing
            </summary>
            <param name="geometryGraph"></param>
            <param name="settings"></param>
            <param name="cancelToken"></param>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutHelpers.RouteAndLabelEdges(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.LayoutAlgorithmSettings,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge})">
            <summary>
            </summary>
            <param name="geometryGraph"></param>
            <param name="layoutSettings"></param>
            <param name="edgesToRoute"></param>
        </member>
        <member name="M:Microsoft.Msagl.Miscellaneous.LayoutHelpers.IncrementalLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Layout.Layered.SugiyamaLayoutSettings)">
            <summary>
            adaptes to the node boundary curve change
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Miscellaneous.RegularGrid.GridTraversal">
            <summary>
            Traversal of regular grid
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.Constraints.AlignmentConstraint">
            <summary>
            This doesn't work yet, but it will be a constraint that aligns nodes, optionally to some fixed orientation (horizontal, vertical, 45 degrees, etc).
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Constraints.AlignmentConstraint.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node})">
            <summary>
            Create an alignment constraint for the given set of nodes
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Constraints.AlignmentConstraint.Project">
            <summary>
            project using a perpendicular least-squares fit
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Constraints.AlignmentConstraint.Level">
            <summary>
            level 1
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Constraints.AlignmentConstraint.Nodes">
            <summary>
            Get the list of nodes involved in the constraint
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData">
            <summary>
            holds the data needed to restore the edge after the editing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.UnderlyingPolyline">
            <summary>
            the underlying polyline
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.LabelCenter">
            <summary>
            the initial center
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.Curve">
            <summary>
            the edge original curve
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.ArrowheadAtSourcePosition">
            <summary>
            the arrow head position at source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.ArrowheadAtTargetPosition">
            <summary>
            the arrow head position at target
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.LabelOffsetFromTheAttachmentPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.EdgeRestoreData.LabelAttachmentParameter">
            <summary>
            the closest point to the label center
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.LayoutEditing.LabelRestoreData">
            <summary>
            keeps a label restore data
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.LabelRestoreData.Center">
            <summary>
            the label center
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.LabelRestoreData.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            constructor
            </summary>
            <param name="centerP"></param>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.LayoutEditing.NodeRestoreData">
            <summary>
            node restore data
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.NodeRestoreData.BoundaryCurve">
            <summary>
            node boundary curve
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator">
            <summary>
            calculations with obstacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.Calculate">
            <summary>
            There are two sets of obstacles: tight and loose.
            We route the shortest path between loose obstacles, and then beautify it while only taking into account tight obstacles
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CreateInitialTightObstacles">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.GetPaddedPolyline(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double)">
            <summary>
            </summary>
            <param name="closedCurve"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.PaddedPolylineBoundaryOfNode(Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            Creates a padded polyline boundary of the node. The polyline offsets at least as the padding from the node boundary.
            </summary>
            <param name="node"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.Inside(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            we know here that there are no intersection between "curveUnderTest" and "curve",
            We are testing that curve is inside of "curveUnderTest"
            </summary>
            <param name="curveUnderTest"></param>
            <param name="curve"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.ObstacleCalculator.CurveIntersectsRectangleNode(Microsoft.Msagl.Core.Geometry.Curves.Polyline,Microsoft.Msagl.Core.Geometry.RectangleNode{Microsoft.Msagl.Core.Geometry.Curves.Polyline},Microsoft.Msagl.Core.Geometry.Curves.Polyline)">
            <summary>
            
            </summary>
            <param name="quadrilateral"></param>
            <param name="rectangleNode"></param>
            <param name="polylineToIgnore"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.LayoutEditing.RestoreData">
            <summary>
            a base class for restoring geometrical objects
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Prototype.LayoutEditing.RestoreData.Action">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper">
            <summary>
            Helper class for creating RestoreData objects from GeometryGraph objects.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            creates node restore datat
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            gets restore data for an edge
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            creates graph restore data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData(Microsoft.Msagl.Core.Layout.Label)">
            <summary>
            creates label restore data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.RestoreHelper.GetRestoreData(Microsoft.Msagl.Core.Layout.GeometryObject)">
            <summary>
            calculates the restore data
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes">
            <summary>
            the router between nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.SourcePort">
            <summary>
            the port of the edge start
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.TargetPort">
            <summary>
            the port of the edge end
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.EnteringAngleBound">
            <summary>
            the minimum angle between a node boundary curve and and an edge 
            curve at the place where the edge curve intersects the node boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.Padding">
            <summary>
            the curve should not come to the nodes closer than MinimalPaddin
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.LoosePadding">
            <summary>
            we pad each node but not more than MaximalPadding
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.OffsetForPolylineRelaxing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double,System.Double)">
            <summary>
            constructor
            </summary>
            <param name="graph"></param>
            <param name="minimalPadding"></param>
            <param name="maximalPadding"></param>
            <param name="offsetForRelaxing"></param>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.LayoutEditing.RouterBetweenTwoNodes.RouteEdge(Microsoft.Msagl.Core.Layout.Edge,System.Boolean)">
            <summary>
            Routes a spline between two graph nodes. sourcePort and targetPort define the start and end point of the resulting curve:
            startPoint=source.BoundaryCurve[sourcePort] and endPoint=target.BoundaryCurve[target].
            </summary>
            <param name="edge"></param>
            <param name="takeYourTime">if set to true then the method will try to improve the spline</param>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.WeightedEdge.Source">
            <summary>
            source
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.LayoutEditing.WeightedEdge.Target">
            <summary>
            source
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.MultiScale.MultiScaleLayout.CalculateLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double)">
            <summary>
            Fastest method we have for laying out large graphs.  Also does a pretty good job
            of unfolding graphs.
            The idea is that a stack of successively more and more simplified (abridged) graphs
            is constructed, then each graph on the stack is laid out, starting nodes at the positions
            of their ancestors in the more abridged graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.MultiScale.MultiScaleLayout.CenterNode(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Place node at the centroid of its neighbours and its initial position
            </summary>
            <param name="u">node to center</param>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.MultiScale.MultiScaleLayout.SimpleLayout(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double)">
            <summary>
            Simple unconstrained layout of graph used by multiscale layout
            </summary>
            <param name="graph"></param>
            <param name="edgeLengthMultiplier"></param>
            <param name="level">double in range [0,1] indicates how far down the multiscale stack we are
            1 is at the top, 0 at the bottom, controls repulsive force strength and ideal edge length</param>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.MultiScale.MultiScaleLayout.CreateAbridgedGraph(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double)">
            <summary>
            Create an abstraction of the graph by pairing edges with the shortest
            symmetric difference of neighbour sets.  In a perfect world the result
            would have half as many nodes as the input graph.  In practice we only
            process the edge list once, and don't pair edges whose ends are already
            paired so the output may have more than n/2 nodes.
            </summary>
            <param name="graph">The input graph</param>
            <param name="edgeLengthOffset">Initial edge length adjustment percent before proportional adjustments.</param>
            <param name="edgeLengthMultiplier">The percent length adjustment unit.</param>
            <returns>an abridged graph</returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull">
            <summary>
            A CvxHull is Convex hull
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.Parent">
            <summary>
            We have a hierarchy of membership
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.Center">
            <summary>
            see IHull
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.MoveCenter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            move the center by delta
            </summary>
            <param name="delta"></param>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.RectangleNode">
            <summary>
            see IHull
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.Weight">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.TranslatedBoundary">
            <summary>
            Gets the boundary translated to the current Center
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull.Project(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull)">
            <summary>
            Resolves overlap between this and another CHull by moving on the minimum penetration depth vector
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull">
            <summary>
            A CvxHull for rectangles
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.Center">
            <summary>
            Center of the node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.MoveCenter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Move by delta
            </summary>
            <param name="delta"></param>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.RectangleNode">
            <summary>
            RectangleNode is used in region queries
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.Weight">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.#ctor(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull,Microsoft.Msagl.Core.Layout.Node,System.Double)">
            <summary>
            
            </summary>
            <param name="parent"></param>
            <param name="padding"></param>
            <param name="mNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.RCHull.TranslatedBoundary">
            <summary>
            Gets the boundary translated to the current Center
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull">
            <summary>
            The convex hull of the constituents of a Cluster
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.Center">
            <summary>
            The Barycenter of the cluster
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.MoveCenter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Move contents by delta
            </summary>
            <param name="delta"></param>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.Weight">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.RectangleNode">
            <summary>
            Bounding box used in region queries
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.#ctor(Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull)">
            <summary>
            The convex hull of the constituents of a Cluster
            </summary>
            <param name="cluster"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.TranslatedBoundary">
            <summary>
            Gets the boundary translated to the current Center
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.ComputeConvexHull">
            <summary>
            The convex hull of all the points of all the nodes in the cluster
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ClusterConvexHull.Contains(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.CvxHull)">
            <summary>
            Search hierarchy to check if child is a descendent of this.
            </summary>
            <param name="child"></param>
            <returns>true if child is a descendent of this cluster</returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries">
            <summary>
            Prevents the boundaries of nodes and clusters from overlapping
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries.#ctor(Microsoft.Msagl.Core.Layout.Cluster,Microsoft.Msagl.Layout.Incremental.FastIncrementalLayoutSettings)">
            <summary>
            
            Non-overlap between nodes in the same cluster (or the root cluster), between the convex hulls
            of clusters and nodes that do belong to those clusters and between clusters and clusters.
            </summary>
            <param name="cluster"></param>
            <param name="settings">for padding extra space around nodes</param>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries.Project">
            <summary>
            Uses Lev's fast proximity query to find pairs of nodes/clusters with overlapping bounding boxes.
            When such are found, they are projected apart.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries.Level">
            <summary>
            NonOverlap constraints are a beautification thing, and therefore higher level than others
            </summary>
            <returns>2</returns>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.AllPairsNonOverlappingBoundaries.Nodes">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull">
            <summary>
            An IHull is used for proximity queries and should implement the Project method which (similar to IConstraint)
            should remove overlap between two hulls by moving them as little as possible
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.Center">
            <summary>
            Actual or weighted center of the hull
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.MoveCenter(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="delta"></param>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.RectangleNode">
            <summary>
            Bounding box
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull.Project(Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull)">
            <summary>
            Remove overlap between this and another IHull by moving them both as little as possible
            </summary>
            <param name="other"></param>
            <returns>amount of displacement</returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ProximityQuery">
            <summary>
            Uses Lev's HierarchyCalculatorWithRectangularNodes to do overlap queries
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ProximityQuery.GetAllIntersections">
            <summary>
            Find all overlapping pairs.
            </summary>
            <returns>List of overlapping pairs</returns>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.NonOverlappingBoundaries.ProximityQuery.GetIntersecting(Microsoft.Msagl.Core.Geometry.RectangleNode{Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull},Microsoft.Msagl.Core.Geometry.RectangleNode{Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull},System.Collections.Generic.List{Microsoft.Msagl.Prototype.NonOverlappingBoundaries.IHull})">
            <summary>
            Search in the hierarchy for rectangles that intersect with leafNode.
            </summary>
            <param name="leafNode"></param>
            <param name="intersecting"></param>
            <param name="internalNode"></param>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.Phylo.PhyloEdge">
            <summary>
            Phylogenetic edge: an edge with a specified length
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Phylo.PhyloEdge.#ctor(Microsoft.Msagl.Core.Layout.Node,Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            constructor
            </summary>
            <param name="sourceP"></param>
            <param name="targetP"></param>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.Phylo.PhyloTree">
            <summary>
            Implements a phylogenetic tree
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Phylo.PhyloTree.Leaves">
            <summary>
            the leaves of the tree
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation.VirtualNodeWidth">
            <summary>
            the width of dummy nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Phylo.PhyloTreeLayoutCalclulation.VirtualNodeHeight">
            <summary>
            the height of dummy nodes
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.Ranking.Centrality">
            <summary>
            Class for centrality computation.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Ranking.Centrality.PageRank(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Boolean)">
            <summary>
            Computes the PageRank in a directed graph.
            </summary>
            <param name="graph">A directed graph.</param>
            <param name="omega">Probability of a jump
            (with uniform probability) to some other node.</param>
            <param name="inverse">false=PageRank, true=TrustRank.</param>
            <returns>PageRank scores.</returns>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.Ranking.RankingLayout">
            <summary>
            Ranking layout for directed graphs.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Ranking.RankingLayout.#ctor(Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings,Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            Constructs the ranking layout algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Ranking.RankingLayout.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Ranking.RankingLayout.Standardize(System.Double[])">
            <summary>
            Scales and translates a vector so that all values are exactly between 0 and 1.
            </summary>
            <param name="x">Vector to be standardized.</param>
        </member>
        <member name="T:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings">
            <summary>
            Ranking layout settings
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.PivotNumber">
            <summary>
            Number of pivots in Landmark Scaling (between 3 and number of objects).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.OmegaX">
            <summary>
            Impact of group structure on layout in the x-axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.OmegaY">
            <summary>
            Impact of group structure on layout in the y-axis.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.ScaleX">
            <summary>
            X Scaling Factor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.ScaleY">
            <summary>
            Y Scaling Factor.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Prototype.Ranking.RankingLayoutSettings.Clone">
            <summary>
            Clones the object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ClusterBoundaryPort">
            <summary>
            this is a port for routing from a cluster
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ClusterBoundaryPort.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Func{Microsoft.Msagl.Core.Geometry.Point},Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            constructor
            </summary>
            <param name="curveDelegate"></param>
            <param name="centerDelegate"></param>
            <param name="locationOffset"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ClusterBoundaryPort.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Func{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            constructor 
            </summary>
            <param name="curveDelegate"></param>
            <param name="centerDelegate"></param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.CdtEdge">
            <summary>
            the edge direction is from the upperSite to lowerSite
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtEdge.upperSite">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtEdge.lowerSite">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtEdge.ccwTriangle">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtEdge.cwTriangle">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtEdge.Constrained">
            <summary>
             is an obstacle side, or a given segment
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CdtEdge.#ctor(Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite)">
            <summary>
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtEdge.Capacity">
            <summary>
            the amount of free space around the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.CdtEdge.ResidualCapacity">
            <summary>
            the amount of residual free space around the edge
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.CdtEdge.CcwTriangle">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.CdtEdge.CwTriangle">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CdtEdge.GetOtherTriangle(Microsoft.Msagl.Routing.CdtSite)">
            <summary>
            returns the trianlge on the edge opposite to the site 
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CdtEdge.IsAdjacent(Microsoft.Msagl.Routing.CdtSite)">
            <summary>
            </summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CdtEdge.GetOtherTriangle(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle)">
            <summary>
            </summary>
            <param name="triangle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CdtEdge.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CdtEdge.OtherSite(Microsoft.Msagl.Routing.CdtSite)">
            <summary>
            </summary>
            <param name="site"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper">
            <summary>
            this class builds the triangulation by a sweep with a horizontal line
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.RunInternal">
            <summary>
            the method making the main work
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.ShortcutTwoFrontElements(Microsoft.Msagl.Core.DataStructures.RBNode{Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement},Microsoft.Msagl.Core.DataStructures.RBNode{Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtFrontElement})">
            <summary>
            aNode is to the left of bNode, and they are consecutive
            </summary>
            <param name="aNode"></param>
            <param name="bNode"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.InCircle(Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite)">
            <summary>
            Testing that d in inside of the circumcircle of (a,b,c). 
            The good explanation of this test is in 
            "Guibas, Stolfi,"Primitives for the Manipulation of General Subdivisions and the Computation of Voronoi Diagrams
            
            </summary>
            <param name="d"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtSweeper.InCone(Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite)">
            <summary>
            
            </summary>
            <param name="pi"></param>
            <param name="a">point on left side of the cone</param>
            <param name="b">the apex</param>
            <param name="c">point on the right side of the cone</param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt">
            <summary>
            triangulates the space between point, line segment and polygons in the Delaunay fashion
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Point},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Collections.Generic.List{Microsoft.Msagl.Core.DataStructures.SymmetricTuple{Microsoft.Msagl.Core.Geometry.Point}})">
            <summary>
            constructor
            </summary>
            <param name="isolatedSites"></param>
            <param name="obstacles"></param>
            <param name="isolatedSegments"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.Msagl.Core.Geometry.Point,System.Object}})">
            <summary>
            constructor
            </summary>
            <param name="isolatedSites"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.GetTriangles">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.RunInternal">
            <summary>
            Executes the actual algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            compare first y then -x coordinates
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>1 if a is above b, 0 if points are the same and -1 if a is below b</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.Above(Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite)">
            <summary>
            compare first y then -x coordinates
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>1 if a is above b, 0 if points are the same and -1 if a is below b</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.SetInEdges">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.Cdt.FindSite(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle">
            <summary>
            a trianlge oriented counterclockwise
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.Edges">
            <summary>
             the edges
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.Sites">
            <summary>
             the sites
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.BindEdgeToTriangle(Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtEdge)">
            <summary>
            in the trianlge, which is always oriented counterclockwise, the edge starts at site 
            </summary>
            <param name="site"></param>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle.FillCcwTriangle(Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite,System.Func{Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtSite,Microsoft.Msagl.Routing.CdtEdge})">
            <summary>
            here a,b,c comprise a ccw triangle
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="createEdgeDelegate"></param>
        </member>
        <member name="F:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.EdgeTracer.a">
            <summary>
            the upper site of the edge
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.EdgeTracer.b">
            <summary>
            the lower site of the edge
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.PerimeterEdge">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray`1">
            <summary>
             an efficient class to simulate a three element array
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray`1.#ctor(`0,`0,`0)">
            <summary>
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray`1.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray`1.Item(System.Int32)">
            <summary>
            </summary>
            <param name="i"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.ThreeArray`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="T:Microsoft.Msagl.Routing.CdtSite">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.CdtSite.Owner">
            <summary>
            Object to which this site refers to.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtSite.Point">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.CdtSite.Edges">
            <summary>
            each CdtSite points to the edges for which it is the upper virtex ( for horizontal edges it is the left point)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.CdtSite.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            </summary>
            <param name="isolatedSite"></param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.CdtSite.Triangles">
            <summary>
            enumerates over all site triangles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.MultiEdgeRouter.GetIndependantPreGraphs">
            <summary>
            creates a set of pregraphs suitable for bundle routing
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.GetPath">
            <summary>
            Returns  a  path
            </summary>
            <returns>a path or null if the target is not reachable from the source</returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Clump">
            <summary>
            This is the list of obstacles in the clump.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper`1">
            <summary>
            Used in merge-type operations to track whether MoveNext has returned false.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper`1.HasCurrent">
            <summary>
            False iff MoveNext has not been called, or has returned false.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.EnumeratorWrapper`1.MoveNextState">
            <summary>
            State of MoveNext.  MoveNext is not automatically called on ctor for consistency with unwrapped enumerators.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.FullVisibilityGraphGenerator.GenerateVisibilityGraph">
            <summary>
            Generate the visibility graph along which edges will be routed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides">
            <summary>
            From an OpenVertexEvent or CloseVertexEvent, we search in the high and low direction for neighbors.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.LowNeighbor">
            <summary>
            The HighObstacleSide of the low neighbor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.LowNeighborSide">
            <summary>
            Dereferences the node if non-null to return the side Item.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.LowOverlapEnd">
            <summary>
            A LowObstacleSide that we pass through in the low direction into open space.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.GroupSideInterveningBeforeLowNeighbor">
            <summary>
            A group that we pass through toward the low neighbor.  Avoids reflections going through group boundaries.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.HighNeighbor">
            <summary>
            The LowObstacleSide of the high neighbor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.HighNeighborSide">
            <summary>
            Dereferences the node if non-null to return the side Item.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.HighOverlapEnd">
            <summary>
            A HighObstacleSide that we pass through in the high direction into open space.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.NeighborSides.GroupSideInterveningBeforeHighNeighbor">
            <summary>
            A group that we pass through toward the high neighbor.  Avoids reflections going through group boundaries.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.VisibilityGraph">
            <summary>
            The visibility graph generated by GenerateVisibilityGraph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.VisibilityGraphGenerator.GenerateVisibilityGraph">
            <summary>
            Generate the visibility graph along which edges will be routed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.OverlapConvexHull">
            <summary>
            This stores the location and type of a Port.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.OverlapConvexHull.PrimaryObstacle">
            <summary>
            This is some arbitrary obstacle inside the convex hull so we qualify Select().Where() so we
            don't get the CH duplicated in the scanline etc. enumerations.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.OverlapConvexHull.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem">
            <summary>
            This forms one slot in the scan segment vector.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.FirstSegment">
            <summary>
            The head of the linked list.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.CurrentSegment">
            <summary>
            The current segment of the linked list, used when appending or intersecting.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.pendingPerpCoords">
            <summary>
            Perpendicular coordinates that are not in a ScanSegment, due to either not having the ScanSegments created
            yet or because it will be faster to do a single pass after accumulating them (e.g. for GroupBoundaryCrossings).
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.ResetForIntersections">
            <summary>
            Restores state between intersection passes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.IsHorizontal">
            <summary>
            Indicates whether ScanSegments in this item are horizontally or vertically oriented.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.Coord">
            <summary>
            Returns the constant coordinate of the ScanSegments in this item, i.e. the coordinate
            that intersects the perpendicular axis.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.#ctor(System.Double)">
            <summary>
            Ctor, taking the parallel (constant) coordinate.
            </summary>
            <param name="coord">the parallel (constant) coordinate</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.TraverseToSegmentContainingPoint(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Move along the linked list until we hit the ScanSegment that contains the point.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.PointIsCurrentEndAndNextStart(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Returns true if the point is the end of the current segment and there is an adjoining NextSegment.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.AddPerpendicularCoord(System.Double)">
            <summary>
            Set Current to the ScanSegment containing the perpendicular coordinate, then add that coordinate to its
            sparse-vector coordinate list.
            </summary>
            <param name="perpCoord"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVectorItem.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector">
            <summary>
            This forms the vector of ScanSegments for the sparse VisibilityGraph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.CurrentSlotIndex">
            <summary>
            The index of the scan segment vector we're appending to on the ScanSegment-generation sweep.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.Length">
            <summary>
            The number of slots.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.FirstSlot">
            <summary>
            The first item in the vector.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.LastSlot">
            <summary>
            The last item in the vector
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.CurrentSlot">
            <summary>
            The item at the index of the scan segment vector we're appending to on the ScanSegment-generation sweep.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.Item(System.Int32)">
            <summary>
            The indexed item in the vector.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.CreateScanSegment(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double,Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList)">
            <summary>
            Appends a ScanSegment to the linked list in the "Current" slot.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.Items">
            <summary>
            Returns an enumeration of the vector of ScanSegmentVectorItems.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.ResetForIntersections">
            <summary>
            Reset vector state between passes.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.IsHorizontal">
            <summary>
            Indicates if this contains horizontal or vertical ScanSegments.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.FindNearest(System.Double,System.Int32)">
            <summary>
            Search the vector for the nearest slot in the specified direction.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.ScanSegmentVector.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.horizontalVertexPoints">
            <summary>
            The points of obstacle vertices encountered on horizontal scan.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.verticalVertexPoints">
            <summary>
            The points of obstacle vertices encountered on vertical scan.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.boundingBoxSteinerPoints">
            <summary>
            The Steiner points generated at the bounding box of obstacles.
            These help ensure that we can "go around" the obstacle, as with the non-orthogonal edges in the paper.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.xCoordAccumulator">
            <summary>
            Accumulates distinct vertex projections to the X axis during sweep.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.yCoordAccumulator">
            <summary>
            Accumulates distinct vertex projections to the Y axis during sweep.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.horizontalScanSegmentVector">
            <summary>
            ScanSegment vector locations on the Y axis; final array after sweep.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.verticalScanSegmentVector">
            <summary>
            ScanSegment vector locations on the X axis; final array after sweep.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.horizontalCoordMap">
            <summary>
            The index from a coordinate to a horizontal vector slot.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.verticalCoordMap">
            <summary>
            The index from a point to a vertical vector slot.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.perpendicularCoordMap">
            <summary>
            The index from a coordinate to a vector slot on the axis we are intersecting to.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.parallelSegmentVector">
            <summary>
            The segment vector we are intersecting along.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.perpendicularSegmentVector">
            <summary>
            The segment vector we are intersecting to.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.currentAxisPointComparer">
            <summary>
            The comparer for points along the horizontal or vertical axis.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SparseVisibilityGraphGenerator.GenerateVisibilityGraph">
            <summary>
            Generate the visibility graph along which edges will be routed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.#ctor(Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear,Microsoft.Msagl.Routing.Rectilinear.VertexEntry,System.Double,System.Int32,System.Double)">
            <summary>
            A class that records an entry from a specific direction for a vertex.
            </summary>
            <param name="vertex">Vertex that this VertexEntry enters</param>
            <param name="prevEntry">The previous VertexEntry along this path; null for a path source</param>
            <param name="length">Length of the path up to this vertex</param>
            <param name="numberOfBends">Number of bends in the path up to this vertex</param>
            <param name="cost">Cost of the path up to this vertex</param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.Cost">
            <summary>
            Cost of the path up to this vertex
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.Vertex">
            <summary>
            The vertex that this VertexEntry enters
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.PreviousVertex">
            <summary>
            The vertex that this VertexEntry is entered from
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.Direction">
            <summary>
            The direction of entry to the vertex for this path (i.e. the direction from PreviousVertex to this.Vertex).
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.Length">
            <summary>
            The length of the path up to this vertex
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.NumberOfBends">
            <summary>
            The number of bends in the path up to this vertex
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.PreviousEntry">
            <summary>
            The previous VertexEntry along this path; null for a path source.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.IsClosed">
            <summary>
            Indicates whether we are allowing further entries into this vertex from this direction.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.VertexEntry.ToString">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.VisibilityVertexRectilinear">
            <summary>
            This vertex class is used in rectilinear shortest paths
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.Crossing(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex[])">
            <summary>
            ignoring crossing at a
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="segsToIgnore"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.StaircaseRemover.IsCrossing(Microsoft.Msagl.Core.Geometry.Curves.LineSegment,Microsoft.Msagl.Core.Geometry.RTree{Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex},Microsoft.Msagl.Routing.Rectilinear.Nudging.SegWithIndex[])">
            <summary>
            ignoring crossing at ls.Start
            </summary>
            <param name="ls"></param>
            <param name="rTree"></param>
            <param name="segsToIgnore"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge">
            <summary>
            a wrapper arownd VisibilityEdge representing the same edge 
            but oriented along the X or the Y axis
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgesContainer">
            <summary>
            keeps a list of active overlapping AxisEdges discovered during the sweep
             </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgesContainer.UpPoint">
            <summary>
            it is not necessarely the upper point but some point above the source
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgesContainer.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdgesContainer.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger">
            <summary>
            sets the order of connector paths on the edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge,Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge,Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge,Microsoft.Msagl.Core.Geometry.Directions)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="axisEdge">axisEdge together with the axisEdgeIsReversed parameter define direction of the movement over the paths</param>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder">
            <summary>
            The class is looking for the free space around AxisEdges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.#ctor(Microsoft.Msagl.Core.Geometry.Directions,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Collections.Generic.Dictionary{Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge,Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Collections.Generic.Dictionary{Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge,System.Collections.Generic.List{Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge}},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge})">
            <summary>
            
            </summary>
            <param name="direction"></param>
            <param name="obstacles"></param>
            <param name="axisEdgesToObstaclesTheyOriginatedFrom"></param>
            <param name="pathOrders"></param>
            <param name="axisEdges">edges to find the empty space around</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.FindFreeSpace">
            <summary>
            calculates the right offsets
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.ConstraintEdgeWithObstaclesAtZ(Microsoft.Msagl.Routing.Rectilinear.Nudging.AxisEdge,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="point">a point on the edge on Z level</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.FreeSpaceFinder.GetAxisEdgesContainerNode(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="point">the point has to be on the same line as the container</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter">
            <summary>
            intersects a set of horizontal LinkedPoints with a set of vertical LinkedPoints
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPointSplitter.#ctor(System.Collections.Generic.List{Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint},System.Collections.Generic.List{Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint})">
            <summary>
            
            </summary>
            <param name="horizontalPoints">no two horizontal segs overlap, but they can share an end point</param>
            <param name="verticalPoints">no two vertical segs overlap, but they can share an end point</param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger">
            <summary>
            following paper "Orthogonal Connector Routing" which is included in the project
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Rectilinear.Nudging.Path},System.Double,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Collections.Generic.Dictionary{Microsoft.Msagl.Routing.Shape,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Routing.Shape}})">
            <summary>
             "nudge" paths to decrease the number of intersections and stores the results inside WidePaths of "paths"
            </summary>
            <param name="paths">paths through the graph</param>
            <param name="cornerFitRad">two parallel paths should be separated by this distance if it is feasible</param>
            <param name="obstacles">polygonal convex obstacles organized in a tree; the obstacles here are padded original obstacles</param>
            <param name="ancestorsSets"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.HierarchyOfObstacles">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.HierarchyOfGroups">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.Rectilinearise(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            sometimes we have very small mistakes in the positions that have to be fixed
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.PathToObstacles">
            <summary>
            maps each path to the pair of obstacles; the first element of the pair is 
            where the path starts and the second where the path ends
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.PortToShapes">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.Nudger.NudgePaths(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Rectilinear.Nudging.Path},System.Double,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Collections.Generic.Dictionary{Microsoft.Msagl.Routing.Shape,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Routing.Shape}},System.Boolean)">
            <summary>
            this function defines the final path coordinates
            </summary>
            <param name="paths">the set of paths, point sequences</param>
            <param name="cornerFitRadius">the radius of the arc inscribed into the path corners</param>
            <param name="paddedObstacles">an enumeration of padded obstacles</param>
            <param name="ancestorsSets"></param>
            <param name="removeStaircases"></param>
            <returns>the mapping of the path to its modified path</returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint">
            <summary>
            represents a segment of a path
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner">
            <summary>
            If two paths intersect then insert the intersection point as a vertex into both paths.
            Remove path self loops. Merge paths between the crossings if they have multiple crossings.
            If a path passes through a vertex of another path then insert this vertex into the first path.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.AdjustPaths(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Rectilinear.Nudging.Path})">
            <summary>
            make sure that every two different points in paths are separated by at least 10e-6
            </summary>
            <param name="paths"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.RefineInDirection(Microsoft.Msagl.Core.Geometry.Directions,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint})">
            <summary>
            refines all segments that are parallel to "direction"
            </summary>
            <param name="direction"></param>
            <param name="pathFirstPoints"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathRefiner.RefineCollinearBucket(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint},Microsoft.Msagl.Routing.Rectilinear.Nudging.PointProjection)">
            <summary>
            refine vertices belonging to a bucket; 
            pathLinkedVertices belong to a line parallel to the direction of the refinement
            </summary>
            <param name="pathLinkedVertices"></param>
            <param name="projectionToDirection"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.PointByDelegateComparer.Compare(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <returns>
            Value 
                                Condition 
                                Less than zero
                            <paramref name="x"/> is less than <paramref name="y"/>.
                                Zero
                            <paramref name="x"/> equals <paramref name="y"/>.
                                Greater than zero
                            <paramref name="x"/> is greater than <paramref name="y"/>.
            </returns>
            <param name="x">The first object to compare.
                            </param><param name="y">The second object to compare.
                            </param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge">
            <summary>
            A place holder for an edge in a path to keep it inside of a linked list representing a path.
            Each PathEdge belongs to only one path
            </summary>
            PathEdge passes through the AxisEdge that it points to but may go to the different direction.
            In the last case the PathEdge is marked as Reversed. Several PathEdges can share the same AxisEdge.
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.LongestNudgedSegment">
            <summary>
            It is the offset of the edge from the underlying line segment 
            [VisibilityEdge.SourcePoint, VisibilityEdge.TargetPoint] in to the direction of the VisibilityEdge.Perpendicular.
            Offset holder is the same for the maximal parallel sequence of connected PathEdges
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.IsFixed">
            <summary>
            A fixed edge cannot be shifted from its visibility edge; offset is always 0.
            Such an edge can be, for example, a terminal edge going to a port. 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.Reversed">
            <summary>
            if set to true then in the path the edge is reversed
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathEdge.Index">
            <summary>
            the index of the edge in the order
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment">
            <summary>
            Represent a maximal straight segment of a path
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.CompassDirection">
            <summary>
            has to be North or East
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.Edges">
            <summary>
            the list of edges holding the same offset and direction
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.IsFixed">
            <summary>
            the segments constraining "this" from the right
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.LongestNudgedSegment.Width">
            <summary>
            the maximal width of the edges 
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.Path">
            <summary>
            represents the path for an EdgeGeometry 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.EdgeGeometry">
            <summary>
            the corresponding edge geometry
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.PathPoints">
            <summary>
            the path points
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.#ctor(Microsoft.Msagl.Core.Layout.EdgeGeometry)">
            <summary>
            constructor
            </summary>
            <param name="edgeGeometry"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.Path.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger">
             <summary>
            Avoid a situation where two paths cross each other more than once. Remove self loops.
             
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger.MergePaths">
            <summary>
            Avoid a situation where two paths cross each other more than once. Remove self loops.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Nudging.PathMerger.Before(Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint,Microsoft.Msagl.Routing.Rectilinear.Nudging.LinkedPoint)">
            <summary>
            checks that a is before b in the path
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true is a is before b in the path</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossing.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.GroupBoundaryCrossingMap.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.Root">
            <summary>
            The root of the hierarchy.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.AncestorSets">
            <summary>
            Dictionary of sets of ancestors for each shape, for evaluating necessary group-boundary crossings.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.SpatialAncestorsAdjusted">
            <summary>
            Indicates whether we adjusted spatial ancestors due to blocked paths.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.shapeIdToObstacleMap">
            <summary>
            The map of shapes to obstacles.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CurrentGroupBoundaryCrossingMap">
            <summary>
            The map of all group boundary crossings for the current RestrictSegmentWithObstacles call.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.allObstacles">
            <summary>
            The list of all obstacles (not just those in the Root, which may have accretions of obstacles in convex hulls).
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.overlapPairs">
            <summary>
            For accreting obstacles for clumps or convex hulls.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.hasOverlaps">
            <summary>
            Indicates whether one or more obstacles overlap.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.lookupIntPair">
            <summary>
            Member to avoid unnecessary class creation just to do a lookup.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.Init(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Rectilinear.Obstacle},System.Collections.Generic.Dictionary{Microsoft.Msagl.Routing.Shape,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Routing.Shape}},System.Collections.Generic.Dictionary{Microsoft.Msagl.Routing.Shape,Microsoft.Msagl.Routing.Rectilinear.Obstacle})">
            <summary>
            Create the tree hierarchy from the enumeration.
            </summary>
            <param name="obstacles"></param>
            <param name="ancestorSets"></param>
            <param name="idToObstacleMap"></param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.Count">
            <summary>
            The number of obstacles.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CreateRoot">
            <summary>
            Create the root with overlapping non-rectangular obstacles converted to their convex hulls, for more reliable calculations.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.AdjustSpatialAncestors">
            <summary>
            Add ancestors that are spatial parents - they may not be in the hierarchy, but we need to be
            able to cross their boundaries if we're routing between obstacles on different sides of them.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.Clear">
            <summary>
            Clear the internal state.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.CreateMaxVisibilitySegment(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Directions,Microsoft.Msagl.Routing.Rectilinear.PointAndCrossingsList@)">
            <summary>
            Create a LineSegment that contains the max visibility from startPoint in the desired direction.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.GetAllObstacles">
            <summary>
            Convenience functions that call through to RectangleNode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstacleTree.GetAllPrimaryObstacles">
            <summary>
            Returns a list of all primary obstacles - secondary obstacles inside a convex hull are not needed in the VisibilityGraphGenerator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide">
            <summary>
            BasicObstacleSide is base class for an obstacle side that is to the low or high end of the
            scanline-parallel coordinate, and knows which direction to traverse to find the endVertex.
            This is different from RightObstacleSide or LeftObstacleSide, where the class itself is the
            determinant of traversal direction being with or opposite to the clockwise polyline direction;
            BasicObstacleSide uses the ctor arg traverseClockwise to manage that.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ScanSegmentTree.Compare(Microsoft.Msagl.Routing.Rectilinear.ScanSegment,Microsoft.Msagl.Routing.Rectilinear.ScanSegment)">
            <summary>
            For ordering the line segments inserted by the ScanLine. Assuming vertical sweep (sweeping up from
            bottom, scanning horizontally) then order ScanSegments first by lowest Y coord, then by lowest X coord.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.TransientGraphUtility.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.EventQueue">
            <summary>
            Wrap the tree of events.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.EventQueue.Compare(Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent,Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent)">
            <summary>
            For ordering events in the event list.
            Assuming vertical sweep (sweeping up from bottom, scanning horizontally) then order events
            first by lowest Y coord, then by lowest X coord (thus assuming we use Cartesian coordinates
            (negative is downward == bottom).
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.FreePoint">
            <summary>
            This is a point on a path that is not associated with an obstacle, such as
            a port for the end of a dragged path, or a waypoint.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.FreePoint.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.HighObstacleSide">
            <summary>
            HighObstacleSide is a side of the obstacle that is between LowestVertex and HighestVertex
            to the higher scanline-parallel coordinate-value side; i.e. to the right (higher X-coordinate)
            for horizontal scan (vertical sweep), and to the left (due to Cartesian coordinates) for Y.
            This is different from RightObstacleSide, which refers to the traversal direction being opposite
            the clockwise polyline direction; HighObstacleSide uses the ctor arg traverseClockwise to manage that.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.LowReflectionEvent">
            <summary>
            This records an intersection of a lookahead ray with an obstacle edge.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.LookaheadScan">
            <summary>
            For lookahead points, we record the point of the intersection on the reflecting side, then
            whenever we load a side, we check for active lookahead lines within this range.  Since we
            are just intersecting rays, we only care about the X (H scan) or Y (V scan) coordinate.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.LookaheadScan.Compare(Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent,Microsoft.Msagl.Routing.Rectilinear.BasicReflectionEvent)">
            <summary>
            For ordering Points in the lookahead list.  We just care about the coordinate that changes
            parallel to the scanline, so for vertical sweep (sweeping up from bottom, scanning
            horizontally) then order points by X only, else by Y only.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.LowObstacleSide">
            <summary>
            LowObstacleSide is a side of the obstacle that is between LowestVertex and HighestVertex
            to the lower scanline-parallel coordinate-value side; i.e. to the left (lower X-coordinate)
            for horizontal scan (vertical sweep), and to the right (due to Cartesian coordinates) for Y.
            This is different from LeftObstacleSide, which refers to the traversal direction being along
            the clockwise polyline direction; LowObstacleSide uses the ctor arg traverseClockwise to manage that.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.GetPath(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Visibility.VisibilityVertex},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Visibility.VisibilityVertex})">
            <summary>
            Get the lowest-cost path from one of one or more sources to one of one or more targets, without waypoints.
            </summary>
            <param name="sources">One or more source vertices</param>
            <param name="targets">One or more target vertices</param>
            <returns>A single enumeration of path points.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.GetPath(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Visibility.VisibilityVertex},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Visibility.VisibilityVertex},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Visibility.VisibilityVertex})">
            <summary>
            Get the lowest-cost path from one of one or more sources to one of one or more targets, with waypoints.
            </summary>
            <param name="sources">One or more source vertices</param>
            <param name="waypoints">One or more waypoint vertices</param>
            <param name="targets">One or more target vertices</param>
            <returns>An enumeration of each stage's enumeration of path points</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.MsmtRectilinearPath.GetPathStage(Microsoft.Msagl.Routing.Rectilinear.VertexEntry[],System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Visibility.VisibilityVertex},Microsoft.Msagl.Routing.Rectilinear.VertexEntry[],System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Visibility.VisibilityVertex})">
            <summary>
            Route a single stage of a possibly multi-stage (due to waypoints) path.
            </summary>
            <param name="sourceVertexEntries">The VertexEntry array that was in the source vertex if it was the target of a prior stage.</param>
            <param name="sources">The enumeration of source vertices; must be only one if sourceVertexEntries is non-null.</param>
            <param name="targets">The enumeration of target vertex entries; must be only one if targetVertexEntries is non-null.</param>
            <param name="targetVertexEntries">The VertexEntry array that is in the target at the end of the stage.</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Obstacle.#ctor(Microsoft.Msagl.Routing.Shape,System.Boolean,System.Double)">
            <summary>
            Only public to make the compiler happy about the "where TPoly : new" constraint.
            Will be populated by caller.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Obstacle.PaddedPolyline">
            <summary>
            The padded polyline that is tight to the input shape.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Obstacle.VisibilityPolyline">
            <summary>
            The polyline that is either the PaddedPolyline or a convex hull for multiple overlapping obstacles.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Obstacle.LooseVisibilityPolyline">
            <summary>
            The visibility polyline that is used for intersection comparisons and group obstacle avoidance.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Obstacle.Clump">
            <summary>
            For overlapping obstacle management; this is just some arbitrary obstacle in the clump.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.Obstacle.OverlapsGroupCorner">
            <summary>
            For sparseVg, the obstacle has a group corner inside it.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.Obstacle.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.ObstaclePort.PortCurve">
            <summary>
            The curve associated with the port.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.ObstaclePort.PortLocation">
            <summary>
            The (unrounded) location of the port.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstaclePort.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.ObstaclePortEntrance">
            <summary>
            An ObstaclePortEntrance is a single edge entering or leaving an obstacle in one of the NSEW Compass directions.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ObstaclePortEntrance.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.PortManager">
            <summary>
            This stores information mapping the App-level Ports (e.g. FloatingPort, RelativeFloatingPort,
            and MultiLocationFloatingPort) to the router's BasicScanPort subclasses (ObstaclePort and FreePoint).
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreatePortsAndRouteEdges(System.Double,System.Double,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge},Microsoft.Msagl.Core.Routing.EdgeRoutingMode,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Create a RectilinearEdgeRouter from the passed obstacleNodes, with one port at the center of each obstacle,
            and route between the obstacles.
            </summary>
            <param name="cornerFitRadius">The radius of the arc inscribed into path corners</param>
            <param name="padding">The minimum padding from an obstacle's curve to its enclosing polyline</param>
            <param name="obstacleNodes">The nodes of the graph</param>
            <param name="geometryEdges">Edges defining the nodes to route between, and receiving the resultant paths</param>
            <param name="edgeRoutingMode">Mode of the edges (Rectilinear or RectilinearToCenter).</param>
            <param name="useSparseVisibilityGraph">Use a more memory-efficient but possibly path-suboptimal visibility graph</param>
            <param name="useObstacleRectangles">Use obstacle bounding box rectangles in visibility graph</param>
            <param name="bendPenaltyAsAPercentageOfDistance">The cost penalty for a bend in the path, as a percentage of the Manhattan distance
                        between the source target ports.</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreatePortsAndRouteEdges(System.Double,System.Double,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge},Microsoft.Msagl.Core.Routing.EdgeRoutingMode,System.Boolean,System.Boolean)">
            <summary>
            Create a RectilinearEdgeRouter from the passed obstacleNodes, with one port at the center of each obstacle,
            and route between the obstacles, with default bend penalty.
            </summary>
            <param name="cornerFitRadius">The radius of the arc inscribed into path corners</param>
            <param name="padding">The minimum padding from an obstacle's curve to its enclosing polyline</param>
            <param name="obstacleNodes">The nodes of the graph</param>
            <param name="geometryEdges">Edges defining the nodes to route between, and receiving the resultant paths</param>
            <param name="edgeRoutingMode">Mode of the edges (Rectilinear or RectilinearToCenter).</param>
            <param name="useObstacleRectangles">Use obstacle bounding box rectangles in visibility graph</param>
            <param name="useSparseVisibilityGraph">Use a more memory-efficient but possibly path-suboptimal visibility graph</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreatePortsAndRouteEdges(System.Double,System.Double,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge},Microsoft.Msagl.Core.Routing.EdgeRoutingMode,System.Boolean)">
            <summary>
            Create a RectilinearEdgeRouter from the passed obstacleNodes, with one port at the center of each obstacle,
            and route between the obstacles, with default bend penalty.
            </summary>
            <param name="cornerFitRadius">The radius of the arc inscribed into path corners</param>
            <param name="padding">The minimum padding from an obstacle's curve to its enclosing polyline</param>
            <param name="obstacleNodes">The nodes of the graph</param>
            <param name="geometryEdges">Edges defining the nodes to route between, and receiving the resultant paths</param>
            <param name="edgeRoutingMode">Mode of the edges (Rectilinear or RectilinearToCenter).</param>
            <param name="useSparseVisibilityGraph">Use a more memory-efficient but possibly path-suboptimal visibility graph</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.FillRouter(System.Double,System.Double,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Node},System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge},Microsoft.Msagl.Core.Routing.EdgeRoutingMode,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Create a RectilinearEdgeRouter populated with the passed obstacles.
            </summary>
            <returns>The populated RectilinearEdgeRouter</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateSimpleEdgeCurveWithGivenFitRadius(Microsoft.Msagl.Core.Layout.Edge,System.Double)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="cornerFitRadius"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateSimpleEdgeCurve(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            creates an edge curve based only on the source and target geometry
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Create a Shape with a single relative port at its center.
            </summary>
            <param name="node">The node from which the shape is derived</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath">
            <summary>
            single source single target rectilinear path
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.CombinedCost(System.Double,System.Double)">
            <summary>
            The cost of the path calculation
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.queue">
            <summary>
            The priority queue for path extensions.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.visitedVertices">
            <summary>
            The list of vertices we've visited for all paths.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.nextNeighbors">
            <summary>
            The next neighbors to extend the path to from the current vertex.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SsstRectilinearPath.HeuristicDistanceFromVertexToTarget(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Directions)">
            <summary>
            estimation from below for the distance
            </summary>
            <param name="point"></param>
            <param name="entryDirToVertex"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter">
            <summary>
            Provides rectilinear edge routing functionality 
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.Padding">
            <summary>
            If an edge does not connect to an obstacle it should stay away from it at least at the padding distance
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.CornerFitRadius">
            <summary>
            The radius of the arc inscribed into the path corners.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.BendPenaltyAsAPercentageOfDistance">
            <summary>
            The relative penalty of a bend, representated as a percentage of the Manhattan distance between
            two ports being connected.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RouteToCenterOfObstacles">
            <summary>
            If true, route to obstacle centers.  Initially false for greater accuracy with the current 
            MultiSourceMultiTarget approach.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.LimitPortVisibilitySpliceToEndpointBoundingBox">
            <summary>
            If true, limits the extension of port visibility splices into the visibility graph to the rectangle defined by
            the path endpoints.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.AddEdgeGeometryToRoute(Microsoft.Msagl.Core.Layout.EdgeGeometry)">
            <summary>
            Add an EdgeGeometry to route
            </summary>
            <param name="edgeGeometry"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RemoveEdgeGeometryToRoute(Microsoft.Msagl.Core.Layout.EdgeGeometry)">
            <summary>
            Remove a routing specification for an EdgeGeometry.
            </summary>
            <param name="edgeGeometry"></param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.EdgeGeometriesToRoute">
            <summary>
            List all edge routing specifications that are currently active.  We want to hide access to the
            List itself so people don't add or remove items directly.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RemoveAllEdgeGeometriesToRoute">
            <summary>
            Remove all EdgeGeometries to route
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.UseSparseVisibilityGraph">
            <summary>
            If true, this router uses a sparse visibility graph, which saves memory for large graphs but
            may choose suboptimal paths.  Set on constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.UseObstacleRectangles">
            <summary>
            If true, this router uses obstacle bounding box rectangles in the visibility graph.
            Set on constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.Obstacles">
            <summary>
            The collection of input shapes to route around. Contains all source and target shapes.
            as well as any intervening obstacles.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.PaddedObstacles">
            <summary>
            The collection of padded obstacle boundary polylines around the input shapes to route around.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.AddObstacles(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Shape})">
            <summary>
            Add obstacles to the router.
            </summary>
            <param name="obstacles"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.AddObstacle(Microsoft.Msagl.Routing.Shape)">
            <summary>
            Add a single obstacle to the router.
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.UpdateObstacles(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Shape})">
            <summary>
            For each Shapes, update its position and reroute as necessary.
            </summary>
            <param name="obstacles"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.UpdateObstacle(Microsoft.Msagl.Routing.Shape)">
            <summary>
            For each Shapes, update its position and reroute as necessary.
            </summary>
            <param name="obstacle"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RemoveObstacles(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Shape})">
            <summary>
            Remove obstacles from the router.
            </summary>
            <param name="obstacles"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RemoveObstacle(Microsoft.Msagl.Routing.Shape)">
            <summary>
            Removes an obstacle from the router.
            </summary>
            <param name="obstacle"></param>
            <returns>All EdgeGeometries affected by the re-routing and re-nudging in order to avoid the new obstacle.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RemoveAllObstacles">
            <summary>
            Remove all obstacles from the graph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.VisibilityGraph">
            <summary>
            The visibility graph generated by GenerateVisibilityGraph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.Clear">
            <summary>
            Clears all data set into the router.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.GraphGenerator">
            <summary>
            Generates the visibility graph.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.ShapeToObstacleMap">
            <summary>
            To support dynamic obstacles, we index obstacles by their Shape, which is
            the unpadded inner obstacle boundary and contains a unique ID so we can
            handle overlap due to dragging.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.EdgeGeometries">
            <summary>
             The list of EdgeGeometries to route
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.PortManager">
            <summary>
             Manages the mapping between App-level Ports, their locations, and their containing EdgeGeometries.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.DefaultPadding">
            <summary>
            The padding from an obstacle's curve to its enclosing polyline.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.DefaultCornerFitRadius">
            <summary>
            The default radius of the arc inscribed into path corners.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Shape})">
            <summary>
            Constructor that takes the obstacles but uses defaults for other arguments.
            </summary>
            <param name="obstacles">The collection of shapes to route around. Contains all source and target shapes
            as well as any intervening obstacles.</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Shape},System.Double,System.Double,System.Boolean)">
            <summary>
            Constructor for a router that does not use obstacle rectangles in the visibility graph.
            </summary>
            <param name="obstacles">The collection of shapes to route around. Contains all source and target shapes
            as well as any intervening obstacles.</param>
            <param name="padding">The minimum padding from an obstacle's curve to its enclosing polyline.</param>
            <param name="cornerFitRadius">The radius of the arc inscribed into path corners</param>
            <param name="useSparseVisibilityGraph">If true, use a sparse visibility graph, which saves memory for large graphs
            but may select suboptimal paths</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Routing.Shape},System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Constructor specifying graph and shape information.
            </summary>
            <param name="obstacles">The collection of shapes to route around. Contains all source and target shapes
            as well as any intervening obstacles.</param>
            <param name="padding">The minimum padding from an obstacle's curve to its enclosing polyline.</param>
            <param name="cornerFitRadius">The radius of the arc inscribed into path corners</param>
            <param name="useSparseVisibilityGraph">If true, use a sparse visibility graph, which saves memory for large graphs
            but may select suboptimal paths</param>
            <param name="useObstacleRectangles">Use obstacle bounding boxes in visibility graph</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double,System.Boolean)">
            <summary>
            Constructor specifying graph information.
            </summary>
            <param name="graph">The graph whose edges are being routed.</param>
            <param name="padding">The minimum padding from an obstacle's curve to its enclosing polyline.</param>
            <param name="cornerFitRadius">The radius of the arc inscribed into path corners</param>
            <param name="useSparseVisibilityGraph">If true, use a sparse visibility graph, which saves memory for large graphs
            but may select suboptimal paths</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Constructor specifying graph information.
            </summary>
            <param name="graph">The graph whose edges are being routed.</param>
            <param name="padding">The minimum padding from an obstacle's curve to its enclosing polyline.</param>
            <param name="cornerFitRadius">The radius of the arc inscribed into path corners</param>
            <param name="useSparseVisibilityGraph">If true, use a sparse visibility graph, which saves memory for large graphs
            but may select suboptimal paths</param>
            <param name="useObstacleRectangles">If true, use obstacle bounding boxes in visibility graph</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RouteEdges">
            <summary>
            Calculates the routed edges geometry, optionally forcing re-routing for existing paths.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.RemoveStaircases">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearEdgeRouter.GenerateVisibilityGraph">
            <summary>
            Generates the visibility graph if it hasn't already been done.
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.HighReflectionEvent">
            <summary>
            This records an intersection of a lookahead ray with an obstacle edge.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ScanDirection.ToString">
            <summary/>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearScanLine.Compare(Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide,Microsoft.Msagl.Routing.Rectilinear.BasicObstacleSide)">
            <summary>
            For ordering lines along the scanline at segment starts/ends.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.RectilinearScanLine.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.ScanSegment.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.Compare(Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent,Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent)">
            <summary>
            For ordering events first by Y, then X, then by whether it's an H or V seg.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.Compare(Microsoft.Msagl.Routing.Rectilinear.ScanSegment,Microsoft.Msagl.Routing.Rectilinear.ScanSegment)">
            <summary>
            For ordering V segments in the scanline by X.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.SegmentIntersector.SegEvent.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Rectilinear.WaypointPort">
            <summary>
            keep this class internal, it not a full fledged Port
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.WaypointPort.#ctor(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            
            </summary>
            <param name="location"></param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Rectilinear.WaypointPort.Location">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Determines whether the specified Points, which are assumed to have been Round()ed,
            are close enough to be considered equal.
            </summary>
            <param name="a">The first object of type Point to compare.</param>
            <param name="b">The second object of type Point to compare.</param>
            <returns>True if the inputs are close enough to be considered equal, else false</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.PointComparer.Equal(System.Double,System.Double)">
            <summary>
            Determines whether the specified double values, which are assumed to have been Round()ed,
            are close enough to be considered equal.
            </summary>
            <param name="x">The first double value to compare.</param>
            <param name="y">The second double value to compare.</param>
            <returns>True if the inputs are close enough to be considered equal, else false</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare(System.Double,System.Double)">
            <summary>
            The usual Compare operation, with inputs that are assumed to have been Round()ed.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is 
            less than rhs, else 1.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.PointComparer.Compare(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            The usual Compare operation, with inputs that are assumed to have been Round()ed.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is 
            less than rhs, else 1.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.PointComparer.LessOrEqual(System.Double,System.Double)">
            <summary>
            return true if less or equal holds for two values that are assumed to have been Round()ed
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Rectilinear.PointComparer.Less(System.Double,System.Double)">
            <summary>
            return true if less holds for two values that are assumed to have been Round()ed
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ShapeCreator">
            <summary>
            Class for creating Shape elements from a Graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ShapeCreator.GetShapes(Microsoft.Msagl.Core.Layout.GeometryGraph)">
            <summary>
            For a given graph finds the obstacles for nodes and clusters, correctly parenting the obstacles
            according to the cluster hierarchy
            </summary>
            <param name="graph">graph with edges to route and nodes/clusters to route around</param>
            <returns>the set of obstacles with correct cluster hierarchy and ports</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ShapeCreator.CreateShapeWithCenterPort(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Creates a shape with a RelativeFloatingPort for the node center, attaches it to the shape and all edges
            </summary>
            <param name="node"></param>
            <returns>Shape obstacle for the node with simple port</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ShapeCreator.CreateShapeWithClusterBoundaryPort(Microsoft.Msagl.Core.Layout.Node)">
            <summary>
            Creates a ClusterBoundaryPort for the cluster boundary, attaches it to the shape and all edges
            </summary>
            <param name="node"></param>
            <returns>Shape obstacle for the node with simple port</returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ShapeCreatorForRoutingToParents">
            <summary>
            written in assumption of a single parent
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.ShapeObstacleCalculator">
            <summary>
            The class calculates obstacles under the shape.
            We assume that the boundaries are not set for the shape children yet
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.ShapeObstacleCalculator.ShapeIsInsideOfPoly(Microsoft.Msagl.Routing.Shape,Microsoft.Msagl.Core.Geometry.Curves.Polyline)">
            <summary>
            this test is valid in our situation were the tight polylines are disjoint and the shape can cross only one of them
            </summary>
            <param name="shape"></param>
            <param name="tightPolyline"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.RouteEdges">
            <summary>
            routing of the edges minimizing (ink+path length+capacity penalty)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.RerouteEdge(Microsoft.Msagl.Core.Layout.EdgeGeometry)">
            <summary>
            Reroute edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SdShortestPath.FillCrossedCdtEdges(System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Layout.EdgeGeometry,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Routing.CdtEdge}})">
            <summary>
            compute cdt edges crossed by paths
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.OutgoingBundleInfo">
            <summary>
            only one of those is not null
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.Curve">
            <summary>
            boundary of cluster or hub containing this base 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.IsParent">
            <summary>
            this bundle base sits on a cluster boundary and the opposite base sits on a child of the cluster 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.BelongsToRealNode">
            <summary>
            if true then the base sits on a real node or cluster, otherwise it belongs to an intermediate hub
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.Position">
            <summary>
            position of the station containing the base
            (could be a center of a hub, or a point on the boundary of a cluster)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.#ctor(System.Int32,Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Point,System.Boolean,System.Int32)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ParRight">
            <summary>
            corresponds to the left point of the base
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Spline.Bundling.BundleBase.ParLeft">
            <summary>
            corresponds to the right point of the base
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.RegularCut(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            find a cut point for 2 segments
            </summary>
            <returns>true if the segment interiors intersect</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.BundleBasesCalculator.IntervalsOverlapLength(System.Double,System.Double,System.Double,System.Double,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            returns the length of the overlapped interval in parameter space
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="d"></param>
            <param name="curve"></param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter">
            <summary>
            The class is responsible for general edge bundling with ordered bundles.
            Currently the router will fail if there are node overlaps.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.Status">
            <summary>
             reports the status of the bundling
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.RunInternal">
            <summary>
            edge routing with Ordered Bundles:
            1. route edges with bundling
            2. nudge bundles and hubs
            3. order paths
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.FixChildParentEdges">
            <summary>
            set endpoint of the edge from child to parent (cluster) to the boundary of the parent
            TODO: is there a better solution?
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.BundleRouter.AnalyzeEdgeSeparation">
            <summary>
            calculates maximum possible edge separation for the computed routing
              if it is greater than bundlingSettings.EdgeSeparation, then proceed 
              if it is smaller, then either
                stop edge bundling, or
                reduce edge separation, or
                move obstacles to get more free space
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus.Success">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus.Overlaps">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.BundlingStatus.EdgeSeparationIsTooLarge">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections">
            <summary>
            Check intersections between edges and obstacles using triangulation (faster than kd-tree)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.BundleAvoidsObstacles(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Collections.Generic.List{System.Tuple{Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point}}@)">
            <summary>
            returns false iff the edge overlap an obstacle
            otherwise it calulates distances to the closest obstacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.FindCloseObstaclesForBundle(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Double)">
            <summary>
            returns null iff the edge overlap an obstacle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.ThreadLineSegmentThroughTriangles(Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Collections.Generic.List{Microsoft.Msagl.Routing.ConstrainedDelaunayTriangulation.CdtTriangle}@)">
            <summary>
            returns false iff the edge overlap an obstacle
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.EdgeIsLegal(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            checks if an edge intersects obstacles
            otherwise it calulates distances to the closest obstacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CdtIntersections.EdgeIsLegal(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Core.Geometry.Curves.Polyline})">
            <summary>
            checks if an edge intersects obstacles
            otherwise it calulates distances to the closest obstacles
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger">
            <summary>
            this class nudges the edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.#ctor(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.CreateMetroOrdering">
            <summary>
            bundle-map ordering
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.BiArc(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Following "Biarc approximation of NURBS curves", Les A. Piegl, and Wayne Tiller. The paper has a bug in V, where they write that v=p0+p4, it is p0-p4.
            Also I treat special cases differently.
            </summary>
            <param name="p0"></param>
            <param name="ts"></param>
            <param name="p4"></param>
            <param name="te"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.ArcOn(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns the arc that a,b,c touches
            </summary>
            <param name="a">belongs to the arc, the tangent point of ba</param>
            <param name="b">ba, and bc are tangents to the arc</param>
            <param name="c">belongs to the arc, the tangent point of bc</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.FanCouple(Microsoft.Msagl.Routing.Spline.Bundling.BundleBase,System.Int32,Microsoft.Msagl.Core.Geometry.Point,System.Double)">
            <summary>
            fans the couple i,i+1
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.EdgeNudger.NicelyAligned(Microsoft.Msagl.Core.Geometry.Curves.CubicBezierSegment,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="longerSeg"></param>
            <param name="del0"></param>
            <param name="del1"></param>
            <param name="midPointOfShorter"></param>
            <param name="minDelLength"></param>
            <param name="maxDelLen"></param>
            <returns> 1 - need to stretch, -1 - need to squeze, 0 - OK </returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.FlipCollapser.CollapseFlip(Microsoft.Msagl.Core.Geometry.Curves.Polyline,Microsoft.Msagl.Core.Geometry.Curves.Polyline)">
            <summary>
            try to collapse the polylines reducing routing cost
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>
            returns the changed polyline
            </returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.FlipCollapser.RandomCost(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint)">
            <summary>
            this function should be called very rarely
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering">
            <summary>
            greedy bundle map ordering based on path comparison
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.Metrolines">
            <summary>
            bundle lines
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.#ctor(System.Collections.Generic.List{Microsoft.Msagl.Routing.Spline.Bundling.Metroline})">
            <summary>
            Initialize bundle graph and build the ordering
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.Microsoft#Msagl#Routing#Spline#Bundling#IMetroMapOrderingAlgorithm#GetOrder(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            Get the ordering of lines on station u with respect to the edge (u->v)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.GetLineCount(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Get the number of lines passing through edge (u->v)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.Microsoft#Msagl#Routing#Spline#Bundling#IMetroMapOrderingAlgorithm#GetLineIndexInOrder(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Metroline)">
            <summary>
            Get the index of line on the edge (u->v) and node u
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.BuildOrder">
            <summary>
            Do the main job
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.BuildOrder(Microsoft.Msagl.Core.Geometry.PointPair,Microsoft.Msagl.Routing.Spline.Bundling.PointPairOrder)">
            <summary>
            Build order for edge (u->v)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.CompareLines(Microsoft.Msagl.Routing.Spline.Bundling.Metroline,Microsoft.Msagl.Routing.Spline.Bundling.Metroline,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Compare two lines on station u with respect to edge (u->v)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.FindStationOnLine(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Routing.Spline.Bundling.Metroline,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint@,System.Func{Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint}@,System.Func{Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint}@)">
            <summary>
            Reimplement it in more efficient way!!! (cache indexes)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.GeneralMetroMapOrdering.IsLeft(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Compare polar angles of v1 and v2 with respect to v0
            (v1 lyes to the left of v2 ?)
            </summary>
            <returns>
             -1  if v1 lyes to the left of v2
              1  if v1 lyes to the right of v2
              0  if v1 and v2 are collinear (and codirectinal)
            </returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.HubDebugger">
            <summary>
            this class nudges the edges
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator">
            <summary>
            Calculates node radii with 'water algorithm'
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.metroGraphData">
            <summary>
            bundle data
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.bundlingSettings">
            <summary>
            Algorithm settings
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CreateNodeRadii">
            <summary>
            calculate node radii with fixed hubs
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GrowHubs(System.Boolean)">
            <summary>
            Grow hubs
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateAllowedHubRadius(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
             Returns the maximal possible radius of the node
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadius(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings,Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            Returns the ideal radius of the hub
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings,Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            Returns the ideal radius of the hub
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings,Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Returns the ideal radius of the hub
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings,Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            Returns the ideal radius of the hub
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles(System.Double,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double,Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Radius we need to draw to separate adjacent bundles ab and ac
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesOld(System.Double,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Double,System.Double,Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Radius we need to draw two adjacent bundles ab and ac
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.IMetroMapOrderingAlgorithm">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.IMetroMapOrderingAlgorithm.GetLineIndexInOrder(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Metroline)">
            <summary>
            Get the index of line on the edge (u->v) and node u
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator">
            <summary>
            Calculates the cost of the routing
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.InkError(System.Double,System.Double,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Error of ink
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.PathLengthsError(System.Double,System.Double,System.Double,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Error of path lengths
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RError(System.Double,System.Double,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Error of hubs
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.BundleError(System.Double,System.Double,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Error of bundles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.Cost(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Cost of the whole graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.CostOfForces(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Cost of the whole graph (hubs and bundles)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.QGain(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Gain of 'ink' function
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.InkGain(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Gain of ink
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.PathLengthsGain(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Gain of path lengths
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.RadiusGain(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Gain of radii
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.CostCalculator.BundleGain(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Gain of bundles
            if a newPosition is not valid (e.g. intersect obstacles) the result is -inf
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.IntersectionCache">
            <summary>
            Stores intersections between edges, hubs, and obstacles to speed up simulated annealing
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.Intersections">
            <summary>
            Check intersections between hubs and obstacles with kd-tree
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Spline.Bundling.Intersections.obstacleTree">
            <summary>
            represents loose or tight hierarchy
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.Intersections.IntersectCircleWithTree(Microsoft.Msagl.Core.Geometry.RectangleNode{Microsoft.Msagl.Core.Geometry.Curves.Polyline},Microsoft.Msagl.Core.Geometry.Point,System.Double,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Core.Geometry.Curves.Polyline},System.Collections.Generic.List{System.Tuple{Microsoft.Msagl.Core.Geometry.Curves.Polyline,Microsoft.Msagl.Core.Geometry.Point}},System.Double@)">
            <summary>
            Computes the intersection between the hub and obstacles
            </summary>
            <param name="node"></param>
            <param name="center"></param>
            <param name="radius"></param>
            <param name="obstaclesToIgnore">these are the obstacles the are ignored by the method</param>
            <param name="touchedObstacles">list of pairs (obstacle, closest point on the obstacle)</param>
            <param name="minimalDistance">min distance from the center to an obstacle</param>
            <returns>false iff center is inside of an obstacle</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.Intersections.LineSegmentIntersectPolyline(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Curves.Polyline)">
            <summary>
            faster way to check segment-polyline intersection
            NOTE: polyline points should be oriented clockwise
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering">
            <summary>
            Linear algorithm as described in our paper
            Edge Routing with Ordered Bunldles
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetrolinesGlobal">
            <summary>
            bundle lines
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.positions">
            <summary>
            Station positions
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.#ctor(System.Collections.Generic.List{Microsoft.Msagl.Routing.Spline.Bundling.Metroline},System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Routing.Spline.Bundling.Station})">
            <summary>
            Initialize bundle graph and build the ordering
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.Microsoft#Msagl#Routing#Spline#Bundling#IMetroMapOrderingAlgorithm#GetOrder(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            Get the ordering of lines on station u with respect to the edge (u->v)
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.Microsoft#Msagl#Routing#Spline#Bundling#IMetroMapOrderingAlgorithm#GetLineIndexInOrder(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Metroline)">
            <summary>
            Get the index of line on the edge (u->v) and node u
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge">
            <summary>
            Edge in graph H
            label is used to distinguish multiple edges
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge.Equals(System.Object)">
            <summary>
            overrides the equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathList">
            <summary>
            unordered list of paths on a specified edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.BuildOrder">
            <summary>
            Do the main job
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.UpdateAdjacencyData(System.Int32,Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge,System.Collections.Generic.List{Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathList})">
            <summary>
            update adjacencies of node 'a': put new edges instead of oldEdge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.RestoreResult(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge)">
            <summary>
            recursively build an order on the edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.ProcessNonTerminal(System.Int32)">
            <summary>
            Remove vertex v from the graph. Update graph and paths correspondingly
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.RadixSort(System.Int32)">
            <summary>
            Linear sorting of paths passing through vertex v
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.FindNextEdgeOnPath(System.Int32,Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge)">
            <summary>
            extract the next edge on a given path after node v
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.OppositeNode(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge,System.Int32)">
            <summary>
            return an opposite vertex of a given edge
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.UpdatePath(Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.PathOnEdge,System.Int32,Microsoft.Msagl.Routing.Spline.Bundling.LinearMetroMapOrdering.MetroEdge)">
            <summary>
            replace edges (av) and (vb) with edge (ab) on a given path
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData">
            <summary>
            Wrapper for geometry graph with coinciding edges:
             'real' nodes stand for edge ends (source,target)
             'virtual' nodes stand for polyline control points
             
             'real' edges are original graph edges
             'virtual' edges are polyline segments
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.edgeInfoDictionary">
            info on the edges passing through a couple
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.ink">
            current ink
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.metrolines">
            Edges
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.PointToStations">
             position -> (node)
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.looseIntersections">
             objects to check crossings and calculate distances
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.cdtIntersections">
             objects to check crossings and calculate distances
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.Cdt">
            <summary>
            triangulation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.RealEdgeCount(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            number of real edges passing the node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.RealEdgeCount(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            number of real edges passing the edge uv
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.MetroNodeInfosOfNode(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            real edges passing the node
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.GetIjInfo(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            real edges passing the edge uv
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.MoveNode(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Move node to the specified position
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.Initialize">
            <summary>
            Initialize data
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.Initialize(System.Boolean)">
            <summary>
            Initialize data
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.SimplifyRegularEdges">
            <summary>
            remove self-cycles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.SimplifyRegularEdge(Microsoft.Msagl.Core.Layout.EdgeGeometry)">
            <summary>
            change the polyline by removing cycles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData.InitializeVirtualGraph">
            <summary>
            Initialize graph comprised of stations and their neighbors
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.Metroline">
            <summary>
            holds the data of a path
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster">
            <summary>
            Adjust current bundle-routing with a number of heuristic
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.bundlingSettings">
            <summary>
            Algorithm settings
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.metroGraphData">
            <summary>
            bundle data
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.FixRouting(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            apply a number of heuristics to improve current routing
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.GlueConflictingNodes">
            <summary>
            unite the nodes that are close to each other
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.NodeGluingIsAllowed(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station,System.Collections.Generic.Dictionary{Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Routing.Spline.Bundling.Station})">
            <summary>
            trying to glue i to j
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.UnglueEdgesFromBundleToSaveInk(System.Boolean)">
            <summary>
            Unbundle unnecessary edges:
             instead of one bundle (a->bcd) we get two bundles (a->b,a->cd) with smaller ink
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.SeparationShortcutAllowed(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,System.Collections.Generic.Dictionary{Microsoft.Msagl.Core.Geometry.PointPair,Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Routing.Spline.Bundling.Metroline}},Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Core.Geometry.Curves.Polyline})">
            <summary>
            allowed iff line (a,c) is legal and inkgain > 0
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.GlueCollinearNeighbors(System.Int32)">
            <summary>
            Fix the situation where a station has two neighbors that are almost in the same directions
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.RelaxConstrainedEdges">
            <summary>
            split each edge that is too much constrained by the obstacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.NodePositionsAdjuster.RemoveDoublePathCrossings">
            <summary>
            switch flips
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing">
            <summary>
            Adjust current bundle-routing
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.metroGraphData">
            <summary>
            bundle data
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.bundlingSettings">
            <summary>
            Algorithm settings
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.costCalculator">
             calculates rouing cost
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.cache">
             used for fast calculation of intersections
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting(Microsoft.Msagl.Routing.Spline.Bundling.MetroGraphData,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            fix routing by simulated annealing algorithm
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.FixRouting(System.Collections.Generic.HashSet{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            Use constraint edge routing to reduce ink
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.Converged(System.Double,System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Point},System.Collections.Generic.List{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            stop SA if relative changes are small
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.TryMoveNode(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            Move node to decrease the cost of the drawing
            Returns true iff position has changed
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.BuildDirection(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            Calculate the direction to improve the ink function
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.CostGain(Microsoft.Msagl.Routing.Spline.Bundling.Station,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Computes cost delta when moving the node
            the cost will be negative if a new position overlaps obstacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.BuildForceForInk(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            force to decrease ink
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.BuildForceForPathLengths(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            direction to decrease path lengths
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.BuildForceForRadius(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            direction to increase radii
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.SimulatedAnnealing.BuildForceForBundle(Microsoft.Msagl.Routing.Spline.Bundling.Station)">
            <summary>
            direction to push a bundle away from obstacle
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.SerialNumber">
            <summary>
            id of the station (used for comparison)
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.IsRealNode">
            <summary>
            if true the station is a center of an obstacle
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.Radius">
            <summary>
            radius of the corresponding hub
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.Position">
            <summary>
            position of the corresponding hub
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.Neighbors">
            <summary>
            neighbors sorted in counter-clockwise order around the station
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.BundleBases">
            <summary>
            it maps each neighbor to its hub
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.EnterableTightPolylines">
            <summary>
            it maps a node to a set of tight polylines that can contain the node
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.EnterableLoosePolylines">
            <summary>
            it maps a node to a set of loose polylines that can contain the node
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.MetroNodeInfos">
            <summary>
            MetroNodeInfos corresponding to the node
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.BoundaryCurve">
            <summary>
            curve of the hub
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.Bundling.Station.CdtTriangle">
            <summary>
            triangle of cdt where the station is situated
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer">
            <summary>
            Outputs run time in debug mode 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer.Run(Microsoft.Msagl.Routing.Spline.Bundling.TimeMeasurer.Task)">
            <summary>
            Run the task and outputs its execution time
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeClosureEvent">
            <summary>
            this event caused by the intersection of a ObstacleSideSegment and the other cone side of the same cone
            when this event happens the cone has to be removed
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSpanner.Bidirectional">
            <summary>
            If set to true then a smaller visibility graph is created.
            An edge is added to the visibility graph only if it is found at least twice: 
            once sweeping with a direction d and the second time with -d
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.ConeSpanner.LeftIntersectionEvent">
            <summary>
            left here means an intersection of a left cone side with an obstacle edge
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations">
            <summary>
            Sweeps a given direction of cones and adds discovered edges to the graph.
            The cones can only start at ports here.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeperForPortLocations.FixConeRightSideIntersections(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.DataStructures.RBNode{Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide})">
            <summary>
            
            </summary>
            <param name="obstSideEndVertex"></param>
            <param name="rbNode">represents a node of the right cone side</param>
            <param name="obstSideStartVertex"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.ConeSpanner.ObstacleSide.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.ConeSpanner.RightIntersectionEvent">
            <summary>
            right here means an intersection of a right cone side with an obstacle edge
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper">
            <summary>
            sweeps a given direction of cones and adds discovered edges to the graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.ConeSpanner.LineSweeper.FixConeRightSideIntersections(Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide,Microsoft.Msagl.Core.DataStructures.RBNode{Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide})">
            <summary>
            
            </summary>
            <param name="rightSide"></param>
            <param name="rbNode">represents a node of the right cone side</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent.ToString">
            <summary/>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide">
            <summary>
            represents a cone side that is broken by the obstacle 
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.start">
            <summary>
            point where it starts
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Spline.ConeSpanner.BrokenConeSide.ConeSide">
            <summary>
            it is the side of the cone that intersects the obstacle side
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Spline.ConeSpanner.ConeSide">
            <summary>
            represents a cone side
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.GetPath">
            <summary>
            Returns  a  path
            </summary>
            <returns>a path or null if the target is not reachable from the source</returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.TightLooseCouple">
            <summary>
            an utility class to keep different polylines created around a shape
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.TightLooseCouple.Distance">
            <summary>
            the loose polyline has been created with this distance
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.TightLooseCouple.GetHashCode">
            <summary>
            compare just by TightPolyline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.TightLooseCouple.Equals(System.Object)">
            <summary>
            compare just by TightPolyline
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.StraightLineEdges">
            <summary>
            Basic edge router for producing straight edges.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.StraightLineEdges.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge},System.Double)">
            <summary>
            Constructs a basic straight edge router.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.StraightLineEdges.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.StraightLineEdges.RouteEdge(Microsoft.Msagl.Core.Layout.Edge,System.Double)">
            <summary>
            populate the geometry including curve and arrowhead positioning for the given edge using simple
            straight line routing style.  Self edges will be drawn as a loop, padding is used to control the
            size of the loop.
            </summary>
            <param name="edge">edge to route</param>
            <param name="padding">controls size of loop</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.StraightLineEdges.CreateLoop(Microsoft.Msagl.Core.Geometry.Rectangle,Microsoft.Msagl.Core.Geometry.Rectangle,System.Double,System.Boolean)">
            <summary>
            creates a loop from sourceBox center to the closest point on the targetBox boundary
            </summary>
            <param name="sourceBox"></param>
            <param name="targetBox">contains sourceBox</param>
            <param name="howMuchToStickOut"></param>
            <param name="reverse">reverse the loop if true</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.StraightLineEdges.GetEdgeLine(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            Returns a line segment for the given edge.
            </summary>
            <returns>The line segment representing the given edge.</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
            creates an edge curve based only on the source and target geometry
            </summary>
            <param name="edge"></param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.InteractiveEdgeRouter">
            <summary>
            the router between nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.Obstacles">
            <summary>
            the obstacles for routing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.EnteringAngleBound">
            <summary>
            the minimum angle between a node boundary curve and and an edge 
            curve at the place where the edge curve intersects the node boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.SourceLoosePolyline">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.TargetTightPolyline">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.SourcePort">
            <summary>
            the port of the edge start
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.TargetPort">
            <summary>
            the port of the edge end
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.TightPadding">
            <summary>
            the curve should not come closer than Padding to the nodes
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.LoosePadding">
            <summary>
            we further pad each node but not more than LoosePadding.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.OffsetForPolylineRelaxing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Double,System.Double,System.Double)">
            <summary>
            Set up the router and calculate the set of obstacles over which to route.
            </summary>
            <param name="obstacles">the obstacles for routing</param>
            <param name="padding">obstacles are inflated by this much to find an inner boundary within which edges cannot enter</param>
            <param name="loosePadding">
            obstacles are inflated again by this much to find initial 
            routing but then spline smoothing is allowed to come inside this outer boundary.
            Loose padding of 0 will give sharp corners (no spline smoothing)</param>
            <param name="coneSpannerAngle">if this is greater than 0 then a "cone spanner" visibility graph with be
            generated using cones of the specified angle to search for visibility edges.  The cone spanner graph is
            a sparser graph than the complete visibility graph and is hence much faster to generate and route over
            but may not give strictly shortest path routes</param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.ExpectedProgressSteps">
            <summary>
            The expected number of progress steps this algorithm will take.
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.InteractiveEdgeRouter.UseInnerPolylingShortcutting">
            <summary>
            if set to true the algorithm will try to shortcut a shortest polyline inner points
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.InteractiveEdgeRouter.UsePolylineEndShortcutting">
            <summary>
            if set to true the algorithm will try to shortcut a shortest polyline start and end
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.#ctor">
            <summary>
            An empty constructor for calling it from inside of MSAGL
            </summary>        
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.SmoothCorners(Microsoft.Msagl.Core.Geometry.SmoothedPolyline)">
            <summary>
            smoothing the corners of the polyline
            </summary>
            <param name="edgePolyline"></param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.CacheCorners">
            <summary>
            is set to true will cache three points defining the corner 
            to avoid obstacle avoidance calculation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.TryToRemoveInflectionsAndCollinearSegments(Microsoft.Msagl.Core.Geometry.SmoothedPolyline)">
            <summary>
            
            </summary>
            <param name="underlyingPolyline"></param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.OverlapsDetected">
            <summary>
            returns true if the nodes overlap or just positioned too close
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveEdgeRouter.ConeSpannerAngle">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.RouteEdgeToLocation(Microsoft.Msagl.Core.Geometry.Point)">
             <summary>
            
             </summary>
             <param name="targetLocation"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.RouteEdgeToPort(Microsoft.Msagl.Core.Layout.Port,Microsoft.Msagl.Core.Geometry.Curves.Polyline,System.Boolean,Microsoft.Msagl.Core.Geometry.SmoothedPolyline@)">
            <summary>
            routes the edge to the port
            </summary>
            <param name="edgeTargetPort"></param>
            <param name="portLoosePolyline"></param>
            <param name="smooth"> if true will smooth the edge avoiding the obstacles, will take more time</param>
            <param name="smoothedPolyline"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.ICurve},System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            </summary>
            <param name="obstacles"></param>
            <param name="padding"></param>
            <param name="loosePadding"></param>
            <param name="coneSpannerAngle"></param>
            <param name="ignoreTightPadding"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetHitLoosePolyline(Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            returns the hit object
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.Clean">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.SetSourcePortAndSourceLoosePolyline(Microsoft.Msagl.Core.Layout.Port,Microsoft.Msagl.Core.Geometry.Curves.Polyline)">
            <summary>
            setting source port and the loose polyline of the port
            </summary>
            <param name="port"></param>
            <param name="sourceLoosePolylinePar"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.RunInternal">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(Microsoft.Msagl.Core.Layout.Port,Microsoft.Msagl.Core.Layout.Port,System.Boolean,Microsoft.Msagl.Core.Geometry.SmoothedPolyline@)">
            <summary>
            </summary>
            <param name="sourcePortLocal"></param>
            <param name="targetPortLocal"></param>
            <param name="smooth"></param>
            <param name="smoothedPolyline"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.GetVisibilityGraph">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveEdgeRouter.CalculatePortVisibilityGraph(Microsoft.Msagl.Core.DataStructures.Set{Microsoft.Msagl.Core.Geometry.Point})">
            <summary>
            </summary>
            <param name="portLocationsPointSet"></param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.InteractiveObstacleCalculator">
            <summary>
            calculations with obstacles
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.Obstacles">
            <summary>
            the obstacles for routing
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.OverlapsDetected">
            <summary>
            Returns true if overlaps are detected in the initial set of TightObstacles.
            TightObstacles will then have been repaired by merging each overlapping group 
            of shapes into a single obstacle.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.TightObstacles">
            <summary>
            Before routing we pad shapes such that every point of the boundary
            of the padded shape is at least router.Padding outside the boundary of the original shape.
            We also add extra faces to round corners a little.  Edge paths are guaranteed not to come
            inside this padded TightObstacle boundary even after spline smoothing.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.LooseObstacles">
            <summary>
            We also pad TightObstacles by router.LoosePadding (where possible) to generate the shape
            overwhich the visibility graph is actually generated.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.RootOfTightHierarchy">
            <summary>
            Root of binary space partition tree used for rapid region queries over TightObstacles.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.RootOfLooseHierarchy">
            <summary>
            Root of binary space partition tree used for rapid region queries over LooseObstacles.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.Calculate">
            <summary>
            There are two sets of obstacles: tight and loose.
            We route the shortest path between LooseObstacles, and then smooth it with splines but without
            going inside TightObstacles.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreateLooseObstacles">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CreateTightObstacles">
             <summary>
             Handling overlapping obstacles:
              - create tightobstacles
              - find overlapping tightobstacles
                - replace with convexhull of overlapping
              
             Not particularly optimal method O(m * n log n) - where m is number of overlaps, n is number of obstacles:
            
             overlapping = 0
             do
               foreach o in TightObstacles:
                 I = set of all other obstacles which intersect o
                 if I != 0
                   overlapping = I + o
                   break  
               if overlapping != 0
                 combinedObstacle = new obstacle from convex hull of overlapping
                 tightObstacles.delete(overlapping)
                 tightObstacles.add(combinedObstacle)
             while overlapping != 0
             </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PadCorner(Microsoft.Msagl.Core.Geometry.Curves.Polyline,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,System.Double)">
            <summary>
            return true if succeeds and false if it is a non convex case
            </summary>
            <param name="poly"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.GetPaddedCorner(Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Curves.PolylinePoint,Microsoft.Msagl.Core.Geometry.Point@,Microsoft.Msagl.Core.Geometry.Point@,System.Double)">
            <summary>
            
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <param name="third"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="padding"></param>
            <returns>number of new points</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.CurveIsClockwise(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            in general works for convex curves
            </summary>
            <param name="iCurve"></param>
            <param name="pointInside"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(Microsoft.Msagl.Core.Geometry.Curves.ICurve,System.Double)">
            <summary>
            Creates a padded polyline boundary of the node. The polyline offsets at least as the padding from the node boundary.
            </summary>
            <param name="curve"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(Microsoft.Msagl.Core.Geometry.RectangleNode{Microsoft.Msagl.Core.Geometry.Curves.Polyline},Microsoft.Msagl.Core.Geometry.Curves.Polyline,System.Double)">
            <summary>
            Find tight obstacles close to the specified polyline and find the max amount of padding (up to
            desiredPadding) which can be applied to the polyline such that it will not overlap any of the
            surrounding polylines when they are also padded.  That is, we find the minimum separation
            between these shapes and divide by 2 (and a bit) - and if this is less than desiredPadding
            we return this as the amount to padd the polyline to create the looseObstacle.
            </summary>
            <param name="hierarchy"></param>
            <param name="polyline">a polyline to pad (tightObstacle)</param>
            <param name="desiredPadding">desired amount to pad</param>
            <returns>maximum amount we can pad without creating overlaps</returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.InteractiveObstacleCalculator.Inside(Microsoft.Msagl.Core.Geometry.Curves.ICurve,Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            we know here that there are no intersections between "curveUnderTest" and "curve",
            We are testing that curve is inside of "curveUnderTest"
            </summary>
            <param name="curveUnderTest"></param>
            <param name="curve"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.TollFreeVisibilityEdge">
            <summary>
            passing through such an edge does not cost anything
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.BimodalSequence">
            <summary>
            For our purposes, it suffices to define a bimodal function as
            one for which there is an r in [ 0, n-1] such that f(r), f(r + I), . . . , f(n), f( l), . . . ,
            f(r - 1) is unimodal. In our case no three sequential elements have the same value
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.BimodalSequence.Sequence">
            <summary>
            the sequence values
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.BimodalSequence.Length">
            <summary>
            the length of the sequence: the sequence starts from 0
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.LineSweeperBase.DirectionPerp">
            <summary>
            sweep direction rotated by 90 degrees clockwise
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.LineSweeperBase.Compare(Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent,Microsoft.Msagl.Routing.Spline.ConeSpanner.SweepEvent)">
            <summary>
            imagine that direction points up,
            lower events have higher priorities,
            for events at the same level events to the left have higher priority
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.ObstacleSideComparer.x">
            <summary>
            the intersection of the sweepline and the active segment
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.polygons">
            <summary>
            the list of obstacles
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.addedPolygons">
            <summary>
            From these polygons we calculate visibility edges to all other polygons
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.RunInternal">
            <summary>
            we calculate tangents between activePolygons and between activePolygons and existingObsacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.InitActiveDiagonals">
            <summary>
            this function will also add the first tangent to the visible edges if needed
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.InteractiveTangentVisibilityGraphCalculator.TangentComparison(Microsoft.Msagl.Routing.Visibility.Tangent,Microsoft.Msagl.Routing.Visibility.Tangent)">
            <summary>
            compare tangents by measuring the counterclockwise angle between the tangent and the edge
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator">
            <summary>
            following "Visibility Algorithms in the Plane", Ghosh
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.sideNodes">
            <summary>
            A mapping from sides to their RBNodes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.visibleBoundaries">
            <summary>
            These are parts of hole boundaries visible from q where each node is taken in isolation
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.CalculatePointVisibilityGraph(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.Polyline},Microsoft.Msagl.Routing.Visibility.VisibilityGraph,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Routing.Visibility.VisibilityKind,Microsoft.Msagl.Routing.Visibility.VisibilityVertex@)">
            <summary>
            We suppose that the holes are convex and oriented clockwis and are mutually disjoint
            </summary>
            <param name="listOfHoles"></param>
            <param name="visibilityGraph"></param>
            <param name="point">The point can belong to the boundary of one of the holes</param>
            <param name="visibilityKind">tangent or regural visibility</param>
            <param name="qVertex">the graph vertex corresponding to the pivot</param>        
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.SortSAndInitActiveSides">
            <summary>
            sorts the set of potentially visible vertices around point q
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.PointVisibilityCalculator.GetInitialVisibleBoundaryStemsAndInsertActiveSides">
            <summary>
            these are chuncks of the visible boundaries growing from the polyline  point just above its crossing with the horizontal ray or 
            from the visible part start
            In the general case we have two stems from one polyline
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.Polygon">
            <summary>
            the polygon is going clockwise
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.Polygon.Median(System.Int32,System.Int32)">
            <summary>
            the median of a chunk going clockwise from p1 to p2
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.Polygon.FindTheFurthestVertexFromBisector(System.Int32,System.Int32,Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            p1 and p2 represent the closest feature. Two cases are possible p1=p2, or p1 and p2 share an edge going from p1 to p2
            Remind that the polygons are oriented clockwise
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="bisectorPivot"></param>
            <param name="bisectorRay"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.Polygon.Distance(Microsoft.Msagl.Routing.Visibility.Polygon,Microsoft.Msagl.Routing.Visibility.Polygon,Microsoft.Msagl.Core.Geometry.Point@,Microsoft.Msagl.Core.Geometry.Point@)">
            <summary>
            Distance between two polygons
            p and q are the closest points
            The function doesn't work if the polygons intersect each other
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.Polygon.Distance(Microsoft.Msagl.Routing.Visibility.Polygon,Microsoft.Msagl.Routing.Visibility.Polygon)">
            <summary>
            Distance between two polygons
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.Polygon.Distance(Microsoft.Msagl.Routing.Visibility.Polygon,Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            Distance between polygon and point
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.StemStartPointComparer">
            <summary>
            compares couples only by looking at the couple first point
            we need the couple to hold the stem
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.UnimodalSequence">
            <summary>
            A real functionf defined on
            the integers 0, 1, . . . , n-1 is said to be unimodal if there exists an integer m such that f is strictly increasing (respectively, decreasing) on [ 0, m] and
            decreasing (respectively, increasing) on [m + 1, n-1]
            No three sequential elements have the same value
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Sequence">
            <summary>
            the sequence values
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.UnimodalSequence.Length">
            <summary>
            the length of the sequence: the sequence starts from 0
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.VisibilityKind">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.VisibilityKind.Regular">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.VisibilityKind.Tangent">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.VisibilityEdge">
            <summary>
            an edge connecting two VisibilityVertices
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.VisibilityEdge.IsPassable">
             <summary>
            returns true if and only if the edge can be passed
             </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.VisibilityEdge.SourcePoint">
            <summary>
            edge source point
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.VisibilityEdge.TargetPoint">
            <summary>
            edge target point
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.VisibilityEdge.ToString">
            <summary>
            Rounded representation; DebuggerDisplay shows the unrounded form.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.VisibilityGraph">
            <summary>
            the visibility graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.VisibilityGraph.PreviosVertex(Microsoft.Msagl.Routing.Visibility.VisibilityVertex)">
            <summary>
            needed for shortest path calculations
            </summary>        
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.VisibilityGraph.vertexFactory">
            <summary>
            the default is just to return VisibilityVertex
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.VisibilityGraph.GetVisibilityGraphForShortestPath(Microsoft.Msagl.Core.Geometry.Point,Microsoft.Msagl.Core.Geometry.Point,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.Polyline},Microsoft.Msagl.Routing.Visibility.VisibilityVertex@,Microsoft.Msagl.Routing.Visibility.VisibilityVertex@)">
            <summary>
            
            </summary>
            <param name="pathStart"></param>
            <param name="pathEnd"></param>
            <param name="obstacles"></param>
            <param name="sourceVertex">graph vertex corresponding to the source</param>
            <param name="targetVertex">graph vertex corresponding to the target</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.VisibilityGraph.FillVisibilityGraphForShortestPath(System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Geometry.Curves.Polyline})">
            <summary>
            Calculates the tangent visibility graph
            </summary>
            <param name="obstacles">a list of polylines representing obstacles</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.VisibilityGraph.Edges">
            <summary>
            Enumerate all VisibilityEdges in the VisibilityGraph.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.VisibilityVertex.OutEdges">
            <summary>
            this collection is sorted by the target point, in the lexicographical order
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.VisibilityVertex.Distance">
            <summary>
            needed for shortest path calculations
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.VisibilityVertex.ToString">
            <summary>
            Rounded representation; DebuggerDisplay shows the unrounded form.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.VisibilityVertex.RemoveOutEdge(Microsoft.Msagl.Routing.Visibility.VisibilityEdge)">
            <summary>
            These iterate from the end of the list because List.Remove is linear in
            the number of items, so callers have been optimized where possible to
            remove only the last or next-to-last edges (but in some cases such as
            rectilinear, this optimization isn't always possible).
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.VisibilityVertex.FindFirst(Microsoft.Msagl.Core.DataStructures.RbTree{Microsoft.Msagl.Routing.Visibility.VisibilityEdge},Microsoft.Msagl.Core.Geometry.Point)">
            <summary>
            avoiding using delegates in calling RBTree.FindFirst because of the memory allocations
            </summary>
            <param name="tree"></param>
            <param name="targetPoint"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.Stem">
            <summary>
            represents a chunk of a hole boundary
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Visibility.Tangent.Diagonal">
            <summary>
            the diagonal will be not a null only when it is active
            </summary>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Visibility.TangentPair">
            <summary>
            calculates the pair of tangent line segments between two convex non-intersecting polygons H and Q
            we suppose that polygons are clockwise oriented
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.TangentPair.TangentBetweenBranches(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            we pretend here that the branches go clockwise from p0 to p1, and from q0 to q1 
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="q0"></param>
            <param name="q1"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.TangentPair.FindDividingBisector(Microsoft.Msagl.Core.Geometry.Point@,Microsoft.Msagl.Core.Geometry.Point@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            following the paper of Edelsbrunner
            </summary>
            <param name="bisectorPivot"></param>
            <param name="bisectorRay"></param>
            <param name="p1">the closest feature start</param>
            <param name="p2">the closest feature end</param>
            <param name="q1">the closest feature end</param>
            <param name="q2">the closest feature start</param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.TangentPair.OnlyOneChunkContainsExactlyTwoVertices(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            we know here that p1!=p2 and q1!=q2
            </summary>
            <param name="p2"></param>
            <param name="p1"></param>
            <param name="q2"></param>
            <param name="q1"></param>
            <param name="mp"></param>
            <param name="mq"></param>
            <param name="a1"></param>
            <param name="b1"></param>
            <param name="a2"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.polygons">
            <summary>
            the list of obstacles
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.InitActiveDiagonals">
            <summary>
            this function will also add the first tangent to the visible edges if needed
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Visibility.TangentVisibilityGraphCalculator.TangentComparison(Microsoft.Msagl.Routing.Visibility.Tangent,Microsoft.Msagl.Routing.Visibility.Tangent)">
            <summary>
            compare tangents by measuring the counterclockwise angle between the tangent and the edge
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Msagl.Routing.RelativeShape">
            <summary>
            A shape wrapping an ICurve delegate, providing additional information.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.RelativeShape.BoundaryCurve">
            <summary>
            The curve of the shape.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.RelativeShape.#ctor(System.Func{Microsoft.Msagl.Core.Geometry.Curves.ICurve})">
            <summary>
            Constructor taking the ID and the curve delegate for the shape.
            </summary>
            <param name="curveDelegate"></param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.Shape">
            <summary>
            A shape wrapping an ICurve, providing additional information.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Shape.Parents">
            <summary>
             shape parents
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Shape.Children">
            <summary>
            shape children
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Shape.BoundaryCurve">
            <summary>
            The curve of the shape.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Shape.BoundingBox">
            <summary>
            The bounding box of the shape.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Shape.Ports">
            <summary>
            The set of Ports for this obstacle, usually RelativePorts.  In the event of overlapping
            obstacles, this identifies the obstacle to which the port applies.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Shape.UserData">
            <summary>
            A location for storing user data associated with the Shape.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Shape.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Shape.#ctor(Microsoft.Msagl.Core.Geometry.Curves.ICurve)">
            <summary>
            Constructor taking the ID and the curve of the shape.
            </summary>
            <param name="boundaryCurve"></param>
        </member>
        <member name="P:Microsoft.Msagl.Routing.Shape.IsGroup">
            <summary>
            A group is a shape that has children.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Shape.AddParent(Microsoft.Msagl.Routing.Shape)">
            <summary>
             Adds a parent. A shape can have several parents
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Shape.AddChild(Microsoft.Msagl.Routing.Shape)">
            <summary>
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Shape.RemoveChild(Microsoft.Msagl.Routing.Shape)">
            <summary>
            
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.Shape.RemoveParent(Microsoft.Msagl.Routing.Shape)">
            <summary>
            
            </summary>
            <param name="shape"></param>
        </member>
        <member name="T:Microsoft.Msagl.Routing.SplineRouter">
            <summary>
             routing splines around shapes
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.SplineRouter.continueOnOverlaps">
            <summary>
            setting this to true forces the calculation to go on even when node overlaps are present
            </summary>
            
        </member>
        <member name="F:Microsoft.Msagl.Routing.SplineRouter.UsePolylineEndShortcutting">
            <summary>
            if set to true the algorithm will try to shortcut a shortest polyline inner points
            </summary>
        </member>
        <member name="F:Microsoft.Msagl.Routing.SplineRouter.UseInnerPolylingShortcutting">
            <summary>
            if set to true the algorithm will try to shortcut a shortest polyline start and end
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,Microsoft.Msagl.Core.Routing.EdgeRoutingSettings)">
            <summary>
            Creates a spline group router for the given graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double,System.Double)">
            <summary>
            Creates a spline group router for the given graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double,System.Double,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Creates a spline group router for the given graph
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Collections.Generic.IEnumerable{Microsoft.Msagl.Core.Layout.Edge},System.Double,System.Double,System.Double,Microsoft.Msagl.Core.Routing.BundlingSettings)">
            <summary>
            Creates a spline group router for the given graph.
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.#ctor(Microsoft.Msagl.Core.Layout.GeometryGraph,System.Double,System.Double,System.Double,System.Collections.Generic.List{Microsoft.Msagl.Core.Layout.Edge},System.Collections.Generic.List{Microsoft.Msagl.Core.Layout.Edge})">
            <summary>
            
            </summary>
            <param name="graph"></param>
            <param name="tightPadding"></param>
            <param name="loosePadding"></param>
            <param name="coneAngle"></param>
            <param name="inParentEdges"></param>
            <param name="outParentEdges"></param>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.RunInternal">
            <summary>
            Executes the algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.SplineRouter.OverlapsDetected">
            <summary>
            set to true if and only if there are overlaps in tight obstacles
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.SplineRouter.RouteMultiEdgesAsBundles">
            <summary>
            if set to true routes multi edges as ordered bundles
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.SplineRouter.CacheCornersForSmoothing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.EdgePassport(Microsoft.Msagl.Core.Layout.Edge)">
            <summary>
             The set of shapes where the edgeGeometry source and target ports shapes are citizens.
             In the simple case it is the union of the target port shape parents and the sourceport shape parents.
             When one end shape contains another, the passport is the set consisting of the end shape and all other shape parents.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Msagl.Routing.SplineRouter.KeepOriginalSpline">
            <summary>
            if set to true the original spline is kept under the corresponding EdgeGeometry
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.SplineRouter.ArrowHeadRatio">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.AddVisibilityEdgesFromPort(Microsoft.Msagl.Core.Layout.Port)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.FillVisibilityGraphUnderShape(Microsoft.Msagl.Routing.Shape)">
            <summary>
            this function might change the shape's loose polylines by inserting new points
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Routing.SplineRouter.Bidirectional">
            <summary>
            If set to true then a smaller visibility graph is created.
            An edge is added to the visibility graph only if it is found at least twice: 
            once sweeping with a direction d and the second time with -d
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.GetOrCreateRoot">
            <summary>
            creates a root; a shape with BoundaryCurve set to null 
            </summary>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SplineRouter.ComputeLooseSplinePadding(System.Double,System.Double)">
            <summary>
             computes loosePadding for spline routing obstacles from node separation and EdgePadding.
            </summary>
            <param name="nodeSeparation"></param>
            <param name="edgePadding"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Msagl.Routing.SingleSourceSingleTargetShortestPathOnVisibilityGraph.GetPath(System.Boolean)">
            <summary>
            Returns  a  path
            </summary>
            <returns>a path or null if the target is not reachable from the source</returns>
        </member>
        <member name="T:Microsoft.Msagl.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.Msagl.Strings.ParallelOperationCanceledExceptionMessage">
            <summary>
              Looks up a localized string similar to A part of the parallel operation was canceled.  See the inner exception..
            </summary>
        </member>
    </members>
</doc>
