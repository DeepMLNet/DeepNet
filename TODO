
- Port the optimizer, since it worked on Exprs before and should thus be not difficult to port.
- or do the evaluator first, since we might want the optimizer to depend on it?
- how would a good evaluator work?

- well, for most simple case, we can implement the simpleEval thing
- this, however has shown, that it runs out of memory quickly

- not entirely clear how BaseEval will be separated from compiled eval
- is it mostly about memory-allocation?
- it was also about stream allocation and efficient re-run...
-


- it would make sense to write basic tests
  i.e. create expression
  derive expression
  access channels of expression
  try slicing
  - no real basic tests exist yet, so we should write them

- Interpolator should probably be moved to tensor


- check if anything useful is left in UExpr
   - yes, Loop channel trimmer. => see where to move that. optimizer?



1. implement var updating expression => DONE
2. think about eval interfaces, i.e. functions etc. => reintroduce function interface with and without EvalEnv
3. think about how to integrate trace and dump without global variables or with thread local variables => specify tracers in EvalEnv
4. think about how to output the graph for visualization along with values for each iteration => use tracers
5. port optimizers
